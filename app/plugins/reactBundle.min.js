require = function() {
    function r(e, n, t) {
        function o(i, f) {
            if (!n[i]) {
                if (!e[i]) {
                    var c = "function" == typeof require && require;
                    if (!f && c) return c(i, !0);
                    if (u) return u(i, !0);
                    var a = new Error("Cannot find module '" + i + "'");
                    throw a.code = "MODULE_NOT_FOUND", a;
                }
                var p = n[i] = {
                    exports: {}
                };
                e[i][0].call(p.exports, function(r) {
                    var n = e[i][1][r];
                    return o(n || r);
                }, p, p.exports, r, e, n, t);
            }
            return n[i].exports;
        }
        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
        return o;
    }
    return r;
}()({
    1: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var emptyFunction = require("./emptyFunction");
            var EventListener = {
                listen: function listen(target, eventType, callback) {
                    if (target.addEventListener) {
                        target.addEventListener(eventType, callback, false);
                        return {
                            remove: function remove() {
                                target.removeEventListener(eventType, callback, false);
                            }
                        };
                    } else if (target.attachEvent) {
                        target.attachEvent("on" + eventType, callback);
                        return {
                            remove: function remove() {
                                target.detachEvent("on" + eventType, callback);
                            }
                        };
                    }
                },
                capture: function capture(target, eventType, callback) {
                    if (target.addEventListener) {
                        target.addEventListener(eventType, callback, true);
                        return {
                            remove: function remove() {
                                target.removeEventListener(eventType, callback, true);
                            }
                        };
                    } else {
                        if (process.env.NODE_ENV !== "production") {
                            console.error("Attempted to listen to events during the capture phase on a " + "browser that does not support the capture phase. Your application " + "will not receive some events.");
                        }
                        return {
                            remove: emptyFunction
                        };
                    }
                },
                registerDefault: function registerDefault() {}
            };
            module.exports = EventListener;
        }).call(this, require("_process"));
    }, {
        "./emptyFunction": 6,
        _process: 19
    } ],
    2: [ function(require, module, exports) {
        "use strict";
        var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
        var ExecutionEnvironment = {
            canUseDOM: canUseDOM,
            canUseWorkers: typeof Worker !== "undefined",
            canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
            canUseViewport: canUseDOM && !!window.screen,
            isInWorker: !canUseDOM
        };
        module.exports = ExecutionEnvironment;
    }, {} ],
    3: [ function(require, module, exports) {
        "use strict";
        var _hyphenPattern = /-(.)/g;
        function camelize(string) {
            return string.replace(_hyphenPattern, function(_, character) {
                return character.toUpperCase();
            });
        }
        module.exports = camelize;
    }, {} ],
    4: [ function(require, module, exports) {
        "use strict";
        var camelize = require("./camelize");
        var msPattern = /^-ms-/;
        function camelizeStyleName(string) {
            return camelize(string.replace(msPattern, "ms-"));
        }
        module.exports = camelizeStyleName;
    }, {
        "./camelize": 3
    } ],
    5: [ function(require, module, exports) {
        "use strict";
        var isTextNode = require("./isTextNode");
        function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
                return false;
            } else if (outerNode === innerNode) {
                return true;
            } else if (isTextNode(outerNode)) {
                return false;
            } else if (isTextNode(innerNode)) {
                return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
                return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
                return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
                return false;
            }
        }
        module.exports = containsNode;
    }, {
        "./isTextNode": 14
    } ],
    6: [ function(require, module, exports) {
        "use strict";
        function makeEmptyFunction(arg) {
            return function() {
                return arg;
            };
        }
        var emptyFunction = function emptyFunction() {};
        emptyFunction.thatReturns = makeEmptyFunction;
        emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
        emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
        emptyFunction.thatReturnsNull = makeEmptyFunction(null);
        emptyFunction.thatReturnsThis = function() {
            return this;
        };
        emptyFunction.thatReturnsArgument = function(arg) {
            return arg;
        };
        module.exports = emptyFunction;
    }, {} ],
    7: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var emptyObject = {};
            if (process.env.NODE_ENV !== "production") {
                Object.freeze(emptyObject);
            }
            module.exports = emptyObject;
        }).call(this, require("_process"));
    }, {
        _process: 19
    } ],
    8: [ function(require, module, exports) {
        "use strict";
        function focusNode(node) {
            try {
                node.focus();
            } catch (e) {}
        }
        module.exports = focusNode;
    }, {} ],
    9: [ function(require, module, exports) {
        "use strict";
        function getActiveElement(doc) {
            doc = doc || (typeof document !== "undefined" ? document : undefined);
            if (typeof doc === "undefined") {
                return null;
            }
            try {
                return doc.activeElement || doc.body;
            } catch (e) {
                return doc.body;
            }
        }
        module.exports = getActiveElement;
    }, {} ],
    10: [ function(require, module, exports) {
        "use strict";
        var _uppercasePattern = /([A-Z])/g;
        function hyphenate(string) {
            return string.replace(_uppercasePattern, "-$1").toLowerCase();
        }
        module.exports = hyphenate;
    }, {} ],
    11: [ function(require, module, exports) {
        "use strict";
        var hyphenate = require("./hyphenate");
        var msPattern = /^ms-/;
        function hyphenateStyleName(string) {
            return hyphenate(string).replace(msPattern, "-ms-");
        }
        module.exports = hyphenateStyleName;
    }, {
        "./hyphenate": 10
    } ],
    12: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var validateFormat = function validateFormat(format) {};
            if (process.env.NODE_ENV !== "production") {
                validateFormat = function validateFormat(format) {
                    if (format === undefined) {
                        throw new Error("invariant requires an error message argument");
                    }
                };
            }
            function invariant(condition, format, a, b, c, d, e, f) {
                validateFormat(format);
                if (!condition) {
                    var error;
                    if (format === undefined) {
                        error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
                    } else {
                        var args = [ a, b, c, d, e, f ];
                        var argIndex = 0;
                        error = new Error(format.replace(/%s/g, function() {
                            return args[argIndex++];
                        }));
                        error.name = "Invariant Violation";
                    }
                    error.framesToPop = 1;
                    throw error;
                }
            }
            module.exports = invariant;
        }).call(this, require("_process"));
    }, {
        _process: 19
    } ],
    13: [ function(require, module, exports) {
        "use strict";
        function isNode(object) {
            var doc = object ? object.ownerDocument || object : document;
            var defaultView = doc.defaultView || window;
            return !!(object && (typeof defaultView.Node === "function" ? object instanceof defaultView.Node : typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string"));
        }
        module.exports = isNode;
    }, {} ],
    14: [ function(require, module, exports) {
        "use strict";
        var isNode = require("./isNode");
        function isTextNode(object) {
            return isNode(object) && object.nodeType == 3;
        }
        module.exports = isTextNode;
    }, {
        "./isNode": 13
    } ],
    15: [ function(require, module, exports) {
        "use strict";
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function is(x, y) {
            if (x === y) {
                return x !== 0 || y !== 0 || 1 / x === 1 / y;
            } else {
                return x !== x && y !== y;
            }
        }
        function shallowEqual(objA, objB) {
            if (is(objA, objB)) {
                return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
                return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
                return false;
            }
            for (var i = 0; i < keysA.length; i++) {
                if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
                    return false;
                }
            }
            return true;
        }
        module.exports = shallowEqual;
    }, {} ],
    16: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var emptyFunction = require("./emptyFunction");
            var warning = emptyFunction;
            if (process.env.NODE_ENV !== "production") {
                var printWarning = function printWarning(format) {
                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }
                    var argIndex = 0;
                    var message = "Warning: " + format.replace(/%s/g, function() {
                        return args[argIndex++];
                    });
                    if (typeof console !== "undefined") {
                        console.error(message);
                    }
                    try {
                        throw new Error(message);
                    } catch (x) {}
                };
                warning = function warning(condition, format) {
                    if (format === undefined) {
                        throw new Error("`warning(condition, format, ...args)` requires a warning " + "message argument");
                    }
                    if (format.indexOf("Failed Composite propType: ") === 0) {
                        return;
                    }
                    if (!condition) {
                        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                            args[_key2 - 2] = arguments[_key2];
                        }
                        printWarning.apply(undefined, [ format ].concat(args));
                    }
                };
            }
            module.exports = warning;
        }).call(this, require("_process"));
    }, {
        "./emptyFunction": 6,
        _process: 19
    } ],
    17: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            exports.__esModule = true;
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            var invariant = require("fbjs/lib/invariant");
            var _prefix = "ID_";
            var Dispatcher = function() {
                function Dispatcher() {
                    _classCallCheck(this, Dispatcher);
                    this._callbacks = {};
                    this._isDispatching = false;
                    this._isHandled = {};
                    this._isPending = {};
                    this._lastID = 1;
                }
                Dispatcher.prototype.register = function register(callback) {
                    var id = _prefix + this._lastID++;
                    this._callbacks[id] = callback;
                    return id;
                };
                Dispatcher.prototype.unregister = function unregister(id) {
                    !this._callbacks[id] ? process.env.NODE_ENV !== "production" ? invariant(false, "Dispatcher.unregister(...): `%s` does not map to a registered callback.", id) : invariant(false) : undefined;
                    delete this._callbacks[id];
                };
                Dispatcher.prototype.waitFor = function waitFor(ids) {
                    !this._isDispatching ? process.env.NODE_ENV !== "production" ? invariant(false, "Dispatcher.waitFor(...): Must be invoked while dispatching.") : invariant(false) : undefined;
                    for (var ii = 0; ii < ids.length; ii++) {
                        var id = ids[ii];
                        if (this._isPending[id]) {
                            !this._isHandled[id] ? process.env.NODE_ENV !== "production" ? invariant(false, "Dispatcher.waitFor(...): Circular dependency detected while " + "waiting for `%s`.", id) : invariant(false) : undefined;
                            continue;
                        }
                        !this._callbacks[id] ? process.env.NODE_ENV !== "production" ? invariant(false, "Dispatcher.waitFor(...): `%s` does not map to a registered callback.", id) : invariant(false) : undefined;
                        this._invokeCallback(id);
                    }
                };
                Dispatcher.prototype.dispatch = function dispatch(payload) {
                    !!this._isDispatching ? process.env.NODE_ENV !== "production" ? invariant(false, "Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.") : invariant(false) : undefined;
                    this._startDispatching(payload);
                    try {
                        for (var id in this._callbacks) {
                            if (this._isPending[id]) {
                                continue;
                            }
                            this._invokeCallback(id);
                        }
                    } finally {
                        this._stopDispatching();
                    }
                };
                Dispatcher.prototype.isDispatching = function isDispatching() {
                    return this._isDispatching;
                };
                Dispatcher.prototype._invokeCallback = function _invokeCallback(id) {
                    this._isPending[id] = true;
                    this._callbacks[id](this._pendingPayload);
                    this._isHandled[id] = true;
                };
                Dispatcher.prototype._startDispatching = function _startDispatching(payload) {
                    for (var id in this._callbacks) {
                        this._isPending[id] = false;
                        this._isHandled[id] = false;
                    }
                    this._pendingPayload = payload;
                    this._isDispatching = true;
                };
                Dispatcher.prototype._stopDispatching = function _stopDispatching() {
                    delete this._pendingPayload;
                    this._isDispatching = false;
                };
                return Dispatcher;
            }();
            module.exports = Dispatcher;
        }).call(this, require("_process"));
    }, {
        _process: 19,
        "fbjs/lib/invariant": 12
    } ],
    18: [ function(require, module, exports) {
        "use strict";
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
            if (val === null || val === undefined) {
                throw new TypeError("Object.assign cannot be called with null or undefined");
            }
            return Object(val);
        }
        function shouldUseNative() {
            try {
                if (!Object.assign) {
                    return false;
                }
                var test1 = new String("abc");
                test1[5] = "de";
                if (Object.getOwnPropertyNames(test1)[0] === "5") {
                    return false;
                }
                var test2 = {};
                for (var i = 0; i < 10; i++) {
                    test2["_" + String.fromCharCode(i)] = i;
                }
                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                });
                if (order2.join("") !== "0123456789") {
                    return false;
                }
                var test3 = {};
                "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                    test3[letter] = letter;
                });
                if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                    return false;
                }
                return true;
            } catch (err) {
                return false;
            }
        }
        module.exports = shouldUseNative() ? Object.assign : function(target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for (var s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);
                for (var key in from) {
                    if (hasOwnProperty.call(from, key)) {
                        to[key] = from[key];
                    }
                }
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) {
                        if (propIsEnumerable.call(from, symbols[i])) {
                            to[symbols[i]] = from[symbols[i]];
                        }
                    }
                }
            }
            return to;
        };
    }, {} ],
    19: [ function(require, module, exports) {
        var process = module.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        (function() {
            try {
                if (typeof setTimeout === "function") {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                if (typeof clearTimeout === "function") {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        })();
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }
            try {
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }
            try {
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }
        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        };
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {}
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name) {
            return [];
        };
        process.binding = function(name) {
            throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
            return "/";
        };
        process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
            return 0;
        };
    }, {} ],
    20: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            if (process.env.NODE_ENV !== "production") {
                var invariant = require("fbjs/lib/invariant");
                var warning = require("fbjs/lib/warning");
                var ReactPropTypesSecret = require("./lib/ReactPropTypesSecret");
                var loggedTypeFailures = {};
            }
            function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
                if (process.env.NODE_ENV !== "production") {
                    for (var typeSpecName in typeSpecs) {
                        if (typeSpecs.hasOwnProperty(typeSpecName)) {
                            var error;
                            try {
                                invariant(typeof typeSpecs[typeSpecName] === "function", "%s: %s type `%s` is invalid; it must be a function, usually from " + "the `prop-types` package, but received `%s`.", componentName || "React class", location, typeSpecName, typeof typeSpecs[typeSpecName]);
                                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                            } catch (ex) {
                                error = ex;
                            }
                            warning(!error || error instanceof Error, "%s: type specification of %s `%s` is invalid; the type checker " + "function must return `null` or an `Error` but returned a %s. " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error);
                            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                                loggedTypeFailures[error.message] = true;
                                var stack = getStack ? getStack() : "";
                                warning(false, "Failed %s type: %s%s", location, error.message, stack != null ? stack : "");
                            }
                        }
                    }
                }
            }
            module.exports = checkPropTypes;
        }).call(this, require("_process"));
    }, {
        "./lib/ReactPropTypesSecret": 21,
        _process: 19,
        "fbjs/lib/invariant": 12,
        "fbjs/lib/warning": 16
    } ],
    21: [ function(require, module, exports) {
        "use strict";
        var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
        module.exports = ReactPropTypesSecret;
    }, {} ],
    22: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            if (process.env.NODE_ENV !== "production") {
                (function() {
                    "use strict";
                    var React = require("react");
                    var invariant = require("fbjs/lib/invariant");
                    var warning = require("fbjs/lib/warning");
                    var ExecutionEnvironment = require("fbjs/lib/ExecutionEnvironment");
                    var _assign = require("object-assign");
                    var emptyFunction = require("fbjs/lib/emptyFunction");
                    var EventListener = require("fbjs/lib/EventListener");
                    var getActiveElement = require("fbjs/lib/getActiveElement");
                    var shallowEqual = require("fbjs/lib/shallowEqual");
                    var containsNode = require("fbjs/lib/containsNode");
                    var focusNode = require("fbjs/lib/focusNode");
                    var emptyObject = require("fbjs/lib/emptyObject");
                    var checkPropTypes = require("prop-types/checkPropTypes");
                    var hyphenateStyleName = require("fbjs/lib/hyphenateStyleName");
                    var camelizeStyleName = require("fbjs/lib/camelizeStyleName");
                    !React ? invariant(false, "ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.") : void 0;
                    var RESERVED_PROPS = {
                        children: true,
                        dangerouslySetInnerHTML: true,
                        defaultValue: true,
                        defaultChecked: true,
                        innerHTML: true,
                        suppressContentEditableWarning: true,
                        suppressHydrationWarning: true,
                        style: true
                    };
                    function checkMask(value, bitmask) {
                        return (value & bitmask) === bitmask;
                    }
                    var DOMPropertyInjection = {
                        MUST_USE_PROPERTY: 1,
                        HAS_BOOLEAN_VALUE: 4,
                        HAS_NUMERIC_VALUE: 8,
                        HAS_POSITIVE_NUMERIC_VALUE: 16 | 8,
                        HAS_OVERLOADED_BOOLEAN_VALUE: 32,
                        HAS_STRING_BOOLEAN_VALUE: 64,
                        injectDOMPropertyConfig: function(domPropertyConfig) {
                            var Injection = DOMPropertyInjection;
                            var Properties = domPropertyConfig.Properties || {};
                            var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
                            var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
                            var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
                            for (var propName in Properties) {
                                !!properties.hasOwnProperty(propName) ? invariant(false, "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.", propName) : void 0;
                                var lowerCased = propName.toLowerCase();
                                var propConfig = Properties[propName];
                                var propertyInfo = {
                                    attributeName: lowerCased,
                                    attributeNamespace: null,
                                    propertyName: propName,
                                    mutationMethod: null,
                                    mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
                                    hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
                                    hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
                                    hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
                                    hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),
                                    hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)
                                };
                                !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, "DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s", propName) : void 0;
                                if (DOMAttributeNames.hasOwnProperty(propName)) {
                                    var attributeName = DOMAttributeNames[propName];
                                    propertyInfo.attributeName = attributeName;
                                }
                                if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
                                    propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
                                }
                                if (DOMMutationMethods.hasOwnProperty(propName)) {
                                    propertyInfo.mutationMethod = DOMMutationMethods[propName];
                                }
                                properties[propName] = propertyInfo;
                            }
                        }
                    };
                    var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
                    var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
                    var ROOT_ATTRIBUTE_NAME = "data-reactroot";
                    var properties = {};
                    function shouldSetAttribute(name, value) {
                        if (isReservedProp(name)) {
                            return false;
                        }
                        if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
                            return false;
                        }
                        if (value === null) {
                            return true;
                        }
                        switch (typeof value) {
                          case "boolean":
                            return shouldAttributeAcceptBooleanValue(name);

                          case "undefined":
                          case "number":
                          case "string":
                          case "object":
                            return true;

                          default:
                            return false;
                        }
                    }
                    function getPropertyInfo(name) {
                        return properties.hasOwnProperty(name) ? properties[name] : null;
                    }
                    function shouldAttributeAcceptBooleanValue(name) {
                        if (isReservedProp(name)) {
                            return true;
                        }
                        var propertyInfo = getPropertyInfo(name);
                        if (propertyInfo) {
                            return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;
                        }
                        var prefix = name.toLowerCase().slice(0, 5);
                        return prefix === "data-" || prefix === "aria-";
                    }
                    function isReservedProp(name) {
                        return RESERVED_PROPS.hasOwnProperty(name);
                    }
                    var injection = DOMPropertyInjection;
                    var MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;
                    var HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;
                    var HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;
                    var HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;
                    var HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;
                    var HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;
                    var HTMLDOMPropertyConfig = {
                        Properties: {
                            allowFullScreen: HAS_BOOLEAN_VALUE,
                            async: HAS_BOOLEAN_VALUE,
                            autoFocus: HAS_BOOLEAN_VALUE,
                            autoPlay: HAS_BOOLEAN_VALUE,
                            capture: HAS_OVERLOADED_BOOLEAN_VALUE,
                            checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                            cols: HAS_POSITIVE_NUMERIC_VALUE,
                            contentEditable: HAS_STRING_BOOLEAN_VALUE,
                            controls: HAS_BOOLEAN_VALUE,
                            default: HAS_BOOLEAN_VALUE,
                            defer: HAS_BOOLEAN_VALUE,
                            disabled: HAS_BOOLEAN_VALUE,
                            download: HAS_OVERLOADED_BOOLEAN_VALUE,
                            draggable: HAS_STRING_BOOLEAN_VALUE,
                            formNoValidate: HAS_BOOLEAN_VALUE,
                            hidden: HAS_BOOLEAN_VALUE,
                            loop: HAS_BOOLEAN_VALUE,
                            multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                            muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                            noValidate: HAS_BOOLEAN_VALUE,
                            open: HAS_BOOLEAN_VALUE,
                            playsInline: HAS_BOOLEAN_VALUE,
                            readOnly: HAS_BOOLEAN_VALUE,
                            required: HAS_BOOLEAN_VALUE,
                            reversed: HAS_BOOLEAN_VALUE,
                            rows: HAS_POSITIVE_NUMERIC_VALUE,
                            rowSpan: HAS_NUMERIC_VALUE,
                            scoped: HAS_BOOLEAN_VALUE,
                            seamless: HAS_BOOLEAN_VALUE,
                            selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                            size: HAS_POSITIVE_NUMERIC_VALUE,
                            start: HAS_NUMERIC_VALUE,
                            span: HAS_POSITIVE_NUMERIC_VALUE,
                            spellCheck: HAS_STRING_BOOLEAN_VALUE,
                            style: 0,
                            tabIndex: 0,
                            itemScope: HAS_BOOLEAN_VALUE,
                            acceptCharset: 0,
                            className: 0,
                            htmlFor: 0,
                            httpEquiv: 0,
                            value: HAS_STRING_BOOLEAN_VALUE
                        },
                        DOMAttributeNames: {
                            acceptCharset: "accept-charset",
                            className: "class",
                            htmlFor: "for",
                            httpEquiv: "http-equiv"
                        },
                        DOMMutationMethods: {
                            value: function(node, value) {
                                if (value == null) {
                                    return node.removeAttribute("value");
                                }
                                if (node.type !== "number" || node.hasAttribute("value") === false) {
                                    node.setAttribute("value", "" + value);
                                } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
                                    node.setAttribute("value", "" + value);
                                }
                            }
                        }
                    };
                    var HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;
                    var NS = {
                        xlink: "http://www.w3.org/1999/xlink",
                        xml: "http://www.w3.org/XML/1998/namespace"
                    };
                    var ATTRS = [ "accent-height", "alignment-baseline", "arabic-form", "baseline-shift", "cap-height", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "dominant-baseline", "enable-background", "fill-opacity", "fill-rule", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "glyph-name", "glyph-orientation-horizontal", "glyph-orientation-vertical", "horiz-adv-x", "horiz-origin-x", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "overline-position", "overline-thickness", "paint-order", "panose-1", "pointer-events", "rendering-intent", "shape-rendering", "stop-color", "stop-opacity", "strikethrough-position", "strikethrough-thickness", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-rendering", "underline-position", "underline-thickness", "unicode-bidi", "unicode-range", "units-per-em", "v-alphabetic", "v-hanging", "v-ideographic", "v-mathematical", "vector-effect", "vert-adv-y", "vert-origin-x", "vert-origin-y", "word-spacing", "writing-mode", "x-height", "xlink:actuate", "xlink:arcrole", "xlink:href", "xlink:role", "xlink:show", "xlink:title", "xlink:type", "xml:base", "xmlns:xlink", "xml:lang", "xml:space" ];
                    var SVGDOMPropertyConfig = {
                        Properties: {
                            autoReverse: HAS_STRING_BOOLEAN_VALUE$1,
                            externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,
                            preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1
                        },
                        DOMAttributeNames: {
                            autoReverse: "autoReverse",
                            externalResourcesRequired: "externalResourcesRequired",
                            preserveAlpha: "preserveAlpha"
                        },
                        DOMAttributeNamespaces: {
                            xlinkActuate: NS.xlink,
                            xlinkArcrole: NS.xlink,
                            xlinkHref: NS.xlink,
                            xlinkRole: NS.xlink,
                            xlinkShow: NS.xlink,
                            xlinkTitle: NS.xlink,
                            xlinkType: NS.xlink,
                            xmlBase: NS.xml,
                            xmlLang: NS.xml,
                            xmlSpace: NS.xml
                        }
                    };
                    var CAMELIZE = /[\-\:]([a-z])/g;
                    var capitalize = function(token) {
                        return token[1].toUpperCase();
                    };
                    ATTRS.forEach(function(original) {
                        var reactName = original.replace(CAMELIZE, capitalize);
                        SVGDOMPropertyConfig.Properties[reactName] = 0;
                        SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;
                    });
                    injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
                    injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);
                    var ReactErrorUtils = {
                        _caughtError: null,
                        _hasCaughtError: false,
                        _rethrowError: null,
                        _hasRethrowError: false,
                        injection: {
                            injectErrorUtils: function(injectedErrorUtils) {
                                !(typeof injectedErrorUtils.invokeGuardedCallback === "function") ? invariant(false, "Injected invokeGuardedCallback() must be a function.") : void 0;
                                invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;
                            }
                        },
                        invokeGuardedCallback: function(name, func, context, a, b, c, d, e, f) {
                            invokeGuardedCallback.apply(ReactErrorUtils, arguments);
                        },
                        invokeGuardedCallbackAndCatchFirstError: function(name, func, context, a, b, c, d, e, f) {
                            ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);
                            if (ReactErrorUtils.hasCaughtError()) {
                                var error = ReactErrorUtils.clearCaughtError();
                                if (!ReactErrorUtils._hasRethrowError) {
                                    ReactErrorUtils._hasRethrowError = true;
                                    ReactErrorUtils._rethrowError = error;
                                }
                            }
                        },
                        rethrowCaughtError: function() {
                            return rethrowCaughtError.apply(ReactErrorUtils, arguments);
                        },
                        hasCaughtError: function() {
                            return ReactErrorUtils._hasCaughtError;
                        },
                        clearCaughtError: function() {
                            if (ReactErrorUtils._hasCaughtError) {
                                var error = ReactErrorUtils._caughtError;
                                ReactErrorUtils._caughtError = null;
                                ReactErrorUtils._hasCaughtError = false;
                                return error;
                            } else {
                                invariant(false, "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
                            }
                        }
                    };
                    var invokeGuardedCallback = function(name, func, context, a, b, c, d, e, f) {
                        ReactErrorUtils._hasCaughtError = false;
                        ReactErrorUtils._caughtError = null;
                        var funcArgs = Array.prototype.slice.call(arguments, 3);
                        try {
                            func.apply(context, funcArgs);
                        } catch (error) {
                            ReactErrorUtils._caughtError = error;
                            ReactErrorUtils._hasCaughtError = true;
                        }
                    };
                    {
                        if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
                            var fakeNode = document.createElement("react");
                            var invokeGuardedCallbackDev = function(name, func, context, a, b, c, d, e, f) {
                                var didError = true;
                                var funcArgs = Array.prototype.slice.call(arguments, 3);
                                function callCallback() {
                                    fakeNode.removeEventListener(evtType, callCallback, false);
                                    func.apply(context, funcArgs);
                                    didError = false;
                                }
                                var error = void 0;
                                var didSetError = false;
                                var isCrossOriginError = false;
                                function onError(event) {
                                    error = event.error;
                                    didSetError = true;
                                    if (error === null && event.colno === 0 && event.lineno === 0) {
                                        isCrossOriginError = true;
                                    }
                                }
                                var evtType = "react-" + (name ? name : "invokeguardedcallback");
                                window.addEventListener("error", onError);
                                fakeNode.addEventListener(evtType, callCallback, false);
                                var evt = document.createEvent("Event");
                                evt.initEvent(evtType, false, false);
                                fakeNode.dispatchEvent(evt);
                                if (didError) {
                                    if (!didSetError) {
                                        error = new Error("An error was thrown inside one of your components, but React " + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + "your browser. Try triggering the error in production mode, " + "or switching to a modern browser. If you suspect that this is " + "actually an issue with React, please file an issue.");
                                    } else if (isCrossOriginError) {
                                        error = new Error("A cross-origin error was thrown. React doesn't have access to " + "the actual error object in development. " + "See https://fb.me/react-crossorigin-error for more information.");
                                    }
                                    ReactErrorUtils._hasCaughtError = true;
                                    ReactErrorUtils._caughtError = error;
                                } else {
                                    ReactErrorUtils._hasCaughtError = false;
                                    ReactErrorUtils._caughtError = null;
                                }
                                window.removeEventListener("error", onError);
                            };
                            invokeGuardedCallback = invokeGuardedCallbackDev;
                        }
                    }
                    var rethrowCaughtError = function() {
                        if (ReactErrorUtils._hasRethrowError) {
                            var error = ReactErrorUtils._rethrowError;
                            ReactErrorUtils._rethrowError = null;
                            ReactErrorUtils._hasRethrowError = false;
                            throw error;
                        }
                    };
                    var eventPluginOrder = null;
                    var namesToPlugins = {};
                    function recomputePluginOrdering() {
                        if (!eventPluginOrder) {
                            return;
                        }
                        for (var pluginName in namesToPlugins) {
                            var pluginModule = namesToPlugins[pluginName];
                            var pluginIndex = eventPluginOrder.indexOf(pluginName);
                            !(pluginIndex > -1) ? invariant(false, "EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.", pluginName) : void 0;
                            if (plugins[pluginIndex]) {
                                continue;
                            }
                            !pluginModule.extractEvents ? invariant(false, "EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.", pluginName) : void 0;
                            plugins[pluginIndex] = pluginModule;
                            var publishedEvents = pluginModule.eventTypes;
                            for (var eventName in publishedEvents) {
                                !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName) : void 0;
                            }
                        }
                    }
                    function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
                        !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, "EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.", eventName) : void 0;
                        eventNameDispatchConfigs[eventName] = dispatchConfig;
                        var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
                        if (phasedRegistrationNames) {
                            for (var phaseName in phasedRegistrationNames) {
                                if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
                                    var phasedRegistrationName = phasedRegistrationNames[phaseName];
                                    publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
                                }
                            }
                            return true;
                        } else if (dispatchConfig.registrationName) {
                            publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
                            return true;
                        }
                        return false;
                    }
                    function publishRegistrationName(registrationName, pluginModule, eventName) {
                        !!registrationNameModules[registrationName] ? invariant(false, "EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.", registrationName) : void 0;
                        registrationNameModules[registrationName] = pluginModule;
                        registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
                        {
                            var lowerCasedName = registrationName.toLowerCase();
                            possibleRegistrationNames[lowerCasedName] = registrationName;
                            if (registrationName === "onDoubleClick") {
                                possibleRegistrationNames.ondblclick = registrationName;
                            }
                        }
                    }
                    var plugins = [];
                    var eventNameDispatchConfigs = {};
                    var registrationNameModules = {};
                    var registrationNameDependencies = {};
                    var possibleRegistrationNames = {};
                    function injectEventPluginOrder(injectedEventPluginOrder) {
                        !!eventPluginOrder ? invariant(false, "EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.") : void 0;
                        eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
                        recomputePluginOrdering();
                    }
                    function injectEventPluginsByName(injectedNamesToPlugins) {
                        var isOrderingDirty = false;
                        for (var pluginName in injectedNamesToPlugins) {
                            if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
                                continue;
                            }
                            var pluginModule = injectedNamesToPlugins[pluginName];
                            if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
                                !!namesToPlugins[pluginName] ? invariant(false, "EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.", pluginName) : void 0;
                                namesToPlugins[pluginName] = pluginModule;
                                isOrderingDirty = true;
                            }
                        }
                        if (isOrderingDirty) {
                            recomputePluginOrdering();
                        }
                    }
                    var EventPluginRegistry = Object.freeze({
                        plugins: plugins,
                        eventNameDispatchConfigs: eventNameDispatchConfigs,
                        registrationNameModules: registrationNameModules,
                        registrationNameDependencies: registrationNameDependencies,
                        possibleRegistrationNames: possibleRegistrationNames,
                        injectEventPluginOrder: injectEventPluginOrder,
                        injectEventPluginsByName: injectEventPluginsByName
                    });
                    var getFiberCurrentPropsFromNode = null;
                    var getInstanceFromNode = null;
                    var getNodeFromInstance = null;
                    var injection$2 = {
                        injectComponentTree: function(Injected) {
                            getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;
                            getInstanceFromNode = Injected.getInstanceFromNode;
                            getNodeFromInstance = Injected.getNodeFromInstance;
                            {
                                warning(getNodeFromInstance && getInstanceFromNode, "EventPluginUtils.injection.injectComponentTree(...): Injected " + "module is missing getNodeFromInstance or getInstanceFromNode.");
                            }
                        }
                    };
                    var validateEventDispatches;
                    {
                        validateEventDispatches = function(event) {
                            var dispatchListeners = event._dispatchListeners;
                            var dispatchInstances = event._dispatchInstances;
                            var listenersIsArr = Array.isArray(dispatchListeners);
                            var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
                            var instancesIsArr = Array.isArray(dispatchInstances);
                            var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
                            warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, "EventPluginUtils: Invalid `event`.");
                        };
                    }
                    function executeDispatch(event, simulated, listener, inst) {
                        var type = event.type || "unknown-event";
                        event.currentTarget = getNodeFromInstance(inst);
                        ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
                        event.currentTarget = null;
                    }
                    function executeDispatchesInOrder(event, simulated) {
                        var dispatchListeners = event._dispatchListeners;
                        var dispatchInstances = event._dispatchInstances;
                        {
                            validateEventDispatches(event);
                        }
                        if (Array.isArray(dispatchListeners)) {
                            for (var i = 0; i < dispatchListeners.length; i++) {
                                if (event.isPropagationStopped()) {
                                    break;
                                }
                                executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
                            }
                        } else if (dispatchListeners) {
                            executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
                        }
                        event._dispatchListeners = null;
                        event._dispatchInstances = null;
                    }
                    function accumulateInto(current, next) {
                        !(next != null) ? invariant(false, "accumulateInto(...): Accumulated items must not be null or undefined.") : void 0;
                        if (current == null) {
                            return next;
                        }
                        if (Array.isArray(current)) {
                            if (Array.isArray(next)) {
                                current.push.apply(current, next);
                                return current;
                            }
                            current.push(next);
                            return current;
                        }
                        if (Array.isArray(next)) {
                            return [ current ].concat(next);
                        }
                        return [ current, next ];
                    }
                    function forEachAccumulated(arr, cb, scope) {
                        if (Array.isArray(arr)) {
                            arr.forEach(cb, scope);
                        } else if (arr) {
                            cb.call(scope, arr);
                        }
                    }
                    var eventQueue = null;
                    var executeDispatchesAndRelease = function(event, simulated) {
                        if (event) {
                            executeDispatchesInOrder(event, simulated);
                            if (!event.isPersistent()) {
                                event.constructor.release(event);
                            }
                        }
                    };
                    var executeDispatchesAndReleaseSimulated = function(e) {
                        return executeDispatchesAndRelease(e, true);
                    };
                    var executeDispatchesAndReleaseTopLevel = function(e) {
                        return executeDispatchesAndRelease(e, false);
                    };
                    function isInteractive(tag) {
                        return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
                    }
                    function shouldPreventMouseEvent(name, type, props) {
                        switch (name) {
                          case "onClick":
                          case "onClickCapture":
                          case "onDoubleClick":
                          case "onDoubleClickCapture":
                          case "onMouseDown":
                          case "onMouseDownCapture":
                          case "onMouseMove":
                          case "onMouseMoveCapture":
                          case "onMouseUp":
                          case "onMouseUpCapture":
                            return !!(props.disabled && isInteractive(type));

                          default:
                            return false;
                        }
                    }
                    var injection$1 = {
                        injectEventPluginOrder: injectEventPluginOrder,
                        injectEventPluginsByName: injectEventPluginsByName
                    };
                    function getListener(inst, registrationName) {
                        var listener;
                        var stateNode = inst.stateNode;
                        if (!stateNode) {
                            return null;
                        }
                        var props = getFiberCurrentPropsFromNode(stateNode);
                        if (!props) {
                            return null;
                        }
                        listener = props[registrationName];
                        if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
                            return null;
                        }
                        !(!listener || typeof listener === "function") ? invariant(false, "Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener) : void 0;
                        return listener;
                    }
                    function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                        var events;
                        for (var i = 0; i < plugins.length; i++) {
                            var possiblePlugin = plugins[i];
                            if (possiblePlugin) {
                                var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
                                if (extractedEvents) {
                                    events = accumulateInto(events, extractedEvents);
                                }
                            }
                        }
                        return events;
                    }
                    function enqueueEvents(events) {
                        if (events) {
                            eventQueue = accumulateInto(eventQueue, events);
                        }
                    }
                    function processEventQueue(simulated) {
                        var processingEventQueue = eventQueue;
                        eventQueue = null;
                        if (!processingEventQueue) {
                            return;
                        }
                        if (simulated) {
                            forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
                        } else {
                            forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
                        }
                        !!eventQueue ? invariant(false, "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.") : void 0;
                        ReactErrorUtils.rethrowCaughtError();
                    }
                    var EventPluginHub = Object.freeze({
                        injection: injection$1,
                        getListener: getListener,
                        extractEvents: extractEvents,
                        enqueueEvents: enqueueEvents,
                        processEventQueue: processEventQueue
                    });
                    var IndeterminateComponent = 0;
                    var FunctionalComponent = 1;
                    var ClassComponent = 2;
                    var HostRoot = 3;
                    var HostPortal = 4;
                    var HostComponent = 5;
                    var HostText = 6;
                    var CallComponent = 7;
                    var CallHandlerPhase = 8;
                    var ReturnComponent = 9;
                    var Fragment = 10;
                    var randomKey = Math.random().toString(36).slice(2);
                    var internalInstanceKey = "__reactInternalInstance$" + randomKey;
                    var internalEventHandlersKey = "__reactEventHandlers$" + randomKey;
                    function precacheFiberNode$1(hostInst, node) {
                        node[internalInstanceKey] = hostInst;
                    }
                    function getClosestInstanceFromNode(node) {
                        if (node[internalInstanceKey]) {
                            return node[internalInstanceKey];
                        }
                        var parents = [];
                        while (!node[internalInstanceKey]) {
                            parents.push(node);
                            if (node.parentNode) {
                                node = node.parentNode;
                            } else {
                                return null;
                            }
                        }
                        var closest = void 0;
                        var inst = node[internalInstanceKey];
                        if (inst.tag === HostComponent || inst.tag === HostText) {
                            return inst;
                        }
                        for (;node && (inst = node[internalInstanceKey]); node = parents.pop()) {
                            closest = inst;
                        }
                        return closest;
                    }
                    function getInstanceFromNode$1(node) {
                        var inst = node[internalInstanceKey];
                        if (inst) {
                            if (inst.tag === HostComponent || inst.tag === HostText) {
                                return inst;
                            } else {
                                return null;
                            }
                        }
                        return null;
                    }
                    function getNodeFromInstance$1(inst) {
                        if (inst.tag === HostComponent || inst.tag === HostText) {
                            return inst.stateNode;
                        }
                        invariant(false, "getNodeFromInstance: Invalid argument.");
                    }
                    function getFiberCurrentPropsFromNode$1(node) {
                        return node[internalEventHandlersKey] || null;
                    }
                    function updateFiberProps$1(node, props) {
                        node[internalEventHandlersKey] = props;
                    }
                    var ReactDOMComponentTree = Object.freeze({
                        precacheFiberNode: precacheFiberNode$1,
                        getClosestInstanceFromNode: getClosestInstanceFromNode,
                        getInstanceFromNode: getInstanceFromNode$1,
                        getNodeFromInstance: getNodeFromInstance$1,
                        getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
                        updateFiberProps: updateFiberProps$1
                    });
                    function getParent(inst) {
                        do {
                            inst = inst["return"];
                        } while (inst && inst.tag !== HostComponent);
                        if (inst) {
                            return inst;
                        }
                        return null;
                    }
                    function getLowestCommonAncestor(instA, instB) {
                        var depthA = 0;
                        for (var tempA = instA; tempA; tempA = getParent(tempA)) {
                            depthA++;
                        }
                        var depthB = 0;
                        for (var tempB = instB; tempB; tempB = getParent(tempB)) {
                            depthB++;
                        }
                        while (depthA - depthB > 0) {
                            instA = getParent(instA);
                            depthA--;
                        }
                        while (depthB - depthA > 0) {
                            instB = getParent(instB);
                            depthB--;
                        }
                        var depth = depthA;
                        while (depth--) {
                            if (instA === instB || instA === instB.alternate) {
                                return instA;
                            }
                            instA = getParent(instA);
                            instB = getParent(instB);
                        }
                        return null;
                    }
                    function getParentInstance(inst) {
                        return getParent(inst);
                    }
                    function traverseTwoPhase(inst, fn, arg) {
                        var path = [];
                        while (inst) {
                            path.push(inst);
                            inst = getParent(inst);
                        }
                        var i;
                        for (i = path.length; i-- > 0; ) {
                            fn(path[i], "captured", arg);
                        }
                        for (i = 0; i < path.length; i++) {
                            fn(path[i], "bubbled", arg);
                        }
                    }
                    function traverseEnterLeave(from, to, fn, argFrom, argTo) {
                        var common = from && to ? getLowestCommonAncestor(from, to) : null;
                        var pathFrom = [];
                        while (true) {
                            if (!from) {
                                break;
                            }
                            if (from === common) {
                                break;
                            }
                            var alternate = from.alternate;
                            if (alternate !== null && alternate === common) {
                                break;
                            }
                            pathFrom.push(from);
                            from = getParent(from);
                        }
                        var pathTo = [];
                        while (true) {
                            if (!to) {
                                break;
                            }
                            if (to === common) {
                                break;
                            }
                            var _alternate = to.alternate;
                            if (_alternate !== null && _alternate === common) {
                                break;
                            }
                            pathTo.push(to);
                            to = getParent(to);
                        }
                        for (var i = 0; i < pathFrom.length; i++) {
                            fn(pathFrom[i], "bubbled", argFrom);
                        }
                        for (var _i = pathTo.length; _i-- > 0; ) {
                            fn(pathTo[_i], "captured", argTo);
                        }
                    }
                    function listenerAtPhase(inst, event, propagationPhase) {
                        var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
                        return getListener(inst, registrationName);
                    }
                    function accumulateDirectionalDispatches(inst, phase, event) {
                        {
                            warning(inst, "Dispatching inst must not be null");
                        }
                        var listener = listenerAtPhase(inst, event, phase);
                        if (listener) {
                            event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
                            event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
                        }
                    }
                    function accumulateTwoPhaseDispatchesSingle(event) {
                        if (event && event.dispatchConfig.phasedRegistrationNames) {
                            traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
                        }
                    }
                    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
                        if (event && event.dispatchConfig.phasedRegistrationNames) {
                            var targetInst = event._targetInst;
                            var parentInst = targetInst ? getParentInstance(targetInst) : null;
                            traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
                        }
                    }
                    function accumulateDispatches(inst, ignoredDirection, event) {
                        if (inst && event && event.dispatchConfig.registrationName) {
                            var registrationName = event.dispatchConfig.registrationName;
                            var listener = getListener(inst, registrationName);
                            if (listener) {
                                event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
                                event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
                            }
                        }
                    }
                    function accumulateDirectDispatchesSingle(event) {
                        if (event && event.dispatchConfig.registrationName) {
                            accumulateDispatches(event._targetInst, null, event);
                        }
                    }
                    function accumulateTwoPhaseDispatches(events) {
                        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
                    }
                    function accumulateTwoPhaseDispatchesSkipTarget(events) {
                        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
                    }
                    function accumulateEnterLeaveDispatches(leave, enter, from, to) {
                        traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
                    }
                    function accumulateDirectDispatches(events) {
                        forEachAccumulated(events, accumulateDirectDispatchesSingle);
                    }
                    var EventPropagators = Object.freeze({
                        accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
                        accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
                        accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,
                        accumulateDirectDispatches: accumulateDirectDispatches
                    });
                    var contentKey = null;
                    function getTextContentAccessor() {
                        if (!contentKey && ExecutionEnvironment.canUseDOM) {
                            contentKey = "textContent" in document.documentElement ? "textContent" : "innerText";
                        }
                        return contentKey;
                    }
                    var compositionState = {
                        _root: null,
                        _startText: null,
                        _fallbackText: null
                    };
                    function initialize(nativeEventTarget) {
                        compositionState._root = nativeEventTarget;
                        compositionState._startText = getText();
                        return true;
                    }
                    function reset() {
                        compositionState._root = null;
                        compositionState._startText = null;
                        compositionState._fallbackText = null;
                    }
                    function getData() {
                        if (compositionState._fallbackText) {
                            return compositionState._fallbackText;
                        }
                        var start;
                        var startValue = compositionState._startText;
                        var startLength = startValue.length;
                        var end;
                        var endValue = getText();
                        var endLength = endValue.length;
                        for (start = 0; start < startLength; start++) {
                            if (startValue[start] !== endValue[start]) {
                                break;
                            }
                        }
                        var minEnd = startLength - start;
                        for (end = 1; end <= minEnd; end++) {
                            if (startValue[startLength - end] !== endValue[endLength - end]) {
                                break;
                            }
                        }
                        var sliceTail = end > 1 ? 1 - end : undefined;
                        compositionState._fallbackText = endValue.slice(start, sliceTail);
                        return compositionState._fallbackText;
                    }
                    function getText() {
                        if ("value" in compositionState._root) {
                            return compositionState._root.value;
                        }
                        return compositionState._root[getTextContentAccessor()];
                    }
                    var didWarnForAddedNewProperty = false;
                    var isProxySupported = typeof Proxy === "function";
                    var EVENT_POOL_SIZE = 10;
                    var shouldBeReleasedProperties = [ "dispatchConfig", "_targetInst", "nativeEvent", "isDefaultPrevented", "isPropagationStopped", "_dispatchListeners", "_dispatchInstances" ];
                    var EventInterface = {
                        type: null,
                        target: null,
                        currentTarget: emptyFunction.thatReturnsNull,
                        eventPhase: null,
                        bubbles: null,
                        cancelable: null,
                        timeStamp: function(event) {
                            return event.timeStamp || Date.now();
                        },
                        defaultPrevented: null,
                        isTrusted: null
                    };
                    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
                        {
                            delete this.nativeEvent;
                            delete this.preventDefault;
                            delete this.stopPropagation;
                        }
                        this.dispatchConfig = dispatchConfig;
                        this._targetInst = targetInst;
                        this.nativeEvent = nativeEvent;
                        var Interface = this.constructor.Interface;
                        for (var propName in Interface) {
                            if (!Interface.hasOwnProperty(propName)) {
                                continue;
                            }
                            {
                                delete this[propName];
                            }
                            var normalize = Interface[propName];
                            if (normalize) {
                                this[propName] = normalize(nativeEvent);
                            } else {
                                if (propName === "target") {
                                    this.target = nativeEventTarget;
                                } else {
                                    this[propName] = nativeEvent[propName];
                                }
                            }
                        }
                        var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
                        if (defaultPrevented) {
                            this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
                        } else {
                            this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
                        }
                        this.isPropagationStopped = emptyFunction.thatReturnsFalse;
                        return this;
                    }
                    _assign(SyntheticEvent.prototype, {
                        preventDefault: function() {
                            this.defaultPrevented = true;
                            var event = this.nativeEvent;
                            if (!event) {
                                return;
                            }
                            if (event.preventDefault) {
                                event.preventDefault();
                            } else if (typeof event.returnValue !== "unknown") {
                                event.returnValue = false;
                            }
                            this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
                        },
                        stopPropagation: function() {
                            var event = this.nativeEvent;
                            if (!event) {
                                return;
                            }
                            if (event.stopPropagation) {
                                event.stopPropagation();
                            } else if (typeof event.cancelBubble !== "unknown") {
                                event.cancelBubble = true;
                            }
                            this.isPropagationStopped = emptyFunction.thatReturnsTrue;
                        },
                        persist: function() {
                            this.isPersistent = emptyFunction.thatReturnsTrue;
                        },
                        isPersistent: emptyFunction.thatReturnsFalse,
                        destructor: function() {
                            var Interface = this.constructor.Interface;
                            for (var propName in Interface) {
                                {
                                    Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
                                }
                            }
                            for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
                                this[shouldBeReleasedProperties[i]] = null;
                            }
                            {
                                Object.defineProperty(this, "nativeEvent", getPooledWarningPropertyDefinition("nativeEvent", null));
                                Object.defineProperty(this, "preventDefault", getPooledWarningPropertyDefinition("preventDefault", emptyFunction));
                                Object.defineProperty(this, "stopPropagation", getPooledWarningPropertyDefinition("stopPropagation", emptyFunction));
                            }
                        }
                    });
                    SyntheticEvent.Interface = EventInterface;
                    SyntheticEvent.augmentClass = function(Class, Interface) {
                        var Super = this;
                        var E = function() {};
                        E.prototype = Super.prototype;
                        var prototype = new E();
                        _assign(prototype, Class.prototype);
                        Class.prototype = prototype;
                        Class.prototype.constructor = Class;
                        Class.Interface = _assign({}, Super.Interface, Interface);
                        Class.augmentClass = Super.augmentClass;
                        addEventPoolingTo(Class);
                    };
                    {
                        if (isProxySupported) {
                            SyntheticEvent = new Proxy(SyntheticEvent, {
                                construct: function(target, args) {
                                    return this.apply(target, Object.create(target.prototype), args);
                                },
                                apply: function(constructor, that, args) {
                                    return new Proxy(constructor.apply(that, args), {
                                        set: function(target, prop, value) {
                                            if (prop !== "isPersistent" && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
                                                warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + "The property is never released. See " + "https://fb.me/react-event-pooling for more information.");
                                                didWarnForAddedNewProperty = true;
                                            }
                                            target[prop] = value;
                                            return true;
                                        }
                                    });
                                }
                            });
                        }
                    }
                    addEventPoolingTo(SyntheticEvent);
                    function getPooledWarningPropertyDefinition(propName, getVal) {
                        var isFunction = typeof getVal === "function";
                        return {
                            configurable: true,
                            set: set,
                            get: get
                        };
                        function set(val) {
                            var action = isFunction ? "setting the method" : "setting the property";
                            warn(action, "This is effectively a no-op");
                            return val;
                        }
                        function get() {
                            var action = isFunction ? "accessing the method" : "accessing the property";
                            var result = isFunction ? "This is a no-op function" : "This is set to null";
                            warn(action, result);
                            return getVal;
                        }
                        function warn(action, result) {
                            var warningCondition = false;
                            warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + "If you must keep the original synthetic event around, use event.persist(). " + "See https://fb.me/react-event-pooling for more information.", action, propName, result);
                        }
                    }
                    function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
                        var EventConstructor = this;
                        if (EventConstructor.eventPool.length) {
                            var instance = EventConstructor.eventPool.pop();
                            EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
                            return instance;
                        }
                        return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
                    }
                    function releasePooledEvent(event) {
                        var EventConstructor = this;
                        !(event instanceof EventConstructor) ? invariant(false, "Trying to release an event instance  into a pool of a different type.") : void 0;
                        event.destructor();
                        if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
                            EventConstructor.eventPool.push(event);
                        }
                    }
                    function addEventPoolingTo(EventConstructor) {
                        EventConstructor.eventPool = [];
                        EventConstructor.getPooled = getPooledEvent;
                        EventConstructor.release = releasePooledEvent;
                    }
                    var SyntheticEvent$1 = SyntheticEvent;
                    var CompositionEventInterface = {
                        data: null
                    };
                    function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
                    var InputEventInterface = {
                        data: null
                    };
                    function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);
                    var END_KEYCODES = [ 9, 13, 27, 32 ];
                    var START_KEYCODE = 229;
                    var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && "CompositionEvent" in window;
                    var documentMode = null;
                    if (ExecutionEnvironment.canUseDOM && "documentMode" in document) {
                        documentMode = document.documentMode;
                    }
                    var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && "TextEvent" in window && !documentMode && !isPresto();
                    var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
                    function isPresto() {
                        var opera = window.opera;
                        return typeof opera === "object" && typeof opera.version === "function" && parseInt(opera.version(), 10) <= 12;
                    }
                    var SPACEBAR_CODE = 32;
                    var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
                    var eventTypes = {
                        beforeInput: {
                            phasedRegistrationNames: {
                                bubbled: "onBeforeInput",
                                captured: "onBeforeInputCapture"
                            },
                            dependencies: [ "topCompositionEnd", "topKeyPress", "topTextInput", "topPaste" ]
                        },
                        compositionEnd: {
                            phasedRegistrationNames: {
                                bubbled: "onCompositionEnd",
                                captured: "onCompositionEndCapture"
                            },
                            dependencies: [ "topBlur", "topCompositionEnd", "topKeyDown", "topKeyPress", "topKeyUp", "topMouseDown" ]
                        },
                        compositionStart: {
                            phasedRegistrationNames: {
                                bubbled: "onCompositionStart",
                                captured: "onCompositionStartCapture"
                            },
                            dependencies: [ "topBlur", "topCompositionStart", "topKeyDown", "topKeyPress", "topKeyUp", "topMouseDown" ]
                        },
                        compositionUpdate: {
                            phasedRegistrationNames: {
                                bubbled: "onCompositionUpdate",
                                captured: "onCompositionUpdateCapture"
                            },
                            dependencies: [ "topBlur", "topCompositionUpdate", "topKeyDown", "topKeyPress", "topKeyUp", "topMouseDown" ]
                        }
                    };
                    var hasSpaceKeypress = false;
                    function isKeypressCommand(nativeEvent) {
                        return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
                    }
                    function getCompositionEventType(topLevelType) {
                        switch (topLevelType) {
                          case "topCompositionStart":
                            return eventTypes.compositionStart;

                          case "topCompositionEnd":
                            return eventTypes.compositionEnd;

                          case "topCompositionUpdate":
                            return eventTypes.compositionUpdate;
                        }
                    }
                    function isFallbackCompositionStart(topLevelType, nativeEvent) {
                        return topLevelType === "topKeyDown" && nativeEvent.keyCode === START_KEYCODE;
                    }
                    function isFallbackCompositionEnd(topLevelType, nativeEvent) {
                        switch (topLevelType) {
                          case "topKeyUp":
                            return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;

                          case "topKeyDown":
                            return nativeEvent.keyCode !== START_KEYCODE;

                          case "topKeyPress":
                          case "topMouseDown":
                          case "topBlur":
                            return true;

                          default:
                            return false;
                        }
                    }
                    function getDataFromCustomEvent(nativeEvent) {
                        var detail = nativeEvent.detail;
                        if (typeof detail === "object" && "data" in detail) {
                            return detail.data;
                        }
                        return null;
                    }
                    var isComposing = false;
                    function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                        var eventType;
                        var fallbackData;
                        if (canUseCompositionEvent) {
                            eventType = getCompositionEventType(topLevelType);
                        } else if (!isComposing) {
                            if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
                                eventType = eventTypes.compositionStart;
                            }
                        } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
                            eventType = eventTypes.compositionEnd;
                        }
                        if (!eventType) {
                            return null;
                        }
                        if (useFallbackCompositionData) {
                            if (!isComposing && eventType === eventTypes.compositionStart) {
                                isComposing = initialize(nativeEventTarget);
                            } else if (eventType === eventTypes.compositionEnd) {
                                if (isComposing) {
                                    fallbackData = getData();
                                }
                            }
                        }
                        var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
                        if (fallbackData) {
                            event.data = fallbackData;
                        } else {
                            var customData = getDataFromCustomEvent(nativeEvent);
                            if (customData !== null) {
                                event.data = customData;
                            }
                        }
                        accumulateTwoPhaseDispatches(event);
                        return event;
                    }
                    function getNativeBeforeInputChars(topLevelType, nativeEvent) {
                        switch (topLevelType) {
                          case "topCompositionEnd":
                            return getDataFromCustomEvent(nativeEvent);

                          case "topKeyPress":
                            var which = nativeEvent.which;
                            if (which !== SPACEBAR_CODE) {
                                return null;
                            }
                            hasSpaceKeypress = true;
                            return SPACEBAR_CHAR;

                          case "topTextInput":
                            var chars = nativeEvent.data;
                            if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                                return null;
                            }
                            return chars;

                          default:
                            return null;
                        }
                    }
                    function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
                        if (isComposing) {
                            if (topLevelType === "topCompositionEnd" || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
                                var chars = getData();
                                reset();
                                isComposing = false;
                                return chars;
                            }
                            return null;
                        }
                        switch (topLevelType) {
                          case "topPaste":
                            return null;

                          case "topKeyPress":
                            if (!isKeypressCommand(nativeEvent)) {
                                if (nativeEvent.char && nativeEvent.char.length > 1) {
                                    return nativeEvent.char;
                                } else if (nativeEvent.which) {
                                    return String.fromCharCode(nativeEvent.which);
                                }
                            }
                            return null;

                          case "topCompositionEnd":
                            return useFallbackCompositionData ? null : nativeEvent.data;

                          default:
                            return null;
                        }
                    }
                    function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                        var chars;
                        if (canUseTextInputEvent) {
                            chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
                        } else {
                            chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
                        }
                        if (!chars) {
                            return null;
                        }
                        var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
                        event.data = chars;
                        accumulateTwoPhaseDispatches(event);
                        return event;
                    }
                    var BeforeInputEventPlugin = {
                        eventTypes: eventTypes,
                        extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                            return [ extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) ];
                        }
                    };
                    var fiberHostComponent = null;
                    var ReactControlledComponentInjection = {
                        injectFiberControlledHostComponent: function(hostComponentImpl) {
                            fiberHostComponent = hostComponentImpl;
                        }
                    };
                    var restoreTarget = null;
                    var restoreQueue = null;
                    function restoreStateOfTarget(target) {
                        var internalInstance = getInstanceFromNode(target);
                        if (!internalInstance) {
                            return;
                        }
                        !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === "function") ? invariant(false, "Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                        var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
                        fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
                    }
                    var injection$3 = ReactControlledComponentInjection;
                    function enqueueStateRestore(target) {
                        if (restoreTarget) {
                            if (restoreQueue) {
                                restoreQueue.push(target);
                            } else {
                                restoreQueue = [ target ];
                            }
                        } else {
                            restoreTarget = target;
                        }
                    }
                    function restoreStateIfNeeded() {
                        if (!restoreTarget) {
                            return;
                        }
                        var target = restoreTarget;
                        var queuedTargets = restoreQueue;
                        restoreTarget = null;
                        restoreQueue = null;
                        restoreStateOfTarget(target);
                        if (queuedTargets) {
                            for (var i = 0; i < queuedTargets.length; i++) {
                                restoreStateOfTarget(queuedTargets[i]);
                            }
                        }
                    }
                    var ReactControlledComponent = Object.freeze({
                        injection: injection$3,
                        enqueueStateRestore: enqueueStateRestore,
                        restoreStateIfNeeded: restoreStateIfNeeded
                    });
                    var fiberBatchedUpdates = function(fn, bookkeeping) {
                        return fn(bookkeeping);
                    };
                    var isNestingBatched = false;
                    function batchedUpdates(fn, bookkeeping) {
                        if (isNestingBatched) {
                            return fiberBatchedUpdates(fn, bookkeeping);
                        }
                        isNestingBatched = true;
                        try {
                            return fiberBatchedUpdates(fn, bookkeeping);
                        } finally {
                            isNestingBatched = false;
                            restoreStateIfNeeded();
                        }
                    }
                    var ReactGenericBatchingInjection = {
                        injectFiberBatchedUpdates: function(_batchedUpdates) {
                            fiberBatchedUpdates = _batchedUpdates;
                        }
                    };
                    var injection$4 = ReactGenericBatchingInjection;
                    var supportedInputTypes = {
                        color: true,
                        date: true,
                        datetime: true,
                        "datetime-local": true,
                        email: true,
                        month: true,
                        number: true,
                        password: true,
                        range: true,
                        search: true,
                        tel: true,
                        text: true,
                        time: true,
                        url: true,
                        week: true
                    };
                    function isTextInputElement(elem) {
                        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
                        if (nodeName === "input") {
                            return !!supportedInputTypes[elem.type];
                        }
                        if (nodeName === "textarea") {
                            return true;
                        }
                        return false;
                    }
                    var ELEMENT_NODE = 1;
                    var TEXT_NODE = 3;
                    var COMMENT_NODE = 8;
                    var DOCUMENT_NODE = 9;
                    var DOCUMENT_FRAGMENT_NODE = 11;
                    function getEventTarget(nativeEvent) {
                        var target = nativeEvent.target || nativeEvent.srcElement || window;
                        if (target.correspondingUseElement) {
                            target = target.correspondingUseElement;
                        }
                        return target.nodeType === TEXT_NODE ? target.parentNode : target;
                    }
                    var useHasFeature;
                    if (ExecutionEnvironment.canUseDOM) {
                        useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true;
                    }
                    function isEventSupported(eventNameSuffix, capture) {
                        if (!ExecutionEnvironment.canUseDOM || capture && !("addEventListener" in document)) {
                            return false;
                        }
                        var eventName = "on" + eventNameSuffix;
                        var isSupported = eventName in document;
                        if (!isSupported) {
                            var element = document.createElement("div");
                            element.setAttribute(eventName, "return;");
                            isSupported = typeof element[eventName] === "function";
                        }
                        if (!isSupported && useHasFeature && eventNameSuffix === "wheel") {
                            isSupported = document.implementation.hasFeature("Events.wheel", "3.0");
                        }
                        return isSupported;
                    }
                    function isCheckable(elem) {
                        var type = elem.type;
                        var nodeName = elem.nodeName;
                        return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
                    }
                    function getTracker(node) {
                        return node._valueTracker;
                    }
                    function detachTracker(node) {
                        node._valueTracker = null;
                    }
                    function getValueFromNode(node) {
                        var value = "";
                        if (!node) {
                            return value;
                        }
                        if (isCheckable(node)) {
                            value = node.checked ? "true" : "false";
                        } else {
                            value = node.value;
                        }
                        return value;
                    }
                    function trackValueOnNode(node) {
                        var valueField = isCheckable(node) ? "checked" : "value";
                        var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
                        var currentValue = "" + node[valueField];
                        if (node.hasOwnProperty(valueField) || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
                            return;
                        }
                        Object.defineProperty(node, valueField, {
                            enumerable: descriptor.enumerable,
                            configurable: true,
                            get: function() {
                                return descriptor.get.call(this);
                            },
                            set: function(value) {
                                currentValue = "" + value;
                                descriptor.set.call(this, value);
                            }
                        });
                        var tracker = {
                            getValue: function() {
                                return currentValue;
                            },
                            setValue: function(value) {
                                currentValue = "" + value;
                            },
                            stopTracking: function() {
                                detachTracker(node);
                                delete node[valueField];
                            }
                        };
                        return tracker;
                    }
                    function track(node) {
                        if (getTracker(node)) {
                            return;
                        }
                        node._valueTracker = trackValueOnNode(node);
                    }
                    function updateValueIfChanged(node) {
                        if (!node) {
                            return false;
                        }
                        var tracker = getTracker(node);
                        if (!tracker) {
                            return true;
                        }
                        var lastValue = tracker.getValue();
                        var nextValue = getValueFromNode(node);
                        if (nextValue !== lastValue) {
                            tracker.setValue(nextValue);
                            return true;
                        }
                        return false;
                    }
                    var eventTypes$1 = {
                        change: {
                            phasedRegistrationNames: {
                                bubbled: "onChange",
                                captured: "onChangeCapture"
                            },
                            dependencies: [ "topBlur", "topChange", "topClick", "topFocus", "topInput", "topKeyDown", "topKeyUp", "topSelectionChange" ]
                        }
                    };
                    function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
                        var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);
                        event.type = "change";
                        enqueueStateRestore(target);
                        accumulateTwoPhaseDispatches(event);
                        return event;
                    }
                    var activeElement = null;
                    var activeElementInst = null;
                    function shouldUseChangeEvent(elem) {
                        var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
                        return nodeName === "select" || nodeName === "input" && elem.type === "file";
                    }
                    function manualDispatchChangeEvent(nativeEvent) {
                        var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));
                        batchedUpdates(runEventInBatch, event);
                    }
                    function runEventInBatch(event) {
                        enqueueEvents(event);
                        processEventQueue(false);
                    }
                    function getInstIfValueChanged(targetInst) {
                        var targetNode = getNodeFromInstance$1(targetInst);
                        if (updateValueIfChanged(targetNode)) {
                            return targetInst;
                        }
                    }
                    function getTargetInstForChangeEvent(topLevelType, targetInst) {
                        if (topLevelType === "topChange") {
                            return targetInst;
                        }
                    }
                    var isInputEventSupported = false;
                    if (ExecutionEnvironment.canUseDOM) {
                        isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
                    }
                    function startWatchingForValueChange(target, targetInst) {
                        activeElement = target;
                        activeElementInst = targetInst;
                        activeElement.attachEvent("onpropertychange", handlePropertyChange);
                    }
                    function stopWatchingForValueChange() {
                        if (!activeElement) {
                            return;
                        }
                        activeElement.detachEvent("onpropertychange", handlePropertyChange);
                        activeElement = null;
                        activeElementInst = null;
                    }
                    function handlePropertyChange(nativeEvent) {
                        if (nativeEvent.propertyName !== "value") {
                            return;
                        }
                        if (getInstIfValueChanged(activeElementInst)) {
                            manualDispatchChangeEvent(nativeEvent);
                        }
                    }
                    function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
                        if (topLevelType === "topFocus") {
                            stopWatchingForValueChange();
                            startWatchingForValueChange(target, targetInst);
                        } else if (topLevelType === "topBlur") {
                            stopWatchingForValueChange();
                        }
                    }
                    function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
                        if (topLevelType === "topSelectionChange" || topLevelType === "topKeyUp" || topLevelType === "topKeyDown") {
                            return getInstIfValueChanged(activeElementInst);
                        }
                    }
                    function shouldUseClickEvent(elem) {
                        var nodeName = elem.nodeName;
                        return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
                    }
                    function getTargetInstForClickEvent(topLevelType, targetInst) {
                        if (topLevelType === "topClick") {
                            return getInstIfValueChanged(targetInst);
                        }
                    }
                    function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
                        if (topLevelType === "topInput" || topLevelType === "topChange") {
                            return getInstIfValueChanged(targetInst);
                        }
                    }
                    function handleControlledInputBlur(inst, node) {
                        if (inst == null) {
                            return;
                        }
                        var state = inst._wrapperState || node._wrapperState;
                        if (!state || !state.controlled || node.type !== "number") {
                            return;
                        }
                        var value = "" + node.value;
                        if (node.getAttribute("value") !== value) {
                            node.setAttribute("value", value);
                        }
                    }
                    var ChangeEventPlugin = {
                        eventTypes: eventTypes$1,
                        _isInputEventSupported: isInputEventSupported,
                        extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                            var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;
                            var getTargetInstFunc, handleEventFunc;
                            if (shouldUseChangeEvent(targetNode)) {
                                getTargetInstFunc = getTargetInstForChangeEvent;
                            } else if (isTextInputElement(targetNode)) {
                                if (isInputEventSupported) {
                                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                                } else {
                                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                                    handleEventFunc = handleEventsForInputEventPolyfill;
                                }
                            } else if (shouldUseClickEvent(targetNode)) {
                                getTargetInstFunc = getTargetInstForClickEvent;
                            }
                            if (getTargetInstFunc) {
                                var inst = getTargetInstFunc(topLevelType, targetInst);
                                if (inst) {
                                    var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
                                    return event;
                                }
                            }
                            if (handleEventFunc) {
                                handleEventFunc(topLevelType, targetNode, targetInst);
                            }
                            if (topLevelType === "topBlur") {
                                handleControlledInputBlur(targetInst, targetNode);
                            }
                        }
                    };
                    var DOMEventPluginOrder = [ "ResponderEventPlugin", "SimpleEventPlugin", "TapEventPlugin", "EnterLeaveEventPlugin", "ChangeEventPlugin", "SelectEventPlugin", "BeforeInputEventPlugin" ];
                    var UIEventInterface = {
                        view: null,
                        detail: null
                    };
                    function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);
                    var modifierKeyToProp = {
                        Alt: "altKey",
                        Control: "ctrlKey",
                        Meta: "metaKey",
                        Shift: "shiftKey"
                    };
                    function modifierStateGetter(keyArg) {
                        var syntheticEvent = this;
                        var nativeEvent = syntheticEvent.nativeEvent;
                        if (nativeEvent.getModifierState) {
                            return nativeEvent.getModifierState(keyArg);
                        }
                        var keyProp = modifierKeyToProp[keyArg];
                        return keyProp ? !!nativeEvent[keyProp] : false;
                    }
                    function getEventModifierState(nativeEvent) {
                        return modifierStateGetter;
                    }
                    var MouseEventInterface = {
                        screenX: null,
                        screenY: null,
                        clientX: null,
                        clientY: null,
                        pageX: null,
                        pageY: null,
                        ctrlKey: null,
                        shiftKey: null,
                        altKey: null,
                        metaKey: null,
                        getModifierState: getEventModifierState,
                        button: null,
                        buttons: null,
                        relatedTarget: function(event) {
                            return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
                        }
                    };
                    function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
                    var eventTypes$2 = {
                        mouseEnter: {
                            registrationName: "onMouseEnter",
                            dependencies: [ "topMouseOut", "topMouseOver" ]
                        },
                        mouseLeave: {
                            registrationName: "onMouseLeave",
                            dependencies: [ "topMouseOut", "topMouseOver" ]
                        }
                    };
                    var EnterLeaveEventPlugin = {
                        eventTypes: eventTypes$2,
                        extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                            if (topLevelType === "topMouseOver" && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
                                return null;
                            }
                            if (topLevelType !== "topMouseOut" && topLevelType !== "topMouseOver") {
                                return null;
                            }
                            var win;
                            if (nativeEventTarget.window === nativeEventTarget) {
                                win = nativeEventTarget;
                            } else {
                                var doc = nativeEventTarget.ownerDocument;
                                if (doc) {
                                    win = doc.defaultView || doc.parentWindow;
                                } else {
                                    win = window;
                                }
                            }
                            var from;
                            var to;
                            if (topLevelType === "topMouseOut") {
                                from = targetInst;
                                var related = nativeEvent.relatedTarget || nativeEvent.toElement;
                                to = related ? getClosestInstanceFromNode(related) : null;
                            } else {
                                from = null;
                                to = targetInst;
                            }
                            if (from === to) {
                                return null;
                            }
                            var fromNode = from == null ? win : getNodeFromInstance$1(from);
                            var toNode = to == null ? win : getNodeFromInstance$1(to);
                            var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);
                            leave.type = "mouseleave";
                            leave.target = fromNode;
                            leave.relatedTarget = toNode;
                            var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);
                            enter.type = "mouseenter";
                            enter.target = toNode;
                            enter.relatedTarget = fromNode;
                            accumulateEnterLeaveDispatches(leave, enter, from, to);
                            return [ leave, enter ];
                        }
                    };
                    function get(key) {
                        return key._reactInternalFiber;
                    }
                    function has(key) {
                        return key._reactInternalFiber !== undefined;
                    }
                    function set(key, value) {
                        key._reactInternalFiber = value;
                    }
                    var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
                    var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
                    var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;
                    function getComponentName(fiber) {
                        var type = fiber.type;
                        if (typeof type === "string") {
                            return type;
                        }
                        if (typeof type === "function") {
                            return type.displayName || type.name;
                        }
                        return null;
                    }
                    var NoEffect = 0;
                    var PerformedWork = 1;
                    var Placement = 2;
                    var Update = 4;
                    var PlacementAndUpdate = 6;
                    var Deletion = 8;
                    var ContentReset = 16;
                    var Callback = 32;
                    var Err = 64;
                    var Ref = 128;
                    var MOUNTING = 1;
                    var MOUNTED = 2;
                    var UNMOUNTED = 3;
                    function isFiberMountedImpl(fiber) {
                        var node = fiber;
                        if (!fiber.alternate) {
                            if ((node.effectTag & Placement) !== NoEffect) {
                                return MOUNTING;
                            }
                            while (node["return"]) {
                                node = node["return"];
                                if ((node.effectTag & Placement) !== NoEffect) {
                                    return MOUNTING;
                                }
                            }
                        } else {
                            while (node["return"]) {
                                node = node["return"];
                            }
                        }
                        if (node.tag === HostRoot) {
                            return MOUNTED;
                        }
                        return UNMOUNTED;
                    }
                    function isFiberMounted(fiber) {
                        return isFiberMountedImpl(fiber) === MOUNTED;
                    }
                    function isMounted(component) {
                        {
                            var owner = ReactCurrentOwner.current;
                            if (owner !== null && owner.tag === ClassComponent) {
                                var ownerFiber = owner;
                                var instance = ownerFiber.stateNode;
                                warning(instance._warnedAboutRefsInRender, "%s is accessing isMounted inside its render() function. " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(ownerFiber) || "A component");
                                instance._warnedAboutRefsInRender = true;
                            }
                        }
                        var fiber = get(component);
                        if (!fiber) {
                            return false;
                        }
                        return isFiberMountedImpl(fiber) === MOUNTED;
                    }
                    function assertIsMounted(fiber) {
                        !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, "Unable to find node on an unmounted component.") : void 0;
                    }
                    function findCurrentFiberUsingSlowPath(fiber) {
                        var alternate = fiber.alternate;
                        if (!alternate) {
                            var state = isFiberMountedImpl(fiber);
                            !(state !== UNMOUNTED) ? invariant(false, "Unable to find node on an unmounted component.") : void 0;
                            if (state === MOUNTING) {
                                return null;
                            }
                            return fiber;
                        }
                        var a = fiber;
                        var b = alternate;
                        while (true) {
                            var parentA = a["return"];
                            var parentB = parentA ? parentA.alternate : null;
                            if (!parentA || !parentB) {
                                break;
                            }
                            if (parentA.child === parentB.child) {
                                var child = parentA.child;
                                while (child) {
                                    if (child === a) {
                                        assertIsMounted(parentA);
                                        return fiber;
                                    }
                                    if (child === b) {
                                        assertIsMounted(parentA);
                                        return alternate;
                                    }
                                    child = child.sibling;
                                }
                                invariant(false, "Unable to find node on an unmounted component.");
                            }
                            if (a["return"] !== b["return"]) {
                                a = parentA;
                                b = parentB;
                            } else {
                                var didFindChild = false;
                                var _child = parentA.child;
                                while (_child) {
                                    if (_child === a) {
                                        didFindChild = true;
                                        a = parentA;
                                        b = parentB;
                                        break;
                                    }
                                    if (_child === b) {
                                        didFindChild = true;
                                        b = parentA;
                                        a = parentB;
                                        break;
                                    }
                                    _child = _child.sibling;
                                }
                                if (!didFindChild) {
                                    _child = parentB.child;
                                    while (_child) {
                                        if (_child === a) {
                                            didFindChild = true;
                                            a = parentB;
                                            b = parentA;
                                            break;
                                        }
                                        if (_child === b) {
                                            didFindChild = true;
                                            b = parentB;
                                            a = parentA;
                                            break;
                                        }
                                        _child = _child.sibling;
                                    }
                                    !didFindChild ? invariant(false, "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.") : void 0;
                                }
                            }
                            !(a.alternate === b) ? invariant(false, "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                        }
                        !(a.tag === HostRoot) ? invariant(false, "Unable to find node on an unmounted component.") : void 0;
                        if (a.stateNode.current === a) {
                            return fiber;
                        }
                        return alternate;
                    }
                    function findCurrentHostFiber(parent) {
                        var currentParent = findCurrentFiberUsingSlowPath(parent);
                        if (!currentParent) {
                            return null;
                        }
                        var node = currentParent;
                        while (true) {
                            if (node.tag === HostComponent || node.tag === HostText) {
                                return node;
                            } else if (node.child) {
                                node.child["return"] = node;
                                node = node.child;
                                continue;
                            }
                            if (node === currentParent) {
                                return null;
                            }
                            while (!node.sibling) {
                                if (!node["return"] || node["return"] === currentParent) {
                                    return null;
                                }
                                node = node["return"];
                            }
                            node.sibling["return"] = node["return"];
                            node = node.sibling;
                        }
                        return null;
                    }
                    function findCurrentHostFiberWithNoPortals(parent) {
                        var currentParent = findCurrentFiberUsingSlowPath(parent);
                        if (!currentParent) {
                            return null;
                        }
                        var node = currentParent;
                        while (true) {
                            if (node.tag === HostComponent || node.tag === HostText) {
                                return node;
                            } else if (node.child && node.tag !== HostPortal) {
                                node.child["return"] = node;
                                node = node.child;
                                continue;
                            }
                            if (node === currentParent) {
                                return null;
                            }
                            while (!node.sibling) {
                                if (!node["return"] || node["return"] === currentParent) {
                                    return null;
                                }
                                node = node["return"];
                            }
                            node.sibling["return"] = node["return"];
                            node = node.sibling;
                        }
                        return null;
                    }
                    var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
                    var callbackBookkeepingPool = [];
                    function findRootContainerNode(inst) {
                        while (inst["return"]) {
                            inst = inst["return"];
                        }
                        if (inst.tag !== HostRoot) {
                            return null;
                        }
                        return inst.stateNode.containerInfo;
                    }
                    function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
                        if (callbackBookkeepingPool.length) {
                            var instance = callbackBookkeepingPool.pop();
                            instance.topLevelType = topLevelType;
                            instance.nativeEvent = nativeEvent;
                            instance.targetInst = targetInst;
                            return instance;
                        }
                        return {
                            topLevelType: topLevelType,
                            nativeEvent: nativeEvent,
                            targetInst: targetInst,
                            ancestors: []
                        };
                    }
                    function releaseTopLevelCallbackBookKeeping(instance) {
                        instance.topLevelType = null;
                        instance.nativeEvent = null;
                        instance.targetInst = null;
                        instance.ancestors.length = 0;
                        if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
                            callbackBookkeepingPool.push(instance);
                        }
                    }
                    function handleTopLevelImpl(bookKeeping) {
                        var targetInst = bookKeeping.targetInst;
                        var ancestor = targetInst;
                        do {
                            if (!ancestor) {
                                bookKeeping.ancestors.push(ancestor);
                                break;
                            }
                            var root = findRootContainerNode(ancestor);
                            if (!root) {
                                break;
                            }
                            bookKeeping.ancestors.push(ancestor);
                            ancestor = getClosestInstanceFromNode(root);
                        } while (ancestor);
                        for (var i = 0; i < bookKeeping.ancestors.length; i++) {
                            targetInst = bookKeeping.ancestors[i];
                            _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
                        }
                    }
                    var _enabled = true;
                    var _handleTopLevel = void 0;
                    function setHandleTopLevel(handleTopLevel) {
                        _handleTopLevel = handleTopLevel;
                    }
                    function setEnabled(enabled) {
                        _enabled = !!enabled;
                    }
                    function isEnabled() {
                        return _enabled;
                    }
                    function trapBubbledEvent(topLevelType, handlerBaseName, element) {
                        if (!element) {
                            return null;
                        }
                        return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
                    }
                    function trapCapturedEvent(topLevelType, handlerBaseName, element) {
                        if (!element) {
                            return null;
                        }
                        return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
                    }
                    function dispatchEvent(topLevelType, nativeEvent) {
                        if (!_enabled) {
                            return;
                        }
                        var nativeEventTarget = getEventTarget(nativeEvent);
                        var targetInst = getClosestInstanceFromNode(nativeEventTarget);
                        if (targetInst !== null && typeof targetInst.tag === "number" && !isFiberMounted(targetInst)) {
                            targetInst = null;
                        }
                        var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);
                        try {
                            batchedUpdates(handleTopLevelImpl, bookKeeping);
                        } finally {
                            releaseTopLevelCallbackBookKeeping(bookKeeping);
                        }
                    }
                    var ReactDOMEventListener = Object.freeze({
                        get _enabled() {
                            return _enabled;
                        },
                        get _handleTopLevel() {
                            return _handleTopLevel;
                        },
                        setHandleTopLevel: setHandleTopLevel,
                        setEnabled: setEnabled,
                        isEnabled: isEnabled,
                        trapBubbledEvent: trapBubbledEvent,
                        trapCapturedEvent: trapCapturedEvent,
                        dispatchEvent: dispatchEvent
                    });
                    function makePrefixMap(styleProp, eventName) {
                        var prefixes = {};
                        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
                        prefixes["Webkit" + styleProp] = "webkit" + eventName;
                        prefixes["Moz" + styleProp] = "moz" + eventName;
                        prefixes["ms" + styleProp] = "MS" + eventName;
                        prefixes["O" + styleProp] = "o" + eventName.toLowerCase();
                        return prefixes;
                    }
                    var vendorPrefixes = {
                        animationend: makePrefixMap("Animation", "AnimationEnd"),
                        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
                        animationstart: makePrefixMap("Animation", "AnimationStart"),
                        transitionend: makePrefixMap("Transition", "TransitionEnd")
                    };
                    var prefixedEventNames = {};
                    var style = {};
                    if (ExecutionEnvironment.canUseDOM) {
                        style = document.createElement("div").style;
                        if (!("AnimationEvent" in window)) {
                            delete vendorPrefixes.animationend.animation;
                            delete vendorPrefixes.animationiteration.animation;
                            delete vendorPrefixes.animationstart.animation;
                        }
                        if (!("TransitionEvent" in window)) {
                            delete vendorPrefixes.transitionend.transition;
                        }
                    }
                    function getVendorPrefixedEventName(eventName) {
                        if (prefixedEventNames[eventName]) {
                            return prefixedEventNames[eventName];
                        } else if (!vendorPrefixes[eventName]) {
                            return eventName;
                        }
                        var prefixMap = vendorPrefixes[eventName];
                        for (var styleProp in prefixMap) {
                            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                                return prefixedEventNames[eventName] = prefixMap[styleProp];
                            }
                        }
                        return "";
                    }
                    var topLevelTypes$1 = {
                        topAbort: "abort",
                        topAnimationEnd: getVendorPrefixedEventName("animationend") || "animationend",
                        topAnimationIteration: getVendorPrefixedEventName("animationiteration") || "animationiteration",
                        topAnimationStart: getVendorPrefixedEventName("animationstart") || "animationstart",
                        topBlur: "blur",
                        topCancel: "cancel",
                        topCanPlay: "canplay",
                        topCanPlayThrough: "canplaythrough",
                        topChange: "change",
                        topClick: "click",
                        topClose: "close",
                        topCompositionEnd: "compositionend",
                        topCompositionStart: "compositionstart",
                        topCompositionUpdate: "compositionupdate",
                        topContextMenu: "contextmenu",
                        topCopy: "copy",
                        topCut: "cut",
                        topDoubleClick: "dblclick",
                        topDrag: "drag",
                        topDragEnd: "dragend",
                        topDragEnter: "dragenter",
                        topDragExit: "dragexit",
                        topDragLeave: "dragleave",
                        topDragOver: "dragover",
                        topDragStart: "dragstart",
                        topDrop: "drop",
                        topDurationChange: "durationchange",
                        topEmptied: "emptied",
                        topEncrypted: "encrypted",
                        topEnded: "ended",
                        topError: "error",
                        topFocus: "focus",
                        topInput: "input",
                        topKeyDown: "keydown",
                        topKeyPress: "keypress",
                        topKeyUp: "keyup",
                        topLoadedData: "loadeddata",
                        topLoad: "load",
                        topLoadedMetadata: "loadedmetadata",
                        topLoadStart: "loadstart",
                        topMouseDown: "mousedown",
                        topMouseMove: "mousemove",
                        topMouseOut: "mouseout",
                        topMouseOver: "mouseover",
                        topMouseUp: "mouseup",
                        topPaste: "paste",
                        topPause: "pause",
                        topPlay: "play",
                        topPlaying: "playing",
                        topProgress: "progress",
                        topRateChange: "ratechange",
                        topScroll: "scroll",
                        topSeeked: "seeked",
                        topSeeking: "seeking",
                        topSelectionChange: "selectionchange",
                        topStalled: "stalled",
                        topSuspend: "suspend",
                        topTextInput: "textInput",
                        topTimeUpdate: "timeupdate",
                        topToggle: "toggle",
                        topTouchCancel: "touchcancel",
                        topTouchEnd: "touchend",
                        topTouchMove: "touchmove",
                        topTouchStart: "touchstart",
                        topTransitionEnd: getVendorPrefixedEventName("transitionend") || "transitionend",
                        topVolumeChange: "volumechange",
                        topWaiting: "waiting",
                        topWheel: "wheel"
                    };
                    var BrowserEventConstants = {
                        topLevelTypes: topLevelTypes$1
                    };
                    function runEventQueueInBatch(events) {
                        enqueueEvents(events);
                        processEventQueue(false);
                    }
                    function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                        var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
                        runEventQueueInBatch(events);
                    }
                    var topLevelTypes = BrowserEventConstants.topLevelTypes;
                    var alreadyListeningTo = {};
                    var reactTopListenersCounter = 0;
                    var topListenersIDKey = "_reactListenersID" + ("" + Math.random()).slice(2);
                    function getListeningForDocument(mountAt) {
                        if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
                            mountAt[topListenersIDKey] = reactTopListenersCounter++;
                            alreadyListeningTo[mountAt[topListenersIDKey]] = {};
                        }
                        return alreadyListeningTo[mountAt[topListenersIDKey]];
                    }
                    function listenTo(registrationName, contentDocumentHandle) {
                        var mountAt = contentDocumentHandle;
                        var isListening = getListeningForDocument(mountAt);
                        var dependencies = registrationNameDependencies[registrationName];
                        for (var i = 0; i < dependencies.length; i++) {
                            var dependency = dependencies[i];
                            if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
                                if (dependency === "topScroll") {
                                    trapCapturedEvent("topScroll", "scroll", mountAt);
                                } else if (dependency === "topFocus" || dependency === "topBlur") {
                                    trapCapturedEvent("topFocus", "focus", mountAt);
                                    trapCapturedEvent("topBlur", "blur", mountAt);
                                    isListening.topBlur = true;
                                    isListening.topFocus = true;
                                } else if (dependency === "topCancel") {
                                    if (isEventSupported("cancel", true)) {
                                        trapCapturedEvent("topCancel", "cancel", mountAt);
                                    }
                                    isListening.topCancel = true;
                                } else if (dependency === "topClose") {
                                    if (isEventSupported("close", true)) {
                                        trapCapturedEvent("topClose", "close", mountAt);
                                    }
                                    isListening.topClose = true;
                                } else if (topLevelTypes.hasOwnProperty(dependency)) {
                                    trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);
                                }
                                isListening[dependency] = true;
                            }
                        }
                    }
                    function isListeningToAllDependencies(registrationName, mountAt) {
                        var isListening = getListeningForDocument(mountAt);
                        var dependencies = registrationNameDependencies[registrationName];
                        for (var i = 0; i < dependencies.length; i++) {
                            var dependency = dependencies[i];
                            if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
                                return false;
                            }
                        }
                        return true;
                    }
                    function getLeafNode(node) {
                        while (node && node.firstChild) {
                            node = node.firstChild;
                        }
                        return node;
                    }
                    function getSiblingNode(node) {
                        while (node) {
                            if (node.nextSibling) {
                                return node.nextSibling;
                            }
                            node = node.parentNode;
                        }
                    }
                    function getNodeForCharacterOffset(root, offset) {
                        var node = getLeafNode(root);
                        var nodeStart = 0;
                        var nodeEnd = 0;
                        while (node) {
                            if (node.nodeType === TEXT_NODE) {
                                nodeEnd = nodeStart + node.textContent.length;
                                if (nodeStart <= offset && nodeEnd >= offset) {
                                    return {
                                        node: node,
                                        offset: offset - nodeStart
                                    };
                                }
                                nodeStart = nodeEnd;
                            }
                            node = getLeafNode(getSiblingNode(node));
                        }
                    }
                    function getOffsets(outerNode) {
                        var selection = window.getSelection && window.getSelection();
                        if (!selection || selection.rangeCount === 0) {
                            return null;
                        }
                        var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode$$1 = selection.focusNode, focusOffset = selection.focusOffset;
                        try {
                            anchorNode.nodeType;
                            focusNode$$1.nodeType;
                        } catch (e) {
                            return null;
                        }
                        return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);
                    }
                    function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {
                        var length = 0;
                        var start = -1;
                        var end = -1;
                        var indexWithinAnchor = 0;
                        var indexWithinFocus = 0;
                        var node = outerNode;
                        var parentNode = null;
                        outer: while (true) {
                            var next = null;
                            while (true) {
                                if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                                    start = length + anchorOffset;
                                }
                                if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                                    end = length + focusOffset;
                                }
                                if (node.nodeType === TEXT_NODE) {
                                    length += node.nodeValue.length;
                                }
                                if ((next = node.firstChild) === null) {
                                    break;
                                }
                                parentNode = node;
                                node = next;
                            }
                            while (true) {
                                if (node === outerNode) {
                                    break outer;
                                }
                                if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                                    start = length;
                                }
                                if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {
                                    end = length;
                                }
                                if ((next = node.nextSibling) !== null) {
                                    break;
                                }
                                node = parentNode;
                                parentNode = node.parentNode;
                            }
                            node = next;
                        }
                        if (start === -1 || end === -1) {
                            return null;
                        }
                        return {
                            start: start,
                            end: end
                        };
                    }
                    function setOffsets(node, offsets) {
                        if (!window.getSelection) {
                            return;
                        }
                        var selection = window.getSelection();
                        var length = node[getTextContentAccessor()].length;
                        var start = Math.min(offsets.start, length);
                        var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
                        if (!selection.extend && start > end) {
                            var temp = end;
                            end = start;
                            start = temp;
                        }
                        var startMarker = getNodeForCharacterOffset(node, start);
                        var endMarker = getNodeForCharacterOffset(node, end);
                        if (startMarker && endMarker) {
                            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                                return;
                            }
                            var range = document.createRange();
                            range.setStart(startMarker.node, startMarker.offset);
                            selection.removeAllRanges();
                            if (start > end) {
                                selection.addRange(range);
                                selection.extend(endMarker.node, endMarker.offset);
                            } else {
                                range.setEnd(endMarker.node, endMarker.offset);
                                selection.addRange(range);
                            }
                        }
                    }
                    function isInDocument(node) {
                        return containsNode(document.documentElement, node);
                    }
                    function hasSelectionCapabilities(elem) {
                        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
                        return nodeName && (nodeName === "input" && elem.type === "text" || nodeName === "textarea" || elem.contentEditable === "true");
                    }
                    function getSelectionInformation() {
                        var focusedElem = getActiveElement();
                        return {
                            focusedElem: focusedElem,
                            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null
                        };
                    }
                    function restoreSelection(priorSelectionInformation) {
                        var curFocusedElem = getActiveElement();
                        var priorFocusedElem = priorSelectionInformation.focusedElem;
                        var priorSelectionRange = priorSelectionInformation.selectionRange;
                        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
                            if (hasSelectionCapabilities(priorFocusedElem)) {
                                setSelection(priorFocusedElem, priorSelectionRange);
                            }
                            var ancestors = [];
                            var ancestor = priorFocusedElem;
                            while (ancestor = ancestor.parentNode) {
                                if (ancestor.nodeType === ELEMENT_NODE) {
                                    ancestors.push({
                                        element: ancestor,
                                        left: ancestor.scrollLeft,
                                        top: ancestor.scrollTop
                                    });
                                }
                            }
                            focusNode(priorFocusedElem);
                            for (var i = 0; i < ancestors.length; i++) {
                                var info = ancestors[i];
                                info.element.scrollLeft = info.left;
                                info.element.scrollTop = info.top;
                            }
                        }
                    }
                    function getSelection$1(input) {
                        var selection = void 0;
                        if ("selectionStart" in input) {
                            selection = {
                                start: input.selectionStart,
                                end: input.selectionEnd
                            };
                        } else {
                            selection = getOffsets(input);
                        }
                        return selection || {
                            start: 0,
                            end: 0
                        };
                    }
                    function setSelection(input, offsets) {
                        var start = offsets.start, end = offsets.end;
                        if (end === undefined) {
                            end = start;
                        }
                        if ("selectionStart" in input) {
                            input.selectionStart = start;
                            input.selectionEnd = Math.min(end, input.value.length);
                        } else {
                            setOffsets(input, offsets);
                        }
                    }
                    var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && "documentMode" in document && document.documentMode <= 11;
                    var eventTypes$3 = {
                        select: {
                            phasedRegistrationNames: {
                                bubbled: "onSelect",
                                captured: "onSelectCapture"
                            },
                            dependencies: [ "topBlur", "topContextMenu", "topFocus", "topKeyDown", "topKeyUp", "topMouseDown", "topMouseUp", "topSelectionChange" ]
                        }
                    };
                    var activeElement$1 = null;
                    var activeElementInst$1 = null;
                    var lastSelection = null;
                    var mouseDown = false;
                    function getSelection(node) {
                        if ("selectionStart" in node && hasSelectionCapabilities(node)) {
                            return {
                                start: node.selectionStart,
                                end: node.selectionEnd
                            };
                        } else if (window.getSelection) {
                            var selection = window.getSelection();
                            return {
                                anchorNode: selection.anchorNode,
                                anchorOffset: selection.anchorOffset,
                                focusNode: selection.focusNode,
                                focusOffset: selection.focusOffset
                            };
                        }
                    }
                    function constructSelectEvent(nativeEvent, nativeEventTarget) {
                        if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {
                            return null;
                        }
                        var currentSelection = getSelection(activeElement$1);
                        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
                            lastSelection = currentSelection;
                            var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);
                            syntheticEvent.type = "select";
                            syntheticEvent.target = activeElement$1;
                            accumulateTwoPhaseDispatches(syntheticEvent);
                            return syntheticEvent;
                        }
                        return null;
                    }
                    var SelectEventPlugin = {
                        eventTypes: eventTypes$3,
                        extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                            var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;
                            if (!doc || !isListeningToAllDependencies("onSelect", doc)) {
                                return null;
                            }
                            var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;
                            switch (topLevelType) {
                              case "topFocus":
                                if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                                    activeElement$1 = targetNode;
                                    activeElementInst$1 = targetInst;
                                    lastSelection = null;
                                }
                                break;

                              case "topBlur":
                                activeElement$1 = null;
                                activeElementInst$1 = null;
                                lastSelection = null;
                                break;

                              case "topMouseDown":
                                mouseDown = true;
                                break;

                              case "topContextMenu":
                              case "topMouseUp":
                                mouseDown = false;
                                return constructSelectEvent(nativeEvent, nativeEventTarget);

                              case "topSelectionChange":
                                if (skipSelectionChangeEvent) {
                                    break;
                                }

                              case "topKeyDown":
                              case "topKeyUp":
                                return constructSelectEvent(nativeEvent, nativeEventTarget);
                            }
                            return null;
                        }
                    };
                    var AnimationEventInterface = {
                        animationName: null,
                        elapsedTime: null,
                        pseudoElement: null
                    };
                    function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
                    var ClipboardEventInterface = {
                        clipboardData: function(event) {
                            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
                        }
                    };
                    function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
                    var FocusEventInterface = {
                        relatedTarget: null
                    };
                    function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
                    function getEventCharCode(nativeEvent) {
                        var charCode;
                        var keyCode = nativeEvent.keyCode;
                        if ("charCode" in nativeEvent) {
                            charCode = nativeEvent.charCode;
                            if (charCode === 0 && keyCode === 13) {
                                charCode = 13;
                            }
                        } else {
                            charCode = keyCode;
                        }
                        if (charCode >= 32 || charCode === 13) {
                            return charCode;
                        }
                        return 0;
                    }
                    var normalizeKey = {
                        Esc: "Escape",
                        Spacebar: " ",
                        Left: "ArrowLeft",
                        Up: "ArrowUp",
                        Right: "ArrowRight",
                        Down: "ArrowDown",
                        Del: "Delete",
                        Win: "OS",
                        Menu: "ContextMenu",
                        Apps: "ContextMenu",
                        Scroll: "ScrollLock",
                        MozPrintableKey: "Unidentified"
                    };
                    var translateToKey = {
                        "8": "Backspace",
                        "9": "Tab",
                        "12": "Clear",
                        "13": "Enter",
                        "16": "Shift",
                        "17": "Control",
                        "18": "Alt",
                        "19": "Pause",
                        "20": "CapsLock",
                        "27": "Escape",
                        "32": " ",
                        "33": "PageUp",
                        "34": "PageDown",
                        "35": "End",
                        "36": "Home",
                        "37": "ArrowLeft",
                        "38": "ArrowUp",
                        "39": "ArrowRight",
                        "40": "ArrowDown",
                        "45": "Insert",
                        "46": "Delete",
                        "112": "F1",
                        "113": "F2",
                        "114": "F3",
                        "115": "F4",
                        "116": "F5",
                        "117": "F6",
                        "118": "F7",
                        "119": "F8",
                        "120": "F9",
                        "121": "F10",
                        "122": "F11",
                        "123": "F12",
                        "144": "NumLock",
                        "145": "ScrollLock",
                        "224": "Meta"
                    };
                    function getEventKey(nativeEvent) {
                        if (nativeEvent.key) {
                            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                            if (key !== "Unidentified") {
                                return key;
                            }
                        }
                        if (nativeEvent.type === "keypress") {
                            var charCode = getEventCharCode(nativeEvent);
                            return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
                        }
                        if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
                            return translateToKey[nativeEvent.keyCode] || "Unidentified";
                        }
                        return "";
                    }
                    var KeyboardEventInterface = {
                        key: getEventKey,
                        location: null,
                        ctrlKey: null,
                        shiftKey: null,
                        altKey: null,
                        metaKey: null,
                        repeat: null,
                        locale: null,
                        getModifierState: getEventModifierState,
                        charCode: function(event) {
                            if (event.type === "keypress") {
                                return getEventCharCode(event);
                            }
                            return 0;
                        },
                        keyCode: function(event) {
                            if (event.type === "keydown" || event.type === "keyup") {
                                return event.keyCode;
                            }
                            return 0;
                        },
                        which: function(event) {
                            if (event.type === "keypress") {
                                return getEventCharCode(event);
                            }
                            if (event.type === "keydown" || event.type === "keyup") {
                                return event.keyCode;
                            }
                            return 0;
                        }
                    };
                    function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
                    var DragEventInterface = {
                        dataTransfer: null
                    };
                    function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
                    var TouchEventInterface = {
                        touches: null,
                        targetTouches: null,
                        changedTouches: null,
                        altKey: null,
                        metaKey: null,
                        ctrlKey: null,
                        shiftKey: null,
                        getModifierState: getEventModifierState
                    };
                    function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
                    var TransitionEventInterface = {
                        propertyName: null,
                        elapsedTime: null,
                        pseudoElement: null
                    };
                    function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
                    var WheelEventInterface = {
                        deltaX: function(event) {
                            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
                        },
                        deltaY: function(event) {
                            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
                        },
                        deltaZ: null,
                        deltaMode: null
                    };
                    function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                        return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
                    }
                    SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
                    var eventTypes$4 = {};
                    var topLevelEventsToDispatchConfig = {};
                    [ "abort", "animationEnd", "animationIteration", "animationStart", "blur", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "doubleClick", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "focus", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "progress", "rateChange", "reset", "scroll", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "toggle", "touchCancel", "touchEnd", "touchMove", "touchStart", "transitionEnd", "volumeChange", "waiting", "wheel" ].forEach(function(event) {
                        var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
                        var onEvent = "on" + capitalizedEvent;
                        var topEvent = "top" + capitalizedEvent;
                        var type = {
                            phasedRegistrationNames: {
                                bubbled: onEvent,
                                captured: onEvent + "Capture"
                            },
                            dependencies: [ topEvent ]
                        };
                        eventTypes$4[event] = type;
                        topLevelEventsToDispatchConfig[topEvent] = type;
                    });
                    var knownHTMLTopLevelTypes = [ "topAbort", "topCancel", "topCanPlay", "topCanPlayThrough", "topClose", "topDurationChange", "topEmptied", "topEncrypted", "topEnded", "topError", "topInput", "topInvalid", "topLoad", "topLoadedData", "topLoadedMetadata", "topLoadStart", "topPause", "topPlay", "topPlaying", "topProgress", "topRateChange", "topReset", "topSeeked", "topSeeking", "topStalled", "topSubmit", "topSuspend", "topTimeUpdate", "topToggle", "topVolumeChange", "topWaiting" ];
                    var SimpleEventPlugin = {
                        eventTypes: eventTypes$4,
                        extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
                            var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
                            if (!dispatchConfig) {
                                return null;
                            }
                            var EventConstructor;
                            switch (topLevelType) {
                              case "topKeyPress":
                                if (getEventCharCode(nativeEvent) === 0) {
                                    return null;
                                }

                              case "topKeyDown":
                              case "topKeyUp":
                                EventConstructor = SyntheticKeyboardEvent;
                                break;

                              case "topBlur":
                              case "topFocus":
                                EventConstructor = SyntheticFocusEvent;
                                break;

                              case "topClick":
                                if (nativeEvent.button === 2) {
                                    return null;
                                }

                              case "topDoubleClick":
                              case "topMouseDown":
                              case "topMouseMove":
                              case "topMouseUp":
                              case "topMouseOut":
                              case "topMouseOver":
                              case "topContextMenu":
                                EventConstructor = SyntheticMouseEvent;
                                break;

                              case "topDrag":
                              case "topDragEnd":
                              case "topDragEnter":
                              case "topDragExit":
                              case "topDragLeave":
                              case "topDragOver":
                              case "topDragStart":
                              case "topDrop":
                                EventConstructor = SyntheticDragEvent;
                                break;

                              case "topTouchCancel":
                              case "topTouchEnd":
                              case "topTouchMove":
                              case "topTouchStart":
                                EventConstructor = SyntheticTouchEvent;
                                break;

                              case "topAnimationEnd":
                              case "topAnimationIteration":
                              case "topAnimationStart":
                                EventConstructor = SyntheticAnimationEvent;
                                break;

                              case "topTransitionEnd":
                                EventConstructor = SyntheticTransitionEvent;
                                break;

                              case "topScroll":
                                EventConstructor = SyntheticUIEvent;
                                break;

                              case "topWheel":
                                EventConstructor = SyntheticWheelEvent;
                                break;

                              case "topCopy":
                              case "topCut":
                              case "topPaste":
                                EventConstructor = SyntheticClipboardEvent;
                                break;

                              default:
                                {
                                    if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
                                        warning(false, "SimpleEventPlugin: Unhandled event type, `%s`. This warning " + "is likely caused by a bug in React. Please file an issue.", topLevelType);
                                    }
                                }
                                EventConstructor = SyntheticEvent$1;
                                break;
                            }
                            var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
                            accumulateTwoPhaseDispatches(event);
                            return event;
                        }
                    };
                    setHandleTopLevel(handleTopLevel);
                    injection$1.injectEventPluginOrder(DOMEventPluginOrder);
                    injection$2.injectComponentTree(ReactDOMComponentTree);
                    injection$1.injectEventPluginsByName({
                        SimpleEventPlugin: SimpleEventPlugin,
                        EnterLeaveEventPlugin: EnterLeaveEventPlugin,
                        ChangeEventPlugin: ChangeEventPlugin,
                        SelectEventPlugin: SelectEventPlugin,
                        BeforeInputEventPlugin: BeforeInputEventPlugin
                    });
                    var enableAsyncSubtreeAPI = true;
                    var enableAsyncSchedulingByDefaultInReactDOM = false;
                    var enableCreateRoot = false;
                    var enableUserTimingAPI = true;
                    var enableMutatingReconciler = true;
                    var enableNoopReconciler = false;
                    var enablePersistentReconciler = false;
                    var debugRenderPhaseSideEffects = false;
                    var valueStack = [];
                    {
                        var fiberStack = [];
                    }
                    var index = -1;
                    function createCursor(defaultValue) {
                        return {
                            current: defaultValue
                        };
                    }
                    function pop(cursor, fiber) {
                        if (index < 0) {
                            {
                                warning(false, "Unexpected pop.");
                            }
                            return;
                        }
                        {
                            if (fiber !== fiberStack[index]) {
                                warning(false, "Unexpected Fiber popped.");
                            }
                        }
                        cursor.current = valueStack[index];
                        valueStack[index] = null;
                        {
                            fiberStack[index] = null;
                        }
                        index--;
                    }
                    function push(cursor, value, fiber) {
                        index++;
                        valueStack[index] = cursor.current;
                        {
                            fiberStack[index] = fiber;
                        }
                        cursor.current = value;
                    }
                    function reset$1() {
                        while (index > -1) {
                            valueStack[index] = null;
                            {
                                fiberStack[index] = null;
                            }
                            index--;
                        }
                    }
                    var describeComponentFrame = function(name, source, ownerName) {
                        return "\n    in " + (name || "Unknown") + (source ? " (at " + source.fileName.replace(/^.*[\\\/]/, "") + ":" + source.lineNumber + ")" : ownerName ? " (created by " + ownerName + ")" : "");
                    };
                    function describeFiber(fiber) {
                        switch (fiber.tag) {
                          case IndeterminateComponent:
                          case FunctionalComponent:
                          case ClassComponent:
                          case HostComponent:
                            var owner = fiber._debugOwner;
                            var source = fiber._debugSource;
                            var name = getComponentName(fiber);
                            var ownerName = null;
                            if (owner) {
                                ownerName = getComponentName(owner);
                            }
                            return describeComponentFrame(name, source, ownerName);

                          default:
                            return "";
                        }
                    }
                    function getStackAddendumByWorkInProgressFiber(workInProgress) {
                        var info = "";
                        var node = workInProgress;
                        do {
                            info += describeFiber(node);
                            node = node["return"];
                        } while (node);
                        return info;
                    }
                    function getCurrentFiberOwnerName() {
                        {
                            var fiber = ReactDebugCurrentFiber.current;
                            if (fiber === null) {
                                return null;
                            }
                            var owner = fiber._debugOwner;
                            if (owner !== null && typeof owner !== "undefined") {
                                return getComponentName(owner);
                            }
                        }
                        return null;
                    }
                    function getCurrentFiberStackAddendum() {
                        {
                            var fiber = ReactDebugCurrentFiber.current;
                            if (fiber === null) {
                                return null;
                            }
                            return getStackAddendumByWorkInProgressFiber(fiber);
                        }
                        return null;
                    }
                    function resetCurrentFiber() {
                        ReactDebugCurrentFrame.getCurrentStack = null;
                        ReactDebugCurrentFiber.current = null;
                        ReactDebugCurrentFiber.phase = null;
                    }
                    function setCurrentFiber(fiber) {
                        ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
                        ReactDebugCurrentFiber.current = fiber;
                        ReactDebugCurrentFiber.phase = null;
                    }
                    function setCurrentPhase(phase) {
                        ReactDebugCurrentFiber.phase = phase;
                    }
                    var ReactDebugCurrentFiber = {
                        current: null,
                        phase: null,
                        resetCurrentFiber: resetCurrentFiber,
                        setCurrentFiber: setCurrentFiber,
                        setCurrentPhase: setCurrentPhase,
                        getCurrentFiberOwnerName: getCurrentFiberOwnerName,
                        getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
                    };
                    var reactEmoji = "";
                    var warningEmoji = "";
                    var supportsUserTiming = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.clearMarks === "function" && typeof performance.measure === "function" && typeof performance.clearMeasures === "function";
                    var currentFiber = null;
                    var currentPhase = null;
                    var currentPhaseFiber = null;
                    var isCommitting = false;
                    var hasScheduledUpdateInCurrentCommit = false;
                    var hasScheduledUpdateInCurrentPhase = false;
                    var commitCountInCurrentWorkLoop = 0;
                    var effectCountInCurrentCommit = 0;
                    var isWaitingForCallback = false;
                    var labelsInCurrentCommit = new Set();
                    var formatMarkName = function(markName) {
                        return reactEmoji + " " + markName;
                    };
                    var formatLabel = function(label, warning$$1) {
                        var prefix = warning$$1 ? warningEmoji + " " : reactEmoji + " ";
                        var suffix = warning$$1 ? " Warning: " + warning$$1 : "";
                        return "" + prefix + label + suffix;
                    };
                    var beginMark = function(markName) {
                        performance.mark(formatMarkName(markName));
                    };
                    var clearMark = function(markName) {
                        performance.clearMarks(formatMarkName(markName));
                    };
                    var endMark = function(label, markName, warning$$1) {
                        var formattedMarkName = formatMarkName(markName);
                        var formattedLabel = formatLabel(label, warning$$1);
                        try {
                            performance.measure(formattedLabel, formattedMarkName);
                        } catch (err) {}
                        performance.clearMarks(formattedMarkName);
                        performance.clearMeasures(formattedLabel);
                    };
                    var getFiberMarkName = function(label, debugID) {
                        return label + " (#" + debugID + ")";
                    };
                    var getFiberLabel = function(componentName, isMounted, phase) {
                        if (phase === null) {
                            return componentName + " [" + (isMounted ? "update" : "mount") + "]";
                        } else {
                            return componentName + "." + phase;
                        }
                    };
                    var beginFiberMark = function(fiber, phase) {
                        var componentName = getComponentName(fiber) || "Unknown";
                        var debugID = fiber._debugID;
                        var isMounted = fiber.alternate !== null;
                        var label = getFiberLabel(componentName, isMounted, phase);
                        if (isCommitting && labelsInCurrentCommit.has(label)) {
                            return false;
                        }
                        labelsInCurrentCommit.add(label);
                        var markName = getFiberMarkName(label, debugID);
                        beginMark(markName);
                        return true;
                    };
                    var clearFiberMark = function(fiber, phase) {
                        var componentName = getComponentName(fiber) || "Unknown";
                        var debugID = fiber._debugID;
                        var isMounted = fiber.alternate !== null;
                        var label = getFiberLabel(componentName, isMounted, phase);
                        var markName = getFiberMarkName(label, debugID);
                        clearMark(markName);
                    };
                    var endFiberMark = function(fiber, phase, warning$$1) {
                        var componentName = getComponentName(fiber) || "Unknown";
                        var debugID = fiber._debugID;
                        var isMounted = fiber.alternate !== null;
                        var label = getFiberLabel(componentName, isMounted, phase);
                        var markName = getFiberMarkName(label, debugID);
                        endMark(label, markName, warning$$1);
                    };
                    var shouldIgnoreFiber = function(fiber) {
                        switch (fiber.tag) {
                          case HostRoot:
                          case HostComponent:
                          case HostText:
                          case HostPortal:
                          case ReturnComponent:
                          case Fragment:
                            return true;

                          default:
                            return false;
                        }
                    };
                    var clearPendingPhaseMeasurement = function() {
                        if (currentPhase !== null && currentPhaseFiber !== null) {
                            clearFiberMark(currentPhaseFiber, currentPhase);
                        }
                        currentPhaseFiber = null;
                        currentPhase = null;
                        hasScheduledUpdateInCurrentPhase = false;
                    };
                    var pauseTimers = function() {
                        var fiber = currentFiber;
                        while (fiber) {
                            if (fiber._debugIsCurrentlyTiming) {
                                endFiberMark(fiber, null, null);
                            }
                            fiber = fiber["return"];
                        }
                    };
                    var resumeTimersRecursively = function(fiber) {
                        if (fiber["return"] !== null) {
                            resumeTimersRecursively(fiber["return"]);
                        }
                        if (fiber._debugIsCurrentlyTiming) {
                            beginFiberMark(fiber, null);
                        }
                    };
                    var resumeTimers = function() {
                        if (currentFiber !== null) {
                            resumeTimersRecursively(currentFiber);
                        }
                    };
                    function recordEffect() {
                        if (enableUserTimingAPI) {
                            effectCountInCurrentCommit++;
                        }
                    }
                    function recordScheduleUpdate() {
                        if (enableUserTimingAPI) {
                            if (isCommitting) {
                                hasScheduledUpdateInCurrentCommit = true;
                            }
                            if (currentPhase !== null && currentPhase !== "componentWillMount" && currentPhase !== "componentWillReceiveProps") {
                                hasScheduledUpdateInCurrentPhase = true;
                            }
                        }
                    }
                    function startRequestCallbackTimer() {
                        if (enableUserTimingAPI) {
                            if (supportsUserTiming && !isWaitingForCallback) {
                                isWaitingForCallback = true;
                                beginMark("(Waiting for async callback...)");
                            }
                        }
                    }
                    function stopRequestCallbackTimer(didExpire) {
                        if (enableUserTimingAPI) {
                            if (supportsUserTiming) {
                                isWaitingForCallback = false;
                                var warning$$1 = didExpire ? "React was blocked by main thread" : null;
                                endMark("(Waiting for async callback...)", "(Waiting for async callback...)", warning$$1);
                            }
                        }
                    }
                    function startWorkTimer(fiber) {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                                return;
                            }
                            currentFiber = fiber;
                            if (!beginFiberMark(fiber, null)) {
                                return;
                            }
                            fiber._debugIsCurrentlyTiming = true;
                        }
                    }
                    function cancelWorkTimer(fiber) {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                                return;
                            }
                            fiber._debugIsCurrentlyTiming = false;
                            clearFiberMark(fiber, null);
                        }
                    }
                    function stopWorkTimer(fiber) {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                                return;
                            }
                            currentFiber = fiber["return"];
                            if (!fiber._debugIsCurrentlyTiming) {
                                return;
                            }
                            fiber._debugIsCurrentlyTiming = false;
                            endFiberMark(fiber, null, null);
                        }
                    }
                    function stopFailedWorkTimer(fiber) {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                                return;
                            }
                            currentFiber = fiber["return"];
                            if (!fiber._debugIsCurrentlyTiming) {
                                return;
                            }
                            fiber._debugIsCurrentlyTiming = false;
                            var warning$$1 = "An error was thrown inside this error boundary";
                            endFiberMark(fiber, null, warning$$1);
                        }
                    }
                    function startPhaseTimer(fiber, phase) {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming) {
                                return;
                            }
                            clearPendingPhaseMeasurement();
                            if (!beginFiberMark(fiber, phase)) {
                                return;
                            }
                            currentPhaseFiber = fiber;
                            currentPhase = phase;
                        }
                    }
                    function stopPhaseTimer() {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming) {
                                return;
                            }
                            if (currentPhase !== null && currentPhaseFiber !== null) {
                                var warning$$1 = hasScheduledUpdateInCurrentPhase ? "Scheduled a cascading update" : null;
                                endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
                            }
                            currentPhase = null;
                            currentPhaseFiber = null;
                        }
                    }
                    function startWorkLoopTimer(nextUnitOfWork) {
                        if (enableUserTimingAPI) {
                            currentFiber = nextUnitOfWork;
                            if (!supportsUserTiming) {
                                return;
                            }
                            commitCountInCurrentWorkLoop = 0;
                            beginMark("(React Tree Reconciliation)");
                            resumeTimers();
                        }
                    }
                    function stopWorkLoopTimer(interruptedBy) {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming) {
                                return;
                            }
                            var warning$$1 = null;
                            if (interruptedBy !== null) {
                                if (interruptedBy.tag === HostRoot) {
                                    warning$$1 = "A top-level update interrupted the previous render";
                                } else {
                                    var componentName = getComponentName(interruptedBy) || "Unknown";
                                    warning$$1 = "An update to " + componentName + " interrupted the previous render";
                                }
                            } else if (commitCountInCurrentWorkLoop > 1) {
                                warning$$1 = "There were cascading updates";
                            }
                            commitCountInCurrentWorkLoop = 0;
                            pauseTimers();
                            endMark("(React Tree Reconciliation)", "(React Tree Reconciliation)", warning$$1);
                        }
                    }
                    function startCommitTimer() {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming) {
                                return;
                            }
                            isCommitting = true;
                            hasScheduledUpdateInCurrentCommit = false;
                            labelsInCurrentCommit.clear();
                            beginMark("(Committing Changes)");
                        }
                    }
                    function stopCommitTimer() {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming) {
                                return;
                            }
                            var warning$$1 = null;
                            if (hasScheduledUpdateInCurrentCommit) {
                                warning$$1 = "Lifecycle hook scheduled a cascading update";
                            } else if (commitCountInCurrentWorkLoop > 0) {
                                warning$$1 = "Caused by a cascading update in earlier commit";
                            }
                            hasScheduledUpdateInCurrentCommit = false;
                            commitCountInCurrentWorkLoop++;
                            isCommitting = false;
                            labelsInCurrentCommit.clear();
                            endMark("(Committing Changes)", "(Committing Changes)", warning$$1);
                        }
                    }
                    function startCommitHostEffectsTimer() {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming) {
                                return;
                            }
                            effectCountInCurrentCommit = 0;
                            beginMark("(Committing Host Effects)");
                        }
                    }
                    function stopCommitHostEffectsTimer() {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming) {
                                return;
                            }
                            var count = effectCountInCurrentCommit;
                            effectCountInCurrentCommit = 0;
                            endMark("(Committing Host Effects: " + count + " Total)", "(Committing Host Effects)", null);
                        }
                    }
                    function startCommitLifeCyclesTimer() {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming) {
                                return;
                            }
                            effectCountInCurrentCommit = 0;
                            beginMark("(Calling Lifecycle Methods)");
                        }
                    }
                    function stopCommitLifeCyclesTimer() {
                        if (enableUserTimingAPI) {
                            if (!supportsUserTiming) {
                                return;
                            }
                            var count = effectCountInCurrentCommit;
                            effectCountInCurrentCommit = 0;
                            endMark("(Calling Lifecycle Methods: " + count + " Total)", "(Calling Lifecycle Methods)", null);
                        }
                    }
                    {
                        var warnedAboutMissingGetChildContext = {};
                    }
                    var contextStackCursor = createCursor(emptyObject);
                    var didPerformWorkStackCursor = createCursor(false);
                    var previousContext = emptyObject;
                    function getUnmaskedContext(workInProgress) {
                        var hasOwnContext = isContextProvider(workInProgress);
                        if (hasOwnContext) {
                            return previousContext;
                        }
                        return contextStackCursor.current;
                    }
                    function cacheContext(workInProgress, unmaskedContext, maskedContext) {
                        var instance = workInProgress.stateNode;
                        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
                        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
                    }
                    function getMaskedContext(workInProgress, unmaskedContext) {
                        var type = workInProgress.type;
                        var contextTypes = type.contextTypes;
                        if (!contextTypes) {
                            return emptyObject;
                        }
                        var instance = workInProgress.stateNode;
                        if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                            return instance.__reactInternalMemoizedMaskedChildContext;
                        }
                        var context = {};
                        for (var key in contextTypes) {
                            context[key] = unmaskedContext[key];
                        }
                        {
                            var name = getComponentName(workInProgress) || "Unknown";
                            checkPropTypes(contextTypes, context, "context", name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
                        }
                        if (instance) {
                            cacheContext(workInProgress, unmaskedContext, context);
                        }
                        return context;
                    }
                    function hasContextChanged() {
                        return didPerformWorkStackCursor.current;
                    }
                    function isContextConsumer(fiber) {
                        return fiber.tag === ClassComponent && fiber.type.contextTypes != null;
                    }
                    function isContextProvider(fiber) {
                        return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;
                    }
                    function popContextProvider(fiber) {
                        if (!isContextProvider(fiber)) {
                            return;
                        }
                        pop(didPerformWorkStackCursor, fiber);
                        pop(contextStackCursor, fiber);
                    }
                    function popTopLevelContextObject(fiber) {
                        pop(didPerformWorkStackCursor, fiber);
                        pop(contextStackCursor, fiber);
                    }
                    function pushTopLevelContextObject(fiber, context, didChange) {
                        !(contextStackCursor.cursor == null) ? invariant(false, "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                        push(contextStackCursor, context, fiber);
                        push(didPerformWorkStackCursor, didChange, fiber);
                    }
                    function processChildContext(fiber, parentContext) {
                        var instance = fiber.stateNode;
                        var childContextTypes = fiber.type.childContextTypes;
                        if (typeof instance.getChildContext !== "function") {
                            {
                                var componentName = getComponentName(fiber) || "Unknown";
                                if (!warnedAboutMissingGetChildContext[componentName]) {
                                    warnedAboutMissingGetChildContext[componentName] = true;
                                    warning(false, "%s.childContextTypes is specified but there is no getChildContext() method " + "on the instance. You can either define getChildContext() on %s or remove " + "childContextTypes from it.", componentName, componentName);
                                }
                            }
                            return parentContext;
                        }
                        var childContext = void 0;
                        {
                            ReactDebugCurrentFiber.setCurrentPhase("getChildContext");
                        }
                        startPhaseTimer(fiber, "getChildContext");
                        childContext = instance.getChildContext();
                        stopPhaseTimer();
                        {
                            ReactDebugCurrentFiber.setCurrentPhase(null);
                        }
                        for (var contextKey in childContext) {
                            !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || "Unknown", contextKey) : void 0;
                        }
                        {
                            var name = getComponentName(fiber) || "Unknown";
                            checkPropTypes(childContextTypes, childContext, "child context", name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
                        }
                        return _assign({}, parentContext, childContext);
                    }
                    function pushContextProvider(workInProgress) {
                        if (!isContextProvider(workInProgress)) {
                            return false;
                        }
                        var instance = workInProgress.stateNode;
                        var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;
                        previousContext = contextStackCursor.current;
                        push(contextStackCursor, memoizedMergedChildContext, workInProgress);
                        push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
                        return true;
                    }
                    function invalidateContextProvider(workInProgress, didChange) {
                        var instance = workInProgress.stateNode;
                        !instance ? invariant(false, "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                        if (didChange) {
                            var mergedContext = processChildContext(workInProgress, previousContext);
                            instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                            pop(didPerformWorkStackCursor, workInProgress);
                            pop(contextStackCursor, workInProgress);
                            push(contextStackCursor, mergedContext, workInProgress);
                            push(didPerformWorkStackCursor, didChange, workInProgress);
                        } else {
                            pop(didPerformWorkStackCursor, workInProgress);
                            push(didPerformWorkStackCursor, didChange, workInProgress);
                        }
                    }
                    function resetContext() {
                        previousContext = emptyObject;
                        contextStackCursor.current = emptyObject;
                        didPerformWorkStackCursor.current = false;
                    }
                    function findCurrentUnmaskedContext(fiber) {
                        !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                        var node = fiber;
                        while (node.tag !== HostRoot) {
                            if (isContextProvider(node)) {
                                return node.stateNode.__reactInternalMemoizedMergedChildContext;
                            }
                            var parent = node["return"];
                            !parent ? invariant(false, "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            node = parent;
                        }
                        return node.stateNode.context;
                    }
                    var NoWork = 0;
                    var Sync = 1;
                    var Never = 2147483647;
                    var UNIT_SIZE = 10;
                    var MAGIC_NUMBER_OFFSET = 2;
                    function msToExpirationTime(ms) {
                        return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
                    }
                    function expirationTimeToMs(expirationTime) {
                        return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
                    }
                    function ceiling(num, precision) {
                        return ((num / precision | 0) + 1) * precision;
                    }
                    function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
                        return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
                    }
                    var NoContext = 0;
                    var AsyncUpdates = 1;
                    {
                        var hasBadMapPolyfill = false;
                        try {
                            var nonExtensibleObject = Object.preventExtensions({});
                        } catch (e) {
                            hasBadMapPolyfill = true;
                        }
                    }
                    {
                        var debugCounter = 1;
                    }
                    function FiberNode(tag, key, internalContextTag) {
                        this.tag = tag;
                        this.key = key;
                        this.type = null;
                        this.stateNode = null;
                        this["return"] = null;
                        this.child = null;
                        this.sibling = null;
                        this.index = 0;
                        this.ref = null;
                        this.pendingProps = null;
                        this.memoizedProps = null;
                        this.updateQueue = null;
                        this.memoizedState = null;
                        this.internalContextTag = internalContextTag;
                        this.effectTag = NoEffect;
                        this.nextEffect = null;
                        this.firstEffect = null;
                        this.lastEffect = null;
                        this.expirationTime = NoWork;
                        this.alternate = null;
                        {
                            this._debugID = debugCounter++;
                            this._debugSource = null;
                            this._debugOwner = null;
                            this._debugIsCurrentlyTiming = false;
                            if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                                Object.preventExtensions(this);
                            }
                        }
                    }
                    var createFiber = function(tag, key, internalContextTag) {
                        return new FiberNode(tag, key, internalContextTag);
                    };
                    function shouldConstruct(Component) {
                        return !!(Component.prototype && Component.prototype.isReactComponent);
                    }
                    function createWorkInProgress(current, pendingProps, expirationTime) {
                        var workInProgress = current.alternate;
                        if (workInProgress === null) {
                            workInProgress = createFiber(current.tag, current.key, current.internalContextTag);
                            workInProgress.type = current.type;
                            workInProgress.stateNode = current.stateNode;
                            {
                                workInProgress._debugID = current._debugID;
                                workInProgress._debugSource = current._debugSource;
                                workInProgress._debugOwner = current._debugOwner;
                            }
                            workInProgress.alternate = current;
                            current.alternate = workInProgress;
                        } else {
                            workInProgress.effectTag = NoEffect;
                            workInProgress.nextEffect = null;
                            workInProgress.firstEffect = null;
                            workInProgress.lastEffect = null;
                        }
                        workInProgress.expirationTime = expirationTime;
                        workInProgress.pendingProps = pendingProps;
                        workInProgress.child = current.child;
                        workInProgress.memoizedProps = current.memoizedProps;
                        workInProgress.memoizedState = current.memoizedState;
                        workInProgress.updateQueue = current.updateQueue;
                        workInProgress.sibling = current.sibling;
                        workInProgress.index = current.index;
                        workInProgress.ref = current.ref;
                        return workInProgress;
                    }
                    function createHostRootFiber() {
                        var fiber = createFiber(HostRoot, null, NoContext);
                        return fiber;
                    }
                    function createFiberFromElement(element, internalContextTag, expirationTime) {
                        var owner = null;
                        {
                            owner = element._owner;
                        }
                        var fiber = void 0;
                        var type = element.type, key = element.key;
                        if (typeof type === "function") {
                            fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);
                            fiber.type = type;
                            fiber.pendingProps = element.props;
                        } else if (typeof type === "string") {
                            fiber = createFiber(HostComponent, key, internalContextTag);
                            fiber.type = type;
                            fiber.pendingProps = element.props;
                        } else if (typeof type === "object" && type !== null && typeof type.tag === "number") {
                            fiber = type;
                            fiber.pendingProps = element.props;
                        } else {
                            var info = "";
                            {
                                if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                                    info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and named imports.";
                                }
                                var ownerName = owner ? getComponentName(owner) : null;
                                if (ownerName) {
                                    info += "\n\nCheck the render method of `" + ownerName + "`.";
                                }
                            }
                            invariant(false, "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", type == null ? type : typeof type, info);
                        }
                        {
                            fiber._debugSource = element._source;
                            fiber._debugOwner = element._owner;
                        }
                        fiber.expirationTime = expirationTime;
                        return fiber;
                    }
                    function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
                        var fiber = createFiber(Fragment, key, internalContextTag);
                        fiber.pendingProps = elements;
                        fiber.expirationTime = expirationTime;
                        return fiber;
                    }
                    function createFiberFromText(content, internalContextTag, expirationTime) {
                        var fiber = createFiber(HostText, null, internalContextTag);
                        fiber.pendingProps = content;
                        fiber.expirationTime = expirationTime;
                        return fiber;
                    }
                    function createFiberFromHostInstanceForDeletion() {
                        var fiber = createFiber(HostComponent, null, NoContext);
                        fiber.type = "DELETED";
                        return fiber;
                    }
                    function createFiberFromCall(call, internalContextTag, expirationTime) {
                        var fiber = createFiber(CallComponent, call.key, internalContextTag);
                        fiber.type = call.handler;
                        fiber.pendingProps = call;
                        fiber.expirationTime = expirationTime;
                        return fiber;
                    }
                    function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
                        var fiber = createFiber(ReturnComponent, null, internalContextTag);
                        fiber.expirationTime = expirationTime;
                        return fiber;
                    }
                    function createFiberFromPortal(portal, internalContextTag, expirationTime) {
                        var fiber = createFiber(HostPortal, portal.key, internalContextTag);
                        fiber.pendingProps = portal.children || [];
                        fiber.expirationTime = expirationTime;
                        fiber.stateNode = {
                            containerInfo: portal.containerInfo,
                            pendingChildren: null,
                            implementation: portal.implementation
                        };
                        return fiber;
                    }
                    function createFiberRoot(containerInfo, hydrate) {
                        var uninitializedFiber = createHostRootFiber();
                        var root = {
                            current: uninitializedFiber,
                            containerInfo: containerInfo,
                            pendingChildren: null,
                            remainingExpirationTime: NoWork,
                            isReadyForCommit: false,
                            finishedWork: null,
                            context: null,
                            pendingContext: null,
                            hydrate: hydrate,
                            nextScheduledRoot: null
                        };
                        uninitializedFiber.stateNode = root;
                        return root;
                    }
                    var onCommitFiberRoot = null;
                    var onCommitFiberUnmount = null;
                    var hasLoggedError = false;
                    function catchErrors(fn) {
                        return function(arg) {
                            try {
                                return fn(arg);
                            } catch (err) {
                                if (true && !hasLoggedError) {
                                    hasLoggedError = true;
                                    warning(false, "React DevTools encountered an error: %s", err);
                                }
                            }
                        };
                    }
                    function injectInternals(internals) {
                        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
                            return false;
                        }
                        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                        if (hook.isDisabled) {
                            return true;
                        }
                        if (!hook.supportsFiber) {
                            {
                                warning(false, "The installed version of React DevTools is too old and will not work " + "with the current version of React. Please update React DevTools. " + "https://fb.me/react-devtools");
                            }
                            return true;
                        }
                        try {
                            var rendererID = hook.inject(internals);
                            onCommitFiberRoot = catchErrors(function(root) {
                                return hook.onCommitFiberRoot(rendererID, root);
                            });
                            onCommitFiberUnmount = catchErrors(function(fiber) {
                                return hook.onCommitFiberUnmount(rendererID, fiber);
                            });
                        } catch (err) {
                            {
                                warning(false, "React DevTools encountered an error: %s.", err);
                            }
                        }
                        return true;
                    }
                    function onCommitRoot(root) {
                        if (typeof onCommitFiberRoot === "function") {
                            onCommitFiberRoot(root);
                        }
                    }
                    function onCommitUnmount(fiber) {
                        if (typeof onCommitFiberUnmount === "function") {
                            onCommitFiberUnmount(fiber);
                        }
                    }
                    {
                        var didWarnUpdateInsideUpdate = false;
                    }
                    function createUpdateQueue(baseState) {
                        var queue = {
                            baseState: baseState,
                            expirationTime: NoWork,
                            first: null,
                            last: null,
                            callbackList: null,
                            hasForceUpdate: false,
                            isInitialized: false
                        };
                        {
                            queue.isProcessing = false;
                        }
                        return queue;
                    }
                    function insertUpdateIntoQueue(queue, update) {
                        if (queue.last === null) {
                            queue.first = queue.last = update;
                        } else {
                            queue.last.next = update;
                            queue.last = update;
                        }
                        if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {
                            queue.expirationTime = update.expirationTime;
                        }
                    }
                    function insertUpdateIntoFiber(fiber, update) {
                        var alternateFiber = fiber.alternate;
                        var queue1 = fiber.updateQueue;
                        if (queue1 === null) {
                            queue1 = fiber.updateQueue = createUpdateQueue(null);
                        }
                        var queue2 = void 0;
                        if (alternateFiber !== null) {
                            queue2 = alternateFiber.updateQueue;
                            if (queue2 === null) {
                                queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
                            }
                        } else {
                            queue2 = null;
                        }
                        queue2 = queue2 !== queue1 ? queue2 : null;
                        {
                            if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {
                                warning(false, "An update (setState, replaceState, or forceUpdate) was scheduled " + "from inside an update function. Update functions should be pure, " + "with zero side-effects. Consider using componentDidUpdate or a " + "callback.");
                                didWarnUpdateInsideUpdate = true;
                            }
                        }
                        if (queue2 === null) {
                            insertUpdateIntoQueue(queue1, update);
                            return;
                        }
                        if (queue1.last === null || queue2.last === null) {
                            insertUpdateIntoQueue(queue1, update);
                            insertUpdateIntoQueue(queue2, update);
                            return;
                        }
                        insertUpdateIntoQueue(queue1, update);
                        queue2.last = update;
                    }
                    function getUpdateExpirationTime(fiber) {
                        if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
                            return NoWork;
                        }
                        var updateQueue = fiber.updateQueue;
                        if (updateQueue === null) {
                            return NoWork;
                        }
                        return updateQueue.expirationTime;
                    }
                    function getStateFromUpdate(update, instance, prevState, props) {
                        var partialState = update.partialState;
                        if (typeof partialState === "function") {
                            var updateFn = partialState;
                            if (debugRenderPhaseSideEffects) {
                                updateFn.call(instance, prevState, props);
                            }
                            return updateFn.call(instance, prevState, props);
                        } else {
                            return partialState;
                        }
                    }
                    function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
                        if (current !== null && current.updateQueue === queue) {
                            var currentQueue = queue;
                            queue = workInProgress.updateQueue = {
                                baseState: currentQueue.baseState,
                                expirationTime: currentQueue.expirationTime,
                                first: currentQueue.first,
                                last: currentQueue.last,
                                isInitialized: currentQueue.isInitialized,
                                callbackList: null,
                                hasForceUpdate: false
                            };
                        }
                        {
                            queue.isProcessing = true;
                        }
                        queue.expirationTime = NoWork;
                        var state = void 0;
                        if (queue.isInitialized) {
                            state = queue.baseState;
                        } else {
                            state = queue.baseState = workInProgress.memoizedState;
                            queue.isInitialized = true;
                        }
                        var dontMutatePrevState = true;
                        var update = queue.first;
                        var didSkip = false;
                        while (update !== null) {
                            var updateExpirationTime = update.expirationTime;
                            if (updateExpirationTime > renderExpirationTime) {
                                var remainingExpirationTime = queue.expirationTime;
                                if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {
                                    queue.expirationTime = updateExpirationTime;
                                }
                                if (!didSkip) {
                                    didSkip = true;
                                    queue.baseState = state;
                                }
                                update = update.next;
                                continue;
                            }
                            if (!didSkip) {
                                queue.first = update.next;
                                if (queue.first === null) {
                                    queue.last = null;
                                }
                            }
                            var _partialState = void 0;
                            if (update.isReplace) {
                                state = getStateFromUpdate(update, instance, state, props);
                                dontMutatePrevState = true;
                            } else {
                                _partialState = getStateFromUpdate(update, instance, state, props);
                                if (_partialState) {
                                    if (dontMutatePrevState) {
                                        state = _assign({}, state, _partialState);
                                    } else {
                                        state = _assign(state, _partialState);
                                    }
                                    dontMutatePrevState = false;
                                }
                            }
                            if (update.isForced) {
                                queue.hasForceUpdate = true;
                            }
                            if (update.callback !== null) {
                                var _callbackList = queue.callbackList;
                                if (_callbackList === null) {
                                    _callbackList = queue.callbackList = [];
                                }
                                _callbackList.push(update);
                            }
                            update = update.next;
                        }
                        if (queue.callbackList !== null) {
                            workInProgress.effectTag |= Callback;
                        } else if (queue.first === null && !queue.hasForceUpdate) {
                            workInProgress.updateQueue = null;
                        }
                        if (!didSkip) {
                            didSkip = true;
                            queue.baseState = state;
                        }
                        {
                            queue.isProcessing = false;
                        }
                        return state;
                    }
                    function commitCallbacks(queue, context) {
                        var callbackList = queue.callbackList;
                        if (callbackList === null) {
                            return;
                        }
                        queue.callbackList = null;
                        for (var i = 0; i < callbackList.length; i++) {
                            var update = callbackList[i];
                            var _callback = update.callback;
                            update.callback = null;
                            !(typeof _callback === "function") ? invariant(false, "Invalid argument passed as callback. Expected a function. Instead received: %s", _callback) : void 0;
                            _callback.call(context);
                        }
                    }
                    var fakeInternalInstance = {};
                    var isArray = Array.isArray;
                    {
                        var didWarnAboutStateAssignmentForComponent = {};
                        var warnOnInvalidCallback = function(callback, callerName) {
                            warning(callback === null || typeof callback === "function", "%s(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callerName, callback);
                        };
                        Object.defineProperty(fakeInternalInstance, "_processChildContext", {
                            enumerable: false,
                            value: function() {
                                invariant(false, "_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
                            }
                        });
                        Object.freeze(fakeInternalInstance);
                    }
                    var ReactFiberClassComponent = function(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
                        var updater = {
                            isMounted: isMounted,
                            enqueueSetState: function(instance, partialState, callback) {
                                var fiber = get(instance);
                                callback = callback === undefined ? null : callback;
                                {
                                    warnOnInvalidCallback(callback, "setState");
                                }
                                var expirationTime = computeExpirationForFiber(fiber);
                                var update = {
                                    expirationTime: expirationTime,
                                    partialState: partialState,
                                    callback: callback,
                                    isReplace: false,
                                    isForced: false,
                                    nextCallback: null,
                                    next: null
                                };
                                insertUpdateIntoFiber(fiber, update);
                                scheduleWork(fiber, expirationTime);
                            },
                            enqueueReplaceState: function(instance, state, callback) {
                                var fiber = get(instance);
                                callback = callback === undefined ? null : callback;
                                {
                                    warnOnInvalidCallback(callback, "replaceState");
                                }
                                var expirationTime = computeExpirationForFiber(fiber);
                                var update = {
                                    expirationTime: expirationTime,
                                    partialState: state,
                                    callback: callback,
                                    isReplace: true,
                                    isForced: false,
                                    nextCallback: null,
                                    next: null
                                };
                                insertUpdateIntoFiber(fiber, update);
                                scheduleWork(fiber, expirationTime);
                            },
                            enqueueForceUpdate: function(instance, callback) {
                                var fiber = get(instance);
                                callback = callback === undefined ? null : callback;
                                {
                                    warnOnInvalidCallback(callback, "forceUpdate");
                                }
                                var expirationTime = computeExpirationForFiber(fiber);
                                var update = {
                                    expirationTime: expirationTime,
                                    partialState: null,
                                    callback: callback,
                                    isReplace: false,
                                    isForced: true,
                                    nextCallback: null,
                                    next: null
                                };
                                insertUpdateIntoFiber(fiber, update);
                                scheduleWork(fiber, expirationTime);
                            }
                        };
                        function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {
                            if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {
                                return true;
                            }
                            var instance = workInProgress.stateNode;
                            var type = workInProgress.type;
                            if (typeof instance.shouldComponentUpdate === "function") {
                                startPhaseTimer(workInProgress, "shouldComponentUpdate");
                                var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
                                stopPhaseTimer();
                                if (debugRenderPhaseSideEffects) {
                                    instance.shouldComponentUpdate(newProps, newState, newContext);
                                }
                                {
                                    warning(shouldUpdate !== undefined, "%s.shouldComponentUpdate(): Returned undefined instead of a " + "boolean value. Make sure to return true or false.", getComponentName(workInProgress) || "Unknown");
                                }
                                return shouldUpdate;
                            }
                            if (type.prototype && type.prototype.isPureReactComponent) {
                                return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
                            }
                            return true;
                        }
                        function checkClassInstance(workInProgress) {
                            var instance = workInProgress.stateNode;
                            var type = workInProgress.type;
                            {
                                var name = getComponentName(workInProgress);
                                var renderPresent = instance.render;
                                if (!renderPresent) {
                                    if (type.prototype && typeof type.prototype.render === "function") {
                                        warning(false, "%s(...): No `render` method found on the returned component " + "instance: did you accidentally return an object from the constructor?", name);
                                    } else {
                                        warning(false, "%s(...): No `render` method found on the returned component " + "instance: you may have forgotten to define `render`.", name);
                                    }
                                }
                                var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
                                warning(noGetInitialStateOnES6, "getInitialState was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Did you mean to define a state property instead?", name);
                                var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
                                warning(noGetDefaultPropsOnES6, "getDefaultProps was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Use a static property to define defaultProps instead.", name);
                                var noInstancePropTypes = !instance.propTypes;
                                warning(noInstancePropTypes, "propTypes was defined as an instance property on %s. Use a static " + "property to define propTypes instead.", name);
                                var noInstanceContextTypes = !instance.contextTypes;
                                warning(noInstanceContextTypes, "contextTypes was defined as an instance property on %s. Use a static " + "property to define contextTypes instead.", name);
                                var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== "function";
                                warning(noComponentShouldUpdate, "%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", name);
                                if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                                    warning(false, "%s has a method called shouldComponentUpdate(). " + "shouldComponentUpdate should not be used when extending React.PureComponent. " + "Please extend React.Component if shouldComponentUpdate is used.", getComponentName(workInProgress) || "A pure component");
                                }
                                var noComponentDidUnmount = typeof instance.componentDidUnmount !== "function";
                                warning(noComponentDidUnmount, "%s has a method called " + "componentDidUnmount(). But there is no such lifecycle method. " + "Did you mean componentWillUnmount()?", name);
                                var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== "function";
                                warning(noComponentDidReceiveProps, "%s has a method called " + "componentDidReceiveProps(). But there is no such lifecycle method. " + "If you meant to update the state in response to changing props, " + "use componentWillReceiveProps(). If you meant to fetch data or " + "run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
                                var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== "function";
                                warning(noComponentWillRecieveProps, "%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
                                var hasMutatedProps = instance.props !== workInProgress.pendingProps;
                                warning(instance.props === undefined || !hasMutatedProps, "%s(...): When calling super() in `%s`, make sure to pass " + "up the same props that your component's constructor was passed.", name, name);
                                var noInstanceDefaultProps = !instance.defaultProps;
                                warning(noInstanceDefaultProps, "Setting defaultProps as an instance property on %s is not supported and will be ignored." + " Instead, define defaultProps as a static property on %s.", name, name);
                            }
                            var state = instance.state;
                            if (state && (typeof state !== "object" || isArray(state))) {
                                warning(false, "%s.state: must be set to an object or null", getComponentName(workInProgress));
                            }
                            if (typeof instance.getChildContext === "function") {
                                warning(typeof workInProgress.type.childContextTypes === "object", "%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", getComponentName(workInProgress));
                            }
                        }
                        function resetInputPointers(workInProgress, instance) {
                            instance.props = workInProgress.memoizedProps;
                            instance.state = workInProgress.memoizedState;
                        }
                        function adoptClassInstance(workInProgress, instance) {
                            instance.updater = updater;
                            workInProgress.stateNode = instance;
                            set(instance, workInProgress);
                            {
                                instance._reactInternalInstance = fakeInternalInstance;
                            }
                        }
                        function constructClassInstance(workInProgress, props) {
                            var ctor = workInProgress.type;
                            var unmaskedContext = getUnmaskedContext(workInProgress);
                            var needsContext = isContextConsumer(workInProgress);
                            var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
                            var instance = new ctor(props, context);
                            adoptClassInstance(workInProgress, instance);
                            if (needsContext) {
                                cacheContext(workInProgress, unmaskedContext, context);
                            }
                            return instance;
                        }
                        function callComponentWillMount(workInProgress, instance) {
                            startPhaseTimer(workInProgress, "componentWillMount");
                            var oldState = instance.state;
                            instance.componentWillMount();
                            stopPhaseTimer();
                            if (debugRenderPhaseSideEffects) {
                                instance.componentWillMount();
                            }
                            if (oldState !== instance.state) {
                                {
                                    warning(false, "%s.componentWillMount(): Assigning directly to this.state is " + "deprecated (except inside a component's " + "constructor). Use setState instead.", getComponentName(workInProgress));
                                }
                                updater.enqueueReplaceState(instance, instance.state, null);
                            }
                        }
                        function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {
                            startPhaseTimer(workInProgress, "componentWillReceiveProps");
                            var oldState = instance.state;
                            instance.componentWillReceiveProps(newProps, newContext);
                            stopPhaseTimer();
                            if (debugRenderPhaseSideEffects) {
                                instance.componentWillReceiveProps(newProps, newContext);
                            }
                            if (instance.state !== oldState) {
                                {
                                    var componentName = getComponentName(workInProgress) || "Component";
                                    if (!didWarnAboutStateAssignmentForComponent[componentName]) {
                                        warning(false, "%s.componentWillReceiveProps(): Assigning directly to " + "this.state is deprecated (except inside a component's " + "constructor). Use setState instead.", componentName);
                                        didWarnAboutStateAssignmentForComponent[componentName] = true;
                                    }
                                }
                                updater.enqueueReplaceState(instance, instance.state, null);
                            }
                        }
                        function mountClassInstance(workInProgress, renderExpirationTime) {
                            var current = workInProgress.alternate;
                            {
                                checkClassInstance(workInProgress);
                            }
                            var instance = workInProgress.stateNode;
                            var state = instance.state || null;
                            var props = workInProgress.pendingProps;
                            !props ? invariant(false, "There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            var unmaskedContext = getUnmaskedContext(workInProgress);
                            instance.props = props;
                            instance.state = workInProgress.memoizedState = state;
                            instance.refs = emptyObject;
                            instance.context = getMaskedContext(workInProgress, unmaskedContext);
                            if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {
                                workInProgress.internalContextTag |= AsyncUpdates;
                            }
                            if (typeof instance.componentWillMount === "function") {
                                callComponentWillMount(workInProgress, instance);
                                var updateQueue = workInProgress.updateQueue;
                                if (updateQueue !== null) {
                                    instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);
                                }
                            }
                            if (typeof instance.componentDidMount === "function") {
                                workInProgress.effectTag |= Update;
                            }
                        }
                        function updateClassInstance(current, workInProgress, renderExpirationTime) {
                            var instance = workInProgress.stateNode;
                            resetInputPointers(workInProgress, instance);
                            var oldProps = workInProgress.memoizedProps;
                            var newProps = workInProgress.pendingProps;
                            if (!newProps) {
                                newProps = oldProps;
                                !(newProps != null) ? invariant(false, "There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            }
                            var oldContext = instance.context;
                            var newUnmaskedContext = getUnmaskedContext(workInProgress);
                            var newContext = getMaskedContext(workInProgress, newUnmaskedContext);
                            if (typeof instance.componentWillReceiveProps === "function" && (oldProps !== newProps || oldContext !== newContext)) {
                                callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);
                            }
                            var oldState = workInProgress.memoizedState;
                            var newState = void 0;
                            if (workInProgress.updateQueue !== null) {
                                newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);
                            } else {
                                newState = oldState;
                            }
                            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {
                                if (typeof instance.componentDidUpdate === "function") {
                                    if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                                        workInProgress.effectTag |= Update;
                                    }
                                }
                                return false;
                            }
                            var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);
                            if (shouldUpdate) {
                                if (typeof instance.componentWillUpdate === "function") {
                                    startPhaseTimer(workInProgress, "componentWillUpdate");
                                    instance.componentWillUpdate(newProps, newState, newContext);
                                    stopPhaseTimer();
                                    if (debugRenderPhaseSideEffects) {
                                        instance.componentWillUpdate(newProps, newState, newContext);
                                    }
                                }
                                if (typeof instance.componentDidUpdate === "function") {
                                    workInProgress.effectTag |= Update;
                                }
                            } else {
                                if (typeof instance.componentDidUpdate === "function") {
                                    if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                                        workInProgress.effectTag |= Update;
                                    }
                                }
                                memoizeProps(workInProgress, newProps);
                                memoizeState(workInProgress, newState);
                            }
                            instance.props = newProps;
                            instance.state = newState;
                            instance.context = newContext;
                            return shouldUpdate;
                        }
                        return {
                            adoptClassInstance: adoptClassInstance,
                            constructClassInstance: constructClassInstance,
                            mountClassInstance: mountClassInstance,
                            updateClassInstance: updateClassInstance
                        };
                    };
                    var hasSymbol = typeof Symbol === "function" && Symbol["for"];
                    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol["for"]("react.element") : 60103;
                    var REACT_CALL_TYPE = hasSymbol ? Symbol["for"]("react.call") : 60104;
                    var REACT_RETURN_TYPE = hasSymbol ? Symbol["for"]("react.return") : 60105;
                    var REACT_PORTAL_TYPE = hasSymbol ? Symbol["for"]("react.portal") : 60106;
                    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol["for"]("react.fragment") : 60107;
                    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
                    var FAUX_ITERATOR_SYMBOL = "@@iterator";
                    function getIteratorFn(maybeIterable) {
                        if (maybeIterable === null || typeof maybeIterable === "undefined") {
                            return null;
                        }
                        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
                        if (typeof maybeIterator === "function") {
                            return maybeIterator;
                        }
                        return null;
                    }
                    var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
                    {
                        var didWarnAboutMaps = false;
                        var ownerHasKeyUseWarning = {};
                        var ownerHasFunctionTypeWarning = {};
                        var warnForMissingKey = function(child) {
                            if (child === null || typeof child !== "object") {
                                return;
                            }
                            if (!child._store || child._store.validated || child.key != null) {
                                return;
                            }
                            !(typeof child._store === "object") ? invariant(false, "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            child._store.validated = true;
                            var currentComponentErrorInfo = "Each child in an array or iterator should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information." + (getCurrentFiberStackAddendum$1() || "");
                            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                                return;
                            }
                            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
                            warning(false, "Each child in an array or iterator should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information.%s", getCurrentFiberStackAddendum$1());
                        };
                    }
                    var isArray$1 = Array.isArray;
                    function coerceRef(current, element) {
                        var mixedRef = element.ref;
                        if (mixedRef !== null && typeof mixedRef !== "function") {
                            if (element._owner) {
                                var owner = element._owner;
                                var inst = void 0;
                                if (owner) {
                                    var ownerFiber = owner;
                                    !(ownerFiber.tag === ClassComponent) ? invariant(false, "Stateless function components cannot have refs.") : void 0;
                                    inst = ownerFiber.stateNode;
                                }
                                !inst ? invariant(false, "Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.", mixedRef) : void 0;
                                var stringRef = "" + mixedRef;
                                if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {
                                    return current.ref;
                                }
                                var ref = function(value) {
                                    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
                                    if (value === null) {
                                        delete refs[stringRef];
                                    } else {
                                        refs[stringRef] = value;
                                    }
                                };
                                ref._stringRef = stringRef;
                                return ref;
                            } else {
                                !(typeof mixedRef === "string") ? invariant(false, "Expected ref to be a function or a string.") : void 0;
                                !element._owner ? invariant(false, "Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).", mixedRef) : void 0;
                            }
                        }
                        return mixedRef;
                    }
                    function throwOnInvalidObjectType(returnFiber, newChild) {
                        if (returnFiber.type !== "textarea") {
                            var addendum = "";
                            {
                                addendum = " If you meant to render a collection of children, use an array " + "instead." + (getCurrentFiberStackAddendum$1() || "");
                            }
                            invariant(false, "Objects are not valid as a React child (found: %s).%s", Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild, addendum);
                        }
                    }
                    function warnOnFunctionType() {
                        var currentComponentErrorInfo = "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it." + (getCurrentFiberStackAddendum$1() || "");
                        if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
                            return;
                        }
                        ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
                        warning(false, "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it.%s", getCurrentFiberStackAddendum$1() || "");
                    }
                    function ChildReconciler(shouldTrackSideEffects) {
                        function deleteChild(returnFiber, childToDelete) {
                            if (!shouldTrackSideEffects) {
                                return;
                            }
                            var last = returnFiber.lastEffect;
                            if (last !== null) {
                                last.nextEffect = childToDelete;
                                returnFiber.lastEffect = childToDelete;
                            } else {
                                returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
                            }
                            childToDelete.nextEffect = null;
                            childToDelete.effectTag = Deletion;
                        }
                        function deleteRemainingChildren(returnFiber, currentFirstChild) {
                            if (!shouldTrackSideEffects) {
                                return null;
                            }
                            var childToDelete = currentFirstChild;
                            while (childToDelete !== null) {
                                deleteChild(returnFiber, childToDelete);
                                childToDelete = childToDelete.sibling;
                            }
                            return null;
                        }
                        function mapRemainingChildren(returnFiber, currentFirstChild) {
                            var existingChildren = new Map();
                            var existingChild = currentFirstChild;
                            while (existingChild !== null) {
                                if (existingChild.key !== null) {
                                    existingChildren.set(existingChild.key, existingChild);
                                } else {
                                    existingChildren.set(existingChild.index, existingChild);
                                }
                                existingChild = existingChild.sibling;
                            }
                            return existingChildren;
                        }
                        function useFiber(fiber, pendingProps, expirationTime) {
                            var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
                            clone.index = 0;
                            clone.sibling = null;
                            return clone;
                        }
                        function placeChild(newFiber, lastPlacedIndex, newIndex) {
                            newFiber.index = newIndex;
                            if (!shouldTrackSideEffects) {
                                return lastPlacedIndex;
                            }
                            var current = newFiber.alternate;
                            if (current !== null) {
                                var oldIndex = current.index;
                                if (oldIndex < lastPlacedIndex) {
                                    newFiber.effectTag = Placement;
                                    return lastPlacedIndex;
                                } else {
                                    return oldIndex;
                                }
                            } else {
                                newFiber.effectTag = Placement;
                                return lastPlacedIndex;
                            }
                        }
                        function placeSingleChild(newFiber) {
                            if (shouldTrackSideEffects && newFiber.alternate === null) {
                                newFiber.effectTag = Placement;
                            }
                            return newFiber;
                        }
                        function updateTextNode(returnFiber, current, textContent, expirationTime) {
                            if (current === null || current.tag !== HostText) {
                                var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
                                created["return"] = returnFiber;
                                return created;
                            } else {
                                var existing = useFiber(current, textContent, expirationTime);
                                existing["return"] = returnFiber;
                                return existing;
                            }
                        }
                        function updateElement(returnFiber, current, element, expirationTime) {
                            if (current !== null && current.type === element.type) {
                                var existing = useFiber(current, element.props, expirationTime);
                                existing.ref = coerceRef(current, element);
                                existing["return"] = returnFiber;
                                {
                                    existing._debugSource = element._source;
                                    existing._debugOwner = element._owner;
                                }
                                return existing;
                            } else {
                                var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
                                created.ref = coerceRef(current, element);
                                created["return"] = returnFiber;
                                return created;
                            }
                        }
                        function updateCall(returnFiber, current, call, expirationTime) {
                            if (current === null || current.tag !== CallComponent) {
                                var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
                                created["return"] = returnFiber;
                                return created;
                            } else {
                                var existing = useFiber(current, call, expirationTime);
                                existing["return"] = returnFiber;
                                return existing;
                            }
                        }
                        function updateReturn(returnFiber, current, returnNode, expirationTime) {
                            if (current === null || current.tag !== ReturnComponent) {
                                var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
                                created.type = returnNode.value;
                                created["return"] = returnFiber;
                                return created;
                            } else {
                                var existing = useFiber(current, null, expirationTime);
                                existing.type = returnNode.value;
                                existing["return"] = returnFiber;
                                return existing;
                            }
                        }
                        function updatePortal(returnFiber, current, portal, expirationTime) {
                            if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
                                var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
                                created["return"] = returnFiber;
                                return created;
                            } else {
                                var existing = useFiber(current, portal.children || [], expirationTime);
                                existing["return"] = returnFiber;
                                return existing;
                            }
                        }
                        function updateFragment(returnFiber, current, fragment, expirationTime, key) {
                            if (current === null || current.tag !== Fragment) {
                                var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);
                                created["return"] = returnFiber;
                                return created;
                            } else {
                                var existing = useFiber(current, fragment, expirationTime);
                                existing["return"] = returnFiber;
                                return existing;
                            }
                        }
                        function createChild(returnFiber, newChild, expirationTime) {
                            if (typeof newChild === "string" || typeof newChild === "number") {
                                var created = createFiberFromText("" + newChild, returnFiber.internalContextTag, expirationTime);
                                created["return"] = returnFiber;
                                return created;
                            }
                            if (typeof newChild === "object" && newChild !== null) {
                                switch (newChild.$$typeof) {
                                  case REACT_ELEMENT_TYPE:
                                    {
                                        if (newChild.type === REACT_FRAGMENT_TYPE) {
                                            var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);
                                            _created["return"] = returnFiber;
                                            return _created;
                                        } else {
                                            var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);
                                            _created2.ref = coerceRef(null, newChild);
                                            _created2["return"] = returnFiber;
                                            return _created2;
                                        }
                                    }

                                  case REACT_CALL_TYPE:
                                    {
                                        var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);
                                        _created3["return"] = returnFiber;
                                        return _created3;
                                    }

                                  case REACT_RETURN_TYPE:
                                    {
                                        var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);
                                        _created4.type = newChild.value;
                                        _created4["return"] = returnFiber;
                                        return _created4;
                                    }

                                  case REACT_PORTAL_TYPE:
                                    {
                                        var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);
                                        _created5["return"] = returnFiber;
                                        return _created5;
                                    }
                                }
                                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                                    var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);
                                    _created6["return"] = returnFiber;
                                    return _created6;
                                }
                                throwOnInvalidObjectType(returnFiber, newChild);
                            }
                            {
                                if (typeof newChild === "function") {
                                    warnOnFunctionType();
                                }
                            }
                            return null;
                        }
                        function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
                            var key = oldFiber !== null ? oldFiber.key : null;
                            if (typeof newChild === "string" || typeof newChild === "number") {
                                if (key !== null) {
                                    return null;
                                }
                                return updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);
                            }
                            if (typeof newChild === "object" && newChild !== null) {
                                switch (newChild.$$typeof) {
                                  case REACT_ELEMENT_TYPE:
                                    {
                                        if (newChild.key === key) {
                                            if (newChild.type === REACT_FRAGMENT_TYPE) {
                                                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
                                            }
                                            return updateElement(returnFiber, oldFiber, newChild, expirationTime);
                                        } else {
                                            return null;
                                        }
                                    }

                                  case REACT_CALL_TYPE:
                                    {
                                        if (newChild.key === key) {
                                            return updateCall(returnFiber, oldFiber, newChild, expirationTime);
                                        } else {
                                            return null;
                                        }
                                    }

                                  case REACT_RETURN_TYPE:
                                    {
                                        if (key === null) {
                                            return updateReturn(returnFiber, oldFiber, newChild, expirationTime);
                                        } else {
                                            return null;
                                        }
                                    }

                                  case REACT_PORTAL_TYPE:
                                    {
                                        if (newChild.key === key) {
                                            return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
                                        } else {
                                            return null;
                                        }
                                    }
                                }
                                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                                    if (key !== null) {
                                        return null;
                                    }
                                    return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
                                }
                                throwOnInvalidObjectType(returnFiber, newChild);
                            }
                            {
                                if (typeof newChild === "function") {
                                    warnOnFunctionType();
                                }
                            }
                            return null;
                        }
                        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
                            if (typeof newChild === "string" || typeof newChild === "number") {
                                var matchedFiber = existingChildren.get(newIdx) || null;
                                return updateTextNode(returnFiber, matchedFiber, "" + newChild, expirationTime);
                            }
                            if (typeof newChild === "object" && newChild !== null) {
                                switch (newChild.$$typeof) {
                                  case REACT_ELEMENT_TYPE:
                                    {
                                        var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                                        if (newChild.type === REACT_FRAGMENT_TYPE) {
                                            return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
                                        }
                                        return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
                                    }

                                  case REACT_CALL_TYPE:
                                    {
                                        var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                                        return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);
                                    }

                                  case REACT_RETURN_TYPE:
                                    {
                                        var _matchedFiber3 = existingChildren.get(newIdx) || null;
                                        return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);
                                    }

                                  case REACT_PORTAL_TYPE:
                                    {
                                        var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                                        return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);
                                    }
                                }
                                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                                    var _matchedFiber5 = existingChildren.get(newIdx) || null;
                                    return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);
                                }
                                throwOnInvalidObjectType(returnFiber, newChild);
                            }
                            {
                                if (typeof newChild === "function") {
                                    warnOnFunctionType();
                                }
                            }
                            return null;
                        }
                        function warnOnInvalidKey(child, knownKeys) {
                            {
                                if (typeof child !== "object" || child === null) {
                                    return knownKeys;
                                }
                                switch (child.$$typeof) {
                                  case REACT_ELEMENT_TYPE:
                                  case REACT_CALL_TYPE:
                                  case REACT_PORTAL_TYPE:
                                    warnForMissingKey(child);
                                    var key = child.key;
                                    if (typeof key !== "string") {
                                        break;
                                    }
                                    if (knownKeys === null) {
                                        knownKeys = new Set();
                                        knownKeys.add(key);
                                        break;
                                    }
                                    if (!knownKeys.has(key)) {
                                        knownKeys.add(key);
                                        break;
                                    }
                                    warning(false, "Encountered two children with the same key, `%s`. " + "Keys should be unique so that components maintain their identity " + "across updates. Non-unique keys may cause children to be " + "duplicated and/or omitted  the behavior is unsupported and " + "could change in a future version.%s", key, getCurrentFiberStackAddendum$1());
                                    break;

                                  default:
                                    break;
                                }
                            }
                            return knownKeys;
                        }
                        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
                            {
                                var knownKeys = null;
                                for (var i = 0; i < newChildren.length; i++) {
                                    var child = newChildren[i];
                                    knownKeys = warnOnInvalidKey(child, knownKeys);
                                }
                            }
                            var resultingFirstChild = null;
                            var previousNewFiber = null;
                            var oldFiber = currentFirstChild;
                            var lastPlacedIndex = 0;
                            var newIdx = 0;
                            var nextOldFiber = null;
                            for (;oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                                if (oldFiber.index > newIdx) {
                                    nextOldFiber = oldFiber;
                                    oldFiber = null;
                                } else {
                                    nextOldFiber = oldFiber.sibling;
                                }
                                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
                                if (newFiber === null) {
                                    if (oldFiber === null) {
                                        oldFiber = nextOldFiber;
                                    }
                                    break;
                                }
                                if (shouldTrackSideEffects) {
                                    if (oldFiber && newFiber.alternate === null) {
                                        deleteChild(returnFiber, oldFiber);
                                    }
                                }
                                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                                if (previousNewFiber === null) {
                                    resultingFirstChild = newFiber;
                                } else {
                                    previousNewFiber.sibling = newFiber;
                                }
                                previousNewFiber = newFiber;
                                oldFiber = nextOldFiber;
                            }
                            if (newIdx === newChildren.length) {
                                deleteRemainingChildren(returnFiber, oldFiber);
                                return resultingFirstChild;
                            }
                            if (oldFiber === null) {
                                for (;newIdx < newChildren.length; newIdx++) {
                                    var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
                                    if (!_newFiber) {
                                        continue;
                                    }
                                    lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                                    if (previousNewFiber === null) {
                                        resultingFirstChild = _newFiber;
                                    } else {
                                        previousNewFiber.sibling = _newFiber;
                                    }
                                    previousNewFiber = _newFiber;
                                }
                                return resultingFirstChild;
                            }
                            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
                            for (;newIdx < newChildren.length; newIdx++) {
                                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
                                if (_newFiber2) {
                                    if (shouldTrackSideEffects) {
                                        if (_newFiber2.alternate !== null) {
                                            existingChildren["delete"](_newFiber2.key === null ? newIdx : _newFiber2.key);
                                        }
                                    }
                                    lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                                    if (previousNewFiber === null) {
                                        resultingFirstChild = _newFiber2;
                                    } else {
                                        previousNewFiber.sibling = _newFiber2;
                                    }
                                    previousNewFiber = _newFiber2;
                                }
                            }
                            if (shouldTrackSideEffects) {
                                existingChildren.forEach(function(child) {
                                    return deleteChild(returnFiber, child);
                                });
                            }
                            return resultingFirstChild;
                        }
                        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
                            var iteratorFn = getIteratorFn(newChildrenIterable);
                            !(typeof iteratorFn === "function") ? invariant(false, "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            {
                                if (typeof newChildrenIterable.entries === "function") {
                                    var possibleMap = newChildrenIterable;
                                    if (possibleMap.entries === iteratorFn) {
                                        warning(didWarnAboutMaps, "Using Maps as children is unsupported and will likely yield " + "unexpected results. Convert it to a sequence/iterable of keyed " + "ReactElements instead.%s", getCurrentFiberStackAddendum$1());
                                        didWarnAboutMaps = true;
                                    }
                                }
                                var _newChildren = iteratorFn.call(newChildrenIterable);
                                if (_newChildren) {
                                    var knownKeys = null;
                                    var _step = _newChildren.next();
                                    for (;!_step.done; _step = _newChildren.next()) {
                                        var child = _step.value;
                                        knownKeys = warnOnInvalidKey(child, knownKeys);
                                    }
                                }
                            }
                            var newChildren = iteratorFn.call(newChildrenIterable);
                            !(newChildren != null) ? invariant(false, "An iterable object provided no iterator.") : void 0;
                            var resultingFirstChild = null;
                            var previousNewFiber = null;
                            var oldFiber = currentFirstChild;
                            var lastPlacedIndex = 0;
                            var newIdx = 0;
                            var nextOldFiber = null;
                            var step = newChildren.next();
                            for (;oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                                if (oldFiber.index > newIdx) {
                                    nextOldFiber = oldFiber;
                                    oldFiber = null;
                                } else {
                                    nextOldFiber = oldFiber.sibling;
                                }
                                var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
                                if (newFiber === null) {
                                    if (!oldFiber) {
                                        oldFiber = nextOldFiber;
                                    }
                                    break;
                                }
                                if (shouldTrackSideEffects) {
                                    if (oldFiber && newFiber.alternate === null) {
                                        deleteChild(returnFiber, oldFiber);
                                    }
                                }
                                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                                if (previousNewFiber === null) {
                                    resultingFirstChild = newFiber;
                                } else {
                                    previousNewFiber.sibling = newFiber;
                                }
                                previousNewFiber = newFiber;
                                oldFiber = nextOldFiber;
                            }
                            if (step.done) {
                                deleteRemainingChildren(returnFiber, oldFiber);
                                return resultingFirstChild;
                            }
                            if (oldFiber === null) {
                                for (;!step.done; newIdx++, step = newChildren.next()) {
                                    var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
                                    if (_newFiber3 === null) {
                                        continue;
                                    }
                                    lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                                    if (previousNewFiber === null) {
                                        resultingFirstChild = _newFiber3;
                                    } else {
                                        previousNewFiber.sibling = _newFiber3;
                                    }
                                    previousNewFiber = _newFiber3;
                                }
                                return resultingFirstChild;
                            }
                            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
                            for (;!step.done; newIdx++, step = newChildren.next()) {
                                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
                                if (_newFiber4 !== null) {
                                    if (shouldTrackSideEffects) {
                                        if (_newFiber4.alternate !== null) {
                                            existingChildren["delete"](_newFiber4.key === null ? newIdx : _newFiber4.key);
                                        }
                                    }
                                    lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                                    if (previousNewFiber === null) {
                                        resultingFirstChild = _newFiber4;
                                    } else {
                                        previousNewFiber.sibling = _newFiber4;
                                    }
                                    previousNewFiber = _newFiber4;
                                }
                            }
                            if (shouldTrackSideEffects) {
                                existingChildren.forEach(function(child) {
                                    return deleteChild(returnFiber, child);
                                });
                            }
                            return resultingFirstChild;
                        }
                        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
                            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                                var existing = useFiber(currentFirstChild, textContent, expirationTime);
                                existing["return"] = returnFiber;
                                return existing;
                            }
                            deleteRemainingChildren(returnFiber, currentFirstChild);
                            var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
                            created["return"] = returnFiber;
                            return created;
                        }
                        function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
                            var key = element.key;
                            var child = currentFirstChild;
                            while (child !== null) {
                                if (child.key === key) {
                                    if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
                                        deleteRemainingChildren(returnFiber, child.sibling);
                                        var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
                                        existing.ref = coerceRef(child, element);
                                        existing["return"] = returnFiber;
                                        {
                                            existing._debugSource = element._source;
                                            existing._debugOwner = element._owner;
                                        }
                                        return existing;
                                    } else {
                                        deleteRemainingChildren(returnFiber, child);
                                        break;
                                    }
                                } else {
                                    deleteChild(returnFiber, child);
                                }
                                child = child.sibling;
                            }
                            if (element.type === REACT_FRAGMENT_TYPE) {
                                var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);
                                created["return"] = returnFiber;
                                return created;
                            } else {
                                var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
                                _created7.ref = coerceRef(currentFirstChild, element);
                                _created7["return"] = returnFiber;
                                return _created7;
                            }
                        }
                        function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {
                            var key = call.key;
                            var child = currentFirstChild;
                            while (child !== null) {
                                if (child.key === key) {
                                    if (child.tag === CallComponent) {
                                        deleteRemainingChildren(returnFiber, child.sibling);
                                        var existing = useFiber(child, call, expirationTime);
                                        existing["return"] = returnFiber;
                                        return existing;
                                    } else {
                                        deleteRemainingChildren(returnFiber, child);
                                        break;
                                    }
                                } else {
                                    deleteChild(returnFiber, child);
                                }
                                child = child.sibling;
                            }
                            var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
                            created["return"] = returnFiber;
                            return created;
                        }
                        function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {
                            var child = currentFirstChild;
                            if (child !== null) {
                                if (child.tag === ReturnComponent) {
                                    deleteRemainingChildren(returnFiber, child.sibling);
                                    var existing = useFiber(child, null, expirationTime);
                                    existing.type = returnNode.value;
                                    existing["return"] = returnFiber;
                                    return existing;
                                } else {
                                    deleteRemainingChildren(returnFiber, child);
                                }
                            }
                            var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
                            created.type = returnNode.value;
                            created["return"] = returnFiber;
                            return created;
                        }
                        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
                            var key = portal.key;
                            var child = currentFirstChild;
                            while (child !== null) {
                                if (child.key === key) {
                                    if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                                        deleteRemainingChildren(returnFiber, child.sibling);
                                        var existing = useFiber(child, portal.children || [], expirationTime);
                                        existing["return"] = returnFiber;
                                        return existing;
                                    } else {
                                        deleteRemainingChildren(returnFiber, child);
                                        break;
                                    }
                                } else {
                                    deleteChild(returnFiber, child);
                                }
                                child = child.sibling;
                            }
                            var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
                            created["return"] = returnFiber;
                            return created;
                        }
                        function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
                            if (typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {
                                newChild = newChild.props.children;
                            }
                            var isObject = typeof newChild === "object" && newChild !== null;
                            if (isObject) {
                                switch (newChild.$$typeof) {
                                  case REACT_ELEMENT_TYPE:
                                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

                                  case REACT_CALL_TYPE:
                                    return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));

                                  case REACT_RETURN_TYPE:
                                    return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));

                                  case REACT_PORTAL_TYPE:
                                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
                                }
                            }
                            if (typeof newChild === "string" || typeof newChild === "number") {
                                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, expirationTime));
                            }
                            if (isArray$1(newChild)) {
                                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
                            }
                            if (getIteratorFn(newChild)) {
                                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
                            }
                            if (isObject) {
                                throwOnInvalidObjectType(returnFiber, newChild);
                            }
                            {
                                if (typeof newChild === "function") {
                                    warnOnFunctionType();
                                }
                            }
                            if (typeof newChild === "undefined") {
                                switch (returnFiber.tag) {
                                  case ClassComponent:
                                    {
                                        {
                                            var instance = returnFiber.stateNode;
                                            if (instance.render._isMockFunction) {
                                                break;
                                            }
                                        }
                                    }

                                  case FunctionalComponent:
                                    {
                                        var Component = returnFiber.type;
                                        invariant(false, "%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.", Component.displayName || Component.name || "Component");
                                    }
                                }
                            }
                            return deleteRemainingChildren(returnFiber, currentFirstChild);
                        }
                        return reconcileChildFibers;
                    }
                    var reconcileChildFibers = ChildReconciler(true);
                    var mountChildFibers = ChildReconciler(false);
                    function cloneChildFibers(current, workInProgress) {
                        !(current === null || workInProgress.child === current.child) ? invariant(false, "Resuming work not yet implemented.") : void 0;
                        if (workInProgress.child === null) {
                            return;
                        }
                        var currentChild = workInProgress.child;
                        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
                        workInProgress.child = newChild;
                        newChild["return"] = workInProgress;
                        while (currentChild.sibling !== null) {
                            currentChild = currentChild.sibling;
                            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
                            newChild["return"] = workInProgress;
                        }
                        newChild.sibling = null;
                    }
                    {
                        var warnedAboutStatelessRefs = {};
                    }
                    var ReactFiberBeginWork = function(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
                        var shouldSetTextContent = config.shouldSetTextContent, useSyncScheduling = config.useSyncScheduling, shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
                        var pushHostContext = hostContext.pushHostContext, pushHostContainer = hostContext.pushHostContainer;
                        var enterHydrationState = hydrationContext.enterHydrationState, resetHydrationState = hydrationContext.resetHydrationState, tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;
                        var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState), adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance, constructClassInstance = _ReactFiberClassCompo.constructClassInstance, mountClassInstance = _ReactFiberClassCompo.mountClassInstance, updateClassInstance = _ReactFiberClassCompo.updateClassInstance;
                        function reconcileChildren(current, workInProgress, nextChildren) {
                            reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);
                        }
                        function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {
                            if (current === null) {
                                workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
                            } else {
                                workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
                            }
                        }
                        function updateFragment(current, workInProgress) {
                            var nextChildren = workInProgress.pendingProps;
                            if (hasContextChanged()) {
                                if (nextChildren === null) {
                                    nextChildren = workInProgress.memoizedProps;
                                }
                            } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
                                return bailoutOnAlreadyFinishedWork(current, workInProgress);
                            }
                            reconcileChildren(current, workInProgress, nextChildren);
                            memoizeProps(workInProgress, nextChildren);
                            return workInProgress.child;
                        }
                        function markRef(current, workInProgress) {
                            var ref = workInProgress.ref;
                            if (ref !== null && (!current || current.ref !== ref)) {
                                workInProgress.effectTag |= Ref;
                            }
                        }
                        function updateFunctionalComponent(current, workInProgress) {
                            var fn = workInProgress.type;
                            var nextProps = workInProgress.pendingProps;
                            var memoizedProps = workInProgress.memoizedProps;
                            if (hasContextChanged()) {
                                if (nextProps === null) {
                                    nextProps = memoizedProps;
                                }
                            } else {
                                if (nextProps === null || memoizedProps === nextProps) {
                                    return bailoutOnAlreadyFinishedWork(current, workInProgress);
                                }
                            }
                            var unmaskedContext = getUnmaskedContext(workInProgress);
                            var context = getMaskedContext(workInProgress, unmaskedContext);
                            var nextChildren;
                            {
                                ReactCurrentOwner.current = workInProgress;
                                ReactDebugCurrentFiber.setCurrentPhase("render");
                                nextChildren = fn(nextProps, context);
                                ReactDebugCurrentFiber.setCurrentPhase(null);
                            }
                            workInProgress.effectTag |= PerformedWork;
                            reconcileChildren(current, workInProgress, nextChildren);
                            memoizeProps(workInProgress, nextProps);
                            return workInProgress.child;
                        }
                        function updateClassComponent(current, workInProgress, renderExpirationTime) {
                            var hasContext = pushContextProvider(workInProgress);
                            var shouldUpdate = void 0;
                            if (current === null) {
                                if (!workInProgress.stateNode) {
                                    constructClassInstance(workInProgress, workInProgress.pendingProps);
                                    mountClassInstance(workInProgress, renderExpirationTime);
                                    shouldUpdate = true;
                                } else {
                                    invariant(false, "Resuming work not yet implemented.");
                                }
                            } else {
                                shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
                            }
                            return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);
                        }
                        function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
                            markRef(current, workInProgress);
                            if (!shouldUpdate) {
                                if (hasContext) {
                                    invalidateContextProvider(workInProgress, false);
                                }
                                return bailoutOnAlreadyFinishedWork(current, workInProgress);
                            }
                            var instance = workInProgress.stateNode;
                            ReactCurrentOwner.current = workInProgress;
                            var nextChildren = void 0;
                            {
                                ReactDebugCurrentFiber.setCurrentPhase("render");
                                nextChildren = instance.render();
                                if (debugRenderPhaseSideEffects) {
                                    instance.render();
                                }
                                ReactDebugCurrentFiber.setCurrentPhase(null);
                            }
                            workInProgress.effectTag |= PerformedWork;
                            reconcileChildren(current, workInProgress, nextChildren);
                            memoizeState(workInProgress, instance.state);
                            memoizeProps(workInProgress, instance.props);
                            if (hasContext) {
                                invalidateContextProvider(workInProgress, true);
                            }
                            return workInProgress.child;
                        }
                        function pushHostRootContext(workInProgress) {
                            var root = workInProgress.stateNode;
                            if (root.pendingContext) {
                                pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
                            } else if (root.context) {
                                pushTopLevelContextObject(workInProgress, root.context, false);
                            }
                            pushHostContainer(workInProgress, root.containerInfo);
                        }
                        function updateHostRoot(current, workInProgress, renderExpirationTime) {
                            pushHostRootContext(workInProgress);
                            var updateQueue = workInProgress.updateQueue;
                            if (updateQueue !== null) {
                                var prevState = workInProgress.memoizedState;
                                var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);
                                if (prevState === state) {
                                    resetHydrationState();
                                    return bailoutOnAlreadyFinishedWork(current, workInProgress);
                                }
                                var element = state.element;
                                var root = workInProgress.stateNode;
                                if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
                                    workInProgress.effectTag |= Placement;
                                    workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);
                                } else {
                                    resetHydrationState();
                                    reconcileChildren(current, workInProgress, element);
                                }
                                memoizeState(workInProgress, state);
                                return workInProgress.child;
                            }
                            resetHydrationState();
                            return bailoutOnAlreadyFinishedWork(current, workInProgress);
                        }
                        function updateHostComponent(current, workInProgress, renderExpirationTime) {
                            pushHostContext(workInProgress);
                            if (current === null) {
                                tryToClaimNextHydratableInstance(workInProgress);
                            }
                            var type = workInProgress.type;
                            var memoizedProps = workInProgress.memoizedProps;
                            var nextProps = workInProgress.pendingProps;
                            if (nextProps === null) {
                                nextProps = memoizedProps;
                                !(nextProps !== null) ? invariant(false, "We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            }
                            var prevProps = current !== null ? current.memoizedProps : null;
                            if (hasContextChanged()) {} else if (nextProps === null || memoizedProps === nextProps) {
                                return bailoutOnAlreadyFinishedWork(current, workInProgress);
                            }
                            var nextChildren = nextProps.children;
                            var isDirectTextChild = shouldSetTextContent(type, nextProps);
                            if (isDirectTextChild) {
                                nextChildren = null;
                            } else if (prevProps && shouldSetTextContent(type, prevProps)) {
                                workInProgress.effectTag |= ContentReset;
                            }
                            markRef(current, workInProgress);
                            if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {
                                workInProgress.expirationTime = Never;
                                return null;
                            }
                            reconcileChildren(current, workInProgress, nextChildren);
                            memoizeProps(workInProgress, nextProps);
                            return workInProgress.child;
                        }
                        function updateHostText(current, workInProgress) {
                            if (current === null) {
                                tryToClaimNextHydratableInstance(workInProgress);
                            }
                            var nextProps = workInProgress.pendingProps;
                            if (nextProps === null) {
                                nextProps = workInProgress.memoizedProps;
                            }
                            memoizeProps(workInProgress, nextProps);
                            return null;
                        }
                        function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {
                            !(current === null) ? invariant(false, "An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            var fn = workInProgress.type;
                            var props = workInProgress.pendingProps;
                            var unmaskedContext = getUnmaskedContext(workInProgress);
                            var context = getMaskedContext(workInProgress, unmaskedContext);
                            var value;
                            {
                                if (fn.prototype && typeof fn.prototype.render === "function") {
                                    var componentName = getComponentName(workInProgress);
                                    warning(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + "This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                                }
                                ReactCurrentOwner.current = workInProgress;
                                value = fn(props, context);
                            }
                            workInProgress.effectTag |= PerformedWork;
                            if (typeof value === "object" && value !== null && typeof value.render === "function") {
                                workInProgress.tag = ClassComponent;
                                var hasContext = pushContextProvider(workInProgress);
                                adoptClassInstance(workInProgress, value);
                                mountClassInstance(workInProgress, renderExpirationTime);
                                return finishClassComponent(current, workInProgress, true, hasContext);
                            } else {
                                workInProgress.tag = FunctionalComponent;
                                {
                                    var Component = workInProgress.type;
                                    if (Component) {
                                        warning(!Component.childContextTypes, "%s(...): childContextTypes cannot be defined on a functional component.", Component.displayName || Component.name || "Component");
                                    }
                                    if (workInProgress.ref !== null) {
                                        var info = "";
                                        var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();
                                        if (ownerName) {
                                            info += "\n\nCheck the render method of `" + ownerName + "`.";
                                        }
                                        var warningKey = ownerName || workInProgress._debugID || "";
                                        var debugSource = workInProgress._debugSource;
                                        if (debugSource) {
                                            warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                                        }
                                        if (!warnedAboutStatelessRefs[warningKey]) {
                                            warnedAboutStatelessRefs[warningKey] = true;
                                            warning(false, "Stateless function components cannot be given refs. " + "Attempts to access this ref will fail.%s%s", info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());
                                        }
                                    }
                                }
                                reconcileChildren(current, workInProgress, value);
                                memoizeProps(workInProgress, props);
                                return workInProgress.child;
                            }
                        }
                        function updateCallComponent(current, workInProgress, renderExpirationTime) {
                            var nextCall = workInProgress.pendingProps;
                            if (hasContextChanged()) {
                                if (nextCall === null) {
                                    nextCall = current && current.memoizedProps;
                                    !(nextCall !== null) ? invariant(false, "We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                                }
                            } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {
                                nextCall = workInProgress.memoizedProps;
                            }
                            var nextChildren = nextCall.children;
                            if (current === null) {
                                workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
                            } else {
                                workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
                            }
                            memoizeProps(workInProgress, nextCall);
                            return workInProgress.stateNode;
                        }
                        function updatePortalComponent(current, workInProgress, renderExpirationTime) {
                            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                            var nextChildren = workInProgress.pendingProps;
                            if (hasContextChanged()) {
                                if (nextChildren === null) {
                                    nextChildren = current && current.memoizedProps;
                                    !(nextChildren != null) ? invariant(false, "We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                                }
                            } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
                                return bailoutOnAlreadyFinishedWork(current, workInProgress);
                            }
                            if (current === null) {
                                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
                                memoizeProps(workInProgress, nextChildren);
                            } else {
                                reconcileChildren(current, workInProgress, nextChildren);
                                memoizeProps(workInProgress, nextChildren);
                            }
                            return workInProgress.child;
                        }
                        function bailoutOnAlreadyFinishedWork(current, workInProgress) {
                            cancelWorkTimer(workInProgress);
                            cloneChildFibers(current, workInProgress);
                            return workInProgress.child;
                        }
                        function bailoutOnLowPriority(current, workInProgress) {
                            cancelWorkTimer(workInProgress);
                            switch (workInProgress.tag) {
                              case HostRoot:
                                pushHostRootContext(workInProgress);
                                break;

                              case ClassComponent:
                                pushContextProvider(workInProgress);
                                break;

                              case HostPortal:
                                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                                break;
                            }
                            return null;
                        }
                        function memoizeProps(workInProgress, nextProps) {
                            workInProgress.memoizedProps = nextProps;
                        }
                        function memoizeState(workInProgress, nextState) {
                            workInProgress.memoizedState = nextState;
                        }
                        function beginWork(current, workInProgress, renderExpirationTime) {
                            if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
                                return bailoutOnLowPriority(current, workInProgress);
                            }
                            switch (workInProgress.tag) {
                              case IndeterminateComponent:
                                return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);

                              case FunctionalComponent:
                                return updateFunctionalComponent(current, workInProgress);

                              case ClassComponent:
                                return updateClassComponent(current, workInProgress, renderExpirationTime);

                              case HostRoot:
                                return updateHostRoot(current, workInProgress, renderExpirationTime);

                              case HostComponent:
                                return updateHostComponent(current, workInProgress, renderExpirationTime);

                              case HostText:
                                return updateHostText(current, workInProgress);

                              case CallHandlerPhase:
                                workInProgress.tag = CallComponent;

                              case CallComponent:
                                return updateCallComponent(current, workInProgress, renderExpirationTime);

                              case ReturnComponent:
                                return null;

                              case HostPortal:
                                return updatePortalComponent(current, workInProgress, renderExpirationTime);

                              case Fragment:
                                return updateFragment(current, workInProgress);

                              default:
                                invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.");
                            }
                        }
                        function beginFailedWork(current, workInProgress, renderExpirationTime) {
                            switch (workInProgress.tag) {
                              case ClassComponent:
                                pushContextProvider(workInProgress);
                                break;

                              case HostRoot:
                                pushHostRootContext(workInProgress);
                                break;

                              default:
                                invariant(false, "Invalid type of work. This error is likely caused by a bug in React. Please file an issue.");
                            }
                            workInProgress.effectTag |= Err;
                            if (current === null) {
                                workInProgress.child = null;
                            } else if (workInProgress.child !== current.child) {
                                workInProgress.child = current.child;
                            }
                            if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
                                return bailoutOnLowPriority(current, workInProgress);
                            }
                            workInProgress.firstEffect = null;
                            workInProgress.lastEffect = null;
                            var nextChildren = null;
                            reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);
                            if (workInProgress.tag === ClassComponent) {
                                var instance = workInProgress.stateNode;
                                workInProgress.memoizedProps = instance.props;
                                workInProgress.memoizedState = instance.state;
                            }
                            return workInProgress.child;
                        }
                        return {
                            beginWork: beginWork,
                            beginFailedWork: beginFailedWork
                        };
                    };
                    var ReactFiberCompleteWork = function(config, hostContext, hydrationContext) {
                        var createInstance = config.createInstance, createTextInstance = config.createTextInstance, appendInitialChild = config.appendInitialChild, finalizeInitialChildren = config.finalizeInitialChildren, prepareUpdate = config.prepareUpdate, mutation = config.mutation, persistence = config.persistence;
                        var getRootHostContainer = hostContext.getRootHostContainer, popHostContext = hostContext.popHostContext, getHostContext = hostContext.getHostContext, popHostContainer = hostContext.popHostContainer;
                        var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance, prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance, popHydrationState = hydrationContext.popHydrationState;
                        function markUpdate(workInProgress) {
                            workInProgress.effectTag |= Update;
                        }
                        function markRef(workInProgress) {
                            workInProgress.effectTag |= Ref;
                        }
                        function appendAllReturns(returns, workInProgress) {
                            var node = workInProgress.stateNode;
                            if (node) {
                                node["return"] = workInProgress;
                            }
                            while (node !== null) {
                                if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {
                                    invariant(false, "A call cannot have host component children.");
                                } else if (node.tag === ReturnComponent) {
                                    returns.push(node.type);
                                } else if (node.child !== null) {
                                    node.child["return"] = node;
                                    node = node.child;
                                    continue;
                                }
                                while (node.sibling === null) {
                                    if (node["return"] === null || node["return"] === workInProgress) {
                                        return;
                                    }
                                    node = node["return"];
                                }
                                node.sibling["return"] = node["return"];
                                node = node.sibling;
                            }
                        }
                        function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {
                            var call = workInProgress.memoizedProps;
                            !call ? invariant(false, "Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            workInProgress.tag = CallHandlerPhase;
                            var returns = [];
                            appendAllReturns(returns, workInProgress);
                            var fn = call.handler;
                            var props = call.props;
                            var nextChildren = fn(props, returns);
                            var currentFirstChild = current !== null ? current.child : null;
                            workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);
                            return workInProgress.child;
                        }
                        function appendAllChildren(parent, workInProgress) {
                            var node = workInProgress.child;
                            while (node !== null) {
                                if (node.tag === HostComponent || node.tag === HostText) {
                                    appendInitialChild(parent, node.stateNode);
                                } else if (node.tag === HostPortal) {} else if (node.child !== null) {
                                    node.child["return"] = node;
                                    node = node.child;
                                    continue;
                                }
                                if (node === workInProgress) {
                                    return;
                                }
                                while (node.sibling === null) {
                                    if (node["return"] === null || node["return"] === workInProgress) {
                                        return;
                                    }
                                    node = node["return"];
                                }
                                node.sibling["return"] = node["return"];
                                node = node.sibling;
                            }
                        }
                        var updateHostContainer = void 0;
                        var updateHostComponent = void 0;
                        var updateHostText = void 0;
                        if (mutation) {
                            if (enableMutatingReconciler) {
                                updateHostContainer = function(workInProgress) {};
                                updateHostComponent = function(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
                                    workInProgress.updateQueue = updatePayload;
                                    if (updatePayload) {
                                        markUpdate(workInProgress);
                                    }
                                };
                                updateHostText = function(current, workInProgress, oldText, newText) {
                                    if (oldText !== newText) {
                                        markUpdate(workInProgress);
                                    }
                                };
                            } else {
                                invariant(false, "Mutating reconciler is disabled.");
                            }
                        } else if (persistence) {
                            if (enablePersistentReconciler) {
                                var cloneInstance = persistence.cloneInstance, createContainerChildSet = persistence.createContainerChildSet, appendChildToContainerChildSet = persistence.appendChildToContainerChildSet, finalizeContainerChildren = persistence.finalizeContainerChildren;
                                var appendAllChildrenToContainer = function(containerChildSet, workInProgress) {
                                    var node = workInProgress.child;
                                    while (node !== null) {
                                        if (node.tag === HostComponent || node.tag === HostText) {
                                            appendChildToContainerChildSet(containerChildSet, node.stateNode);
                                        } else if (node.tag === HostPortal) {} else if (node.child !== null) {
                                            node.child["return"] = node;
                                            node = node.child;
                                            continue;
                                        }
                                        if (node === workInProgress) {
                                            return;
                                        }
                                        while (node.sibling === null) {
                                            if (node["return"] === null || node["return"] === workInProgress) {
                                                return;
                                            }
                                            node = node["return"];
                                        }
                                        node.sibling["return"] = node["return"];
                                        node = node.sibling;
                                    }
                                };
                                updateHostContainer = function(workInProgress) {
                                    var portalOrRoot = workInProgress.stateNode;
                                    var childrenUnchanged = workInProgress.firstEffect === null;
                                    if (childrenUnchanged) {} else {
                                        var container = portalOrRoot.containerInfo;
                                        var newChildSet = createContainerChildSet(container);
                                        if (finalizeContainerChildren(container, newChildSet)) {
                                            markUpdate(workInProgress);
                                        }
                                        portalOrRoot.pendingChildren = newChildSet;
                                        appendAllChildrenToContainer(newChildSet, workInProgress);
                                        markUpdate(workInProgress);
                                    }
                                };
                                updateHostComponent = function(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
                                    var childrenUnchanged = workInProgress.firstEffect === null;
                                    var currentInstance = current.stateNode;
                                    if (childrenUnchanged && updatePayload === null) {
                                        workInProgress.stateNode = currentInstance;
                                    } else {
                                        var recyclableInstance = workInProgress.stateNode;
                                        var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
                                        if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {
                                            markUpdate(workInProgress);
                                        }
                                        workInProgress.stateNode = newInstance;
                                        if (childrenUnchanged) {
                                            markUpdate(workInProgress);
                                        } else {
                                            appendAllChildren(newInstance, workInProgress);
                                        }
                                    }
                                };
                                updateHostText = function(current, workInProgress, oldText, newText) {
                                    if (oldText !== newText) {
                                        var rootContainerInstance = getRootHostContainer();
                                        var currentHostContext = getHostContext();
                                        workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
                                        markUpdate(workInProgress);
                                    }
                                };
                            } else {
                                invariant(false, "Persistent reconciler is disabled.");
                            }
                        } else {
                            if (enableNoopReconciler) {
                                updateHostContainer = function(workInProgress) {};
                                updateHostComponent = function(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {};
                                updateHostText = function(current, workInProgress, oldText, newText) {};
                            } else {
                                invariant(false, "Noop reconciler is disabled.");
                            }
                        }
                        function completeWork(current, workInProgress, renderExpirationTime) {
                            var newProps = workInProgress.pendingProps;
                            if (newProps === null) {
                                newProps = workInProgress.memoizedProps;
                            } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {
                                workInProgress.pendingProps = null;
                            }
                            switch (workInProgress.tag) {
                              case FunctionalComponent:
                                return null;

                              case ClassComponent:
                                {
                                    popContextProvider(workInProgress);
                                    return null;
                                }

                              case HostRoot:
                                {
                                    popHostContainer(workInProgress);
                                    popTopLevelContextObject(workInProgress);
                                    var fiberRoot = workInProgress.stateNode;
                                    if (fiberRoot.pendingContext) {
                                        fiberRoot.context = fiberRoot.pendingContext;
                                        fiberRoot.pendingContext = null;
                                    }
                                    if (current === null || current.child === null) {
                                        popHydrationState(workInProgress);
                                        workInProgress.effectTag &= ~Placement;
                                    }
                                    updateHostContainer(workInProgress);
                                    return null;
                                }

                              case HostComponent:
                                {
                                    popHostContext(workInProgress);
                                    var rootContainerInstance = getRootHostContainer();
                                    var type = workInProgress.type;
                                    if (current !== null && workInProgress.stateNode != null) {
                                        var oldProps = current.memoizedProps;
                                        var instance = workInProgress.stateNode;
                                        var currentHostContext = getHostContext();
                                        var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
                                        updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);
                                        if (current.ref !== workInProgress.ref) {
                                            markRef(workInProgress);
                                        }
                                    } else {
                                        if (!newProps) {
                                            !(workInProgress.stateNode !== null) ? invariant(false, "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                                            return null;
                                        }
                                        var _currentHostContext = getHostContext();
                                        var wasHydrated = popHydrationState(workInProgress);
                                        if (wasHydrated) {
                                            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
                                                markUpdate(workInProgress);
                                            }
                                        } else {
                                            var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);
                                            appendAllChildren(_instance, workInProgress);
                                            if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {
                                                markUpdate(workInProgress);
                                            }
                                            workInProgress.stateNode = _instance;
                                        }
                                        if (workInProgress.ref !== null) {
                                            markRef(workInProgress);
                                        }
                                    }
                                    return null;
                                }

                              case HostText:
                                {
                                    var newText = newProps;
                                    if (current && workInProgress.stateNode != null) {
                                        var oldText = current.memoizedProps;
                                        updateHostText(current, workInProgress, oldText, newText);
                                    } else {
                                        if (typeof newText !== "string") {
                                            !(workInProgress.stateNode !== null) ? invariant(false, "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                                            return null;
                                        }
                                        var _rootContainerInstance = getRootHostContainer();
                                        var _currentHostContext2 = getHostContext();
                                        var _wasHydrated = popHydrationState(workInProgress);
                                        if (_wasHydrated) {
                                            if (prepareToHydrateHostTextInstance(workInProgress)) {
                                                markUpdate(workInProgress);
                                            }
                                        } else {
                                            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
                                        }
                                    }
                                    return null;
                                }

                              case CallComponent:
                                return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);

                              case CallHandlerPhase:
                                workInProgress.tag = CallComponent;
                                return null;

                              case ReturnComponent:
                                return null;

                              case Fragment:
                                return null;

                              case HostPortal:
                                popHostContainer(workInProgress);
                                updateHostContainer(workInProgress);
                                return null;

                              case IndeterminateComponent:
                                invariant(false, "An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.");

                              default:
                                invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.");
                            }
                        }
                        return {
                            completeWork: completeWork
                        };
                    };
                    var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
                    var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
                    var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;
                    var ReactFiberCommitWork = function(config, captureError) {
                        var getPublicInstance = config.getPublicInstance, mutation = config.mutation, persistence = config.persistence;
                        var callComponentWillUnmountWithTimer = function(current, instance) {
                            startPhaseTimer(current, "componentWillUnmount");
                            instance.props = current.memoizedProps;
                            instance.state = current.memoizedState;
                            instance.componentWillUnmount();
                            stopPhaseTimer();
                        };
                        function safelyCallComponentWillUnmount(current, instance) {
                            {
                                invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);
                                if (hasCaughtError$1()) {
                                    var unmountError = clearCaughtError$1();
                                    captureError(current, unmountError);
                                }
                            }
                        }
                        function safelyDetachRef(current) {
                            var ref = current.ref;
                            if (ref !== null) {
                                {
                                    invokeGuardedCallback$2(null, ref, null, null);
                                    if (hasCaughtError$1()) {
                                        var refError = clearCaughtError$1();
                                        captureError(current, refError);
                                    }
                                }
                            }
                        }
                        function commitLifeCycles(current, finishedWork) {
                            switch (finishedWork.tag) {
                              case ClassComponent:
                                {
                                    var instance = finishedWork.stateNode;
                                    if (finishedWork.effectTag & Update) {
                                        if (current === null) {
                                            startPhaseTimer(finishedWork, "componentDidMount");
                                            instance.props = finishedWork.memoizedProps;
                                            instance.state = finishedWork.memoizedState;
                                            instance.componentDidMount();
                                            stopPhaseTimer();
                                        } else {
                                            var prevProps = current.memoizedProps;
                                            var prevState = current.memoizedState;
                                            startPhaseTimer(finishedWork, "componentDidUpdate");
                                            instance.props = finishedWork.memoizedProps;
                                            instance.state = finishedWork.memoizedState;
                                            instance.componentDidUpdate(prevProps, prevState);
                                            stopPhaseTimer();
                                        }
                                    }
                                    var updateQueue = finishedWork.updateQueue;
                                    if (updateQueue !== null) {
                                        commitCallbacks(updateQueue, instance);
                                    }
                                    return;
                                }

                              case HostRoot:
                                {
                                    var _updateQueue = finishedWork.updateQueue;
                                    if (_updateQueue !== null) {
                                        var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;
                                        commitCallbacks(_updateQueue, _instance);
                                    }
                                    return;
                                }

                              case HostComponent:
                                {
                                    var _instance2 = finishedWork.stateNode;
                                    if (current === null && finishedWork.effectTag & Update) {
                                        var type = finishedWork.type;
                                        var props = finishedWork.memoizedProps;
                                        commitMount(_instance2, type, props, finishedWork);
                                    }
                                    return;
                                }

                              case HostText:
                                {
                                    return;
                                }

                              case HostPortal:
                                {
                                    return;
                                }

                              default:
                                {
                                    invariant(false, "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                                }
                            }
                        }
                        function commitAttachRef(finishedWork) {
                            var ref = finishedWork.ref;
                            if (ref !== null) {
                                var instance = finishedWork.stateNode;
                                switch (finishedWork.tag) {
                                  case HostComponent:
                                    ref(getPublicInstance(instance));
                                    break;

                                  default:
                                    ref(instance);
                                }
                            }
                        }
                        function commitDetachRef(current) {
                            var currentRef = current.ref;
                            if (currentRef !== null) {
                                currentRef(null);
                            }
                        }
                        function commitUnmount(current) {
                            if (typeof onCommitUnmount === "function") {
                                onCommitUnmount(current);
                            }
                            switch (current.tag) {
                              case ClassComponent:
                                {
                                    safelyDetachRef(current);
                                    var instance = current.stateNode;
                                    if (typeof instance.componentWillUnmount === "function") {
                                        safelyCallComponentWillUnmount(current, instance);
                                    }
                                    return;
                                }

                              case HostComponent:
                                {
                                    safelyDetachRef(current);
                                    return;
                                }

                              case CallComponent:
                                {
                                    commitNestedUnmounts(current.stateNode);
                                    return;
                                }

                              case HostPortal:
                                {
                                    if (enableMutatingReconciler && mutation) {
                                        unmountHostComponents(current);
                                    } else if (enablePersistentReconciler && persistence) {
                                        emptyPortalContainer(current);
                                    }
                                    return;
                                }
                            }
                        }
                        function commitNestedUnmounts(root) {
                            var node = root;
                            while (true) {
                                commitUnmount(node);
                                if (node.child !== null && (!mutation || node.tag !== HostPortal)) {
                                    node.child["return"] = node;
                                    node = node.child;
                                    continue;
                                }
                                if (node === root) {
                                    return;
                                }
                                while (node.sibling === null) {
                                    if (node["return"] === null || node["return"] === root) {
                                        return;
                                    }
                                    node = node["return"];
                                }
                                node.sibling["return"] = node["return"];
                                node = node.sibling;
                            }
                        }
                        function detachFiber(current) {
                            current["return"] = null;
                            current.child = null;
                            if (current.alternate) {
                                current.alternate.child = null;
                                current.alternate["return"] = null;
                            }
                        }
                        if (!mutation) {
                            var commitContainer = void 0;
                            if (persistence) {
                                var replaceContainerChildren = persistence.replaceContainerChildren, createContainerChildSet = persistence.createContainerChildSet;
                                var emptyPortalContainer = function(current) {
                                    var portal = current.stateNode;
                                    var containerInfo = portal.containerInfo;
                                    var emptyChildSet = createContainerChildSet(containerInfo);
                                    replaceContainerChildren(containerInfo, emptyChildSet);
                                };
                                commitContainer = function(finishedWork) {
                                    switch (finishedWork.tag) {
                                      case ClassComponent:
                                        {
                                            return;
                                        }

                                      case HostComponent:
                                        {
                                            return;
                                        }

                                      case HostText:
                                        {
                                            return;
                                        }

                                      case HostRoot:
                                      case HostPortal:
                                        {
                                            var portalOrRoot = finishedWork.stateNode;
                                            var containerInfo = portalOrRoot.containerInfo, _pendingChildren = portalOrRoot.pendingChildren;
                                            replaceContainerChildren(containerInfo, _pendingChildren);
                                            return;
                                        }

                                      default:
                                        {
                                            invariant(false, "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                                        }
                                    }
                                };
                            } else {
                                commitContainer = function(finishedWork) {};
                            }
                            if (enablePersistentReconciler || enableNoopReconciler) {
                                return {
                                    commitResetTextContent: function(finishedWork) {},
                                    commitPlacement: function(finishedWork) {},
                                    commitDeletion: function(current) {
                                        commitNestedUnmounts(current);
                                        detachFiber(current);
                                    },
                                    commitWork: function(current, finishedWork) {
                                        commitContainer(finishedWork);
                                    },
                                    commitLifeCycles: commitLifeCycles,
                                    commitAttachRef: commitAttachRef,
                                    commitDetachRef: commitDetachRef
                                };
                            } else if (persistence) {
                                invariant(false, "Persistent reconciler is disabled.");
                            } else {
                                invariant(false, "Noop reconciler is disabled.");
                            }
                        }
                        var commitMount = mutation.commitMount, commitUpdate = mutation.commitUpdate, resetTextContent = mutation.resetTextContent, commitTextUpdate = mutation.commitTextUpdate, appendChild = mutation.appendChild, appendChildToContainer = mutation.appendChildToContainer, insertBefore = mutation.insertBefore, insertInContainerBefore = mutation.insertInContainerBefore, removeChild = mutation.removeChild, removeChildFromContainer = mutation.removeChildFromContainer;
                        function getHostParentFiber(fiber) {
                            var parent = fiber["return"];
                            while (parent !== null) {
                                if (isHostParent(parent)) {
                                    return parent;
                                }
                                parent = parent["return"];
                            }
                            invariant(false, "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                        }
                        function isHostParent(fiber) {
                            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
                        }
                        function getHostSibling(fiber) {
                            var node = fiber;
                            siblings: while (true) {
                                while (node.sibling === null) {
                                    if (node["return"] === null || isHostParent(node["return"])) {
                                        return null;
                                    }
                                    node = node["return"];
                                }
                                node.sibling["return"] = node["return"];
                                node = node.sibling;
                                while (node.tag !== HostComponent && node.tag !== HostText) {
                                    if (node.effectTag & Placement) {
                                        continue siblings;
                                    }
                                    if (node.child === null || node.tag === HostPortal) {
                                        continue siblings;
                                    } else {
                                        node.child["return"] = node;
                                        node = node.child;
                                    }
                                }
                                if (!(node.effectTag & Placement)) {
                                    return node.stateNode;
                                }
                            }
                        }
                        function commitPlacement(finishedWork) {
                            var parentFiber = getHostParentFiber(finishedWork);
                            var parent = void 0;
                            var isContainer = void 0;
                            switch (parentFiber.tag) {
                              case HostComponent:
                                parent = parentFiber.stateNode;
                                isContainer = false;
                                break;

                              case HostRoot:
                                parent = parentFiber.stateNode.containerInfo;
                                isContainer = true;
                                break;

                              case HostPortal:
                                parent = parentFiber.stateNode.containerInfo;
                                isContainer = true;
                                break;

                              default:
                                invariant(false, "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
                            }
                            if (parentFiber.effectTag & ContentReset) {
                                resetTextContent(parent);
                                parentFiber.effectTag &= ~ContentReset;
                            }
                            var before = getHostSibling(finishedWork);
                            var node = finishedWork;
                            while (true) {
                                if (node.tag === HostComponent || node.tag === HostText) {
                                    if (before) {
                                        if (isContainer) {
                                            insertInContainerBefore(parent, node.stateNode, before);
                                        } else {
                                            insertBefore(parent, node.stateNode, before);
                                        }
                                    } else {
                                        if (isContainer) {
                                            appendChildToContainer(parent, node.stateNode);
                                        } else {
                                            appendChild(parent, node.stateNode);
                                        }
                                    }
                                } else if (node.tag === HostPortal) {} else if (node.child !== null) {
                                    node.child["return"] = node;
                                    node = node.child;
                                    continue;
                                }
                                if (node === finishedWork) {
                                    return;
                                }
                                while (node.sibling === null) {
                                    if (node["return"] === null || node["return"] === finishedWork) {
                                        return;
                                    }
                                    node = node["return"];
                                }
                                node.sibling["return"] = node["return"];
                                node = node.sibling;
                            }
                        }
                        function unmountHostComponents(current) {
                            var node = current;
                            var currentParentIsValid = false;
                            var currentParent = void 0;
                            var currentParentIsContainer = void 0;
                            while (true) {
                                if (!currentParentIsValid) {
                                    var parent = node["return"];
                                    findParent: while (true) {
                                        !(parent !== null) ? invariant(false, "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                                        switch (parent.tag) {
                                          case HostComponent:
                                            currentParent = parent.stateNode;
                                            currentParentIsContainer = false;
                                            break findParent;

                                          case HostRoot:
                                            currentParent = parent.stateNode.containerInfo;
                                            currentParentIsContainer = true;
                                            break findParent;

                                          case HostPortal:
                                            currentParent = parent.stateNode.containerInfo;
                                            currentParentIsContainer = true;
                                            break findParent;
                                        }
                                        parent = parent["return"];
                                    }
                                    currentParentIsValid = true;
                                }
                                if (node.tag === HostComponent || node.tag === HostText) {
                                    commitNestedUnmounts(node);
                                    if (currentParentIsContainer) {
                                        removeChildFromContainer(currentParent, node.stateNode);
                                    } else {
                                        removeChild(currentParent, node.stateNode);
                                    }
                                } else if (node.tag === HostPortal) {
                                    currentParent = node.stateNode.containerInfo;
                                    if (node.child !== null) {
                                        node.child["return"] = node;
                                        node = node.child;
                                        continue;
                                    }
                                } else {
                                    commitUnmount(node);
                                    if (node.child !== null) {
                                        node.child["return"] = node;
                                        node = node.child;
                                        continue;
                                    }
                                }
                                if (node === current) {
                                    return;
                                }
                                while (node.sibling === null) {
                                    if (node["return"] === null || node["return"] === current) {
                                        return;
                                    }
                                    node = node["return"];
                                    if (node.tag === HostPortal) {
                                        currentParentIsValid = false;
                                    }
                                }
                                node.sibling["return"] = node["return"];
                                node = node.sibling;
                            }
                        }
                        function commitDeletion(current) {
                            unmountHostComponents(current);
                            detachFiber(current);
                        }
                        function commitWork(current, finishedWork) {
                            switch (finishedWork.tag) {
                              case ClassComponent:
                                {
                                    return;
                                }

                              case HostComponent:
                                {
                                    var instance = finishedWork.stateNode;
                                    if (instance != null) {
                                        var newProps = finishedWork.memoizedProps;
                                        var oldProps = current !== null ? current.memoizedProps : newProps;
                                        var type = finishedWork.type;
                                        var updatePayload = finishedWork.updateQueue;
                                        finishedWork.updateQueue = null;
                                        if (updatePayload !== null) {
                                            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
                                        }
                                    }
                                    return;
                                }

                              case HostText:
                                {
                                    !(finishedWork.stateNode !== null) ? invariant(false, "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                                    var textInstance = finishedWork.stateNode;
                                    var newText = finishedWork.memoizedProps;
                                    var oldText = current !== null ? current.memoizedProps : newText;
                                    commitTextUpdate(textInstance, oldText, newText);
                                    return;
                                }

                              case HostRoot:
                                {
                                    return;
                                }

                              default:
                                {
                                    invariant(false, "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                                }
                            }
                        }
                        function commitResetTextContent(current) {
                            resetTextContent(current.stateNode);
                        }
                        if (enableMutatingReconciler) {
                            return {
                                commitResetTextContent: commitResetTextContent,
                                commitPlacement: commitPlacement,
                                commitDeletion: commitDeletion,
                                commitWork: commitWork,
                                commitLifeCycles: commitLifeCycles,
                                commitAttachRef: commitAttachRef,
                                commitDetachRef: commitDetachRef
                            };
                        } else {
                            invariant(false, "Mutating reconciler is disabled.");
                        }
                    };
                    var NO_CONTEXT = {};
                    var ReactFiberHostContext = function(config) {
                        var getChildHostContext = config.getChildHostContext, getRootHostContext = config.getRootHostContext;
                        var contextStackCursor = createCursor(NO_CONTEXT);
                        var contextFiberStackCursor = createCursor(NO_CONTEXT);
                        var rootInstanceStackCursor = createCursor(NO_CONTEXT);
                        function requiredContext(c) {
                            !(c !== NO_CONTEXT) ? invariant(false, "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            return c;
                        }
                        function getRootHostContainer() {
                            var rootInstance = requiredContext(rootInstanceStackCursor.current);
                            return rootInstance;
                        }
                        function pushHostContainer(fiber, nextRootInstance) {
                            push(rootInstanceStackCursor, nextRootInstance, fiber);
                            var nextRootContext = getRootHostContext(nextRootInstance);
                            push(contextFiberStackCursor, fiber, fiber);
                            push(contextStackCursor, nextRootContext, fiber);
                        }
                        function popHostContainer(fiber) {
                            pop(contextStackCursor, fiber);
                            pop(contextFiberStackCursor, fiber);
                            pop(rootInstanceStackCursor, fiber);
                        }
                        function getHostContext() {
                            var context = requiredContext(contextStackCursor.current);
                            return context;
                        }
                        function pushHostContext(fiber) {
                            var rootInstance = requiredContext(rootInstanceStackCursor.current);
                            var context = requiredContext(contextStackCursor.current);
                            var nextContext = getChildHostContext(context, fiber.type, rootInstance);
                            if (context === nextContext) {
                                return;
                            }
                            push(contextFiberStackCursor, fiber, fiber);
                            push(contextStackCursor, nextContext, fiber);
                        }
                        function popHostContext(fiber) {
                            if (contextFiberStackCursor.current !== fiber) {
                                return;
                            }
                            pop(contextStackCursor, fiber);
                            pop(contextFiberStackCursor, fiber);
                        }
                        function resetHostContainer() {
                            contextStackCursor.current = NO_CONTEXT;
                            rootInstanceStackCursor.current = NO_CONTEXT;
                        }
                        return {
                            getHostContext: getHostContext,
                            getRootHostContainer: getRootHostContainer,
                            popHostContainer: popHostContainer,
                            popHostContext: popHostContext,
                            pushHostContainer: pushHostContainer,
                            pushHostContext: pushHostContext,
                            resetHostContainer: resetHostContainer
                        };
                    };
                    var ReactFiberHydrationContext = function(config) {
                        var shouldSetTextContent = config.shouldSetTextContent, hydration = config.hydration;
                        if (!hydration) {
                            return {
                                enterHydrationState: function() {
                                    return false;
                                },
                                resetHydrationState: function() {},
                                tryToClaimNextHydratableInstance: function() {},
                                prepareToHydrateHostInstance: function() {
                                    invariant(false, "Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                                },
                                prepareToHydrateHostTextInstance: function() {
                                    invariant(false, "Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                                },
                                popHydrationState: function(fiber) {
                                    return false;
                                }
                            };
                        }
                        var canHydrateInstance = hydration.canHydrateInstance, canHydrateTextInstance = hydration.canHydrateTextInstance, getNextHydratableSibling = hydration.getNextHydratableSibling, getFirstHydratableChild = hydration.getFirstHydratableChild, hydrateInstance = hydration.hydrateInstance, hydrateTextInstance = hydration.hydrateTextInstance, didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance, didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance, didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance, didNotHydrateInstance = hydration.didNotHydrateInstance, didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance, didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance, didNotFindHydratableInstance = hydration.didNotFindHydratableInstance, didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;
                        var hydrationParentFiber = null;
                        var nextHydratableInstance = null;
                        var isHydrating = false;
                        function enterHydrationState(fiber) {
                            var parentInstance = fiber.stateNode.containerInfo;
                            nextHydratableInstance = getFirstHydratableChild(parentInstance);
                            hydrationParentFiber = fiber;
                            isHydrating = true;
                            return true;
                        }
                        function deleteHydratableInstance(returnFiber, instance) {
                            {
                                switch (returnFiber.tag) {
                                  case HostRoot:
                                    didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
                                    break;

                                  case HostComponent:
                                    didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
                                    break;
                                }
                            }
                            var childToDelete = createFiberFromHostInstanceForDeletion();
                            childToDelete.stateNode = instance;
                            childToDelete["return"] = returnFiber;
                            childToDelete.effectTag = Deletion;
                            if (returnFiber.lastEffect !== null) {
                                returnFiber.lastEffect.nextEffect = childToDelete;
                                returnFiber.lastEffect = childToDelete;
                            } else {
                                returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
                            }
                        }
                        function insertNonHydratedInstance(returnFiber, fiber) {
                            fiber.effectTag |= Placement;
                            {
                                switch (returnFiber.tag) {
                                  case HostRoot:
                                    {
                                        var parentContainer = returnFiber.stateNode.containerInfo;
                                        switch (fiber.tag) {
                                          case HostComponent:
                                            var type = fiber.type;
                                            var props = fiber.pendingProps;
                                            didNotFindHydratableContainerInstance(parentContainer, type, props);
                                            break;

                                          case HostText:
                                            var text = fiber.pendingProps;
                                            didNotFindHydratableContainerTextInstance(parentContainer, text);
                                            break;
                                        }
                                        break;
                                    }

                                  case HostComponent:
                                    {
                                        var parentType = returnFiber.type;
                                        var parentProps = returnFiber.memoizedProps;
                                        var parentInstance = returnFiber.stateNode;
                                        switch (fiber.tag) {
                                          case HostComponent:
                                            var _type = fiber.type;
                                            var _props = fiber.pendingProps;
                                            didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                                            break;

                                          case HostText:
                                            var _text = fiber.pendingProps;
                                            didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                                            break;
                                        }
                                        break;
                                    }

                                  default:
                                    return;
                                }
                            }
                        }
                        function tryHydrate(fiber, nextInstance) {
                            switch (fiber.tag) {
                              case HostComponent:
                                {
                                    var type = fiber.type;
                                    var props = fiber.pendingProps;
                                    var instance = canHydrateInstance(nextInstance, type, props);
                                    if (instance !== null) {
                                        fiber.stateNode = instance;
                                        return true;
                                    }
                                    return false;
                                }

                              case HostText:
                                {
                                    var text = fiber.pendingProps;
                                    var textInstance = canHydrateTextInstance(nextInstance, text);
                                    if (textInstance !== null) {
                                        fiber.stateNode = textInstance;
                                        return true;
                                    }
                                    return false;
                                }

                              default:
                                return false;
                            }
                        }
                        function tryToClaimNextHydratableInstance(fiber) {
                            if (!isHydrating) {
                                return;
                            }
                            var nextInstance = nextHydratableInstance;
                            if (!nextInstance) {
                                insertNonHydratedInstance(hydrationParentFiber, fiber);
                                isHydrating = false;
                                hydrationParentFiber = fiber;
                                return;
                            }
                            if (!tryHydrate(fiber, nextInstance)) {
                                nextInstance = getNextHydratableSibling(nextInstance);
                                if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                                    insertNonHydratedInstance(hydrationParentFiber, fiber);
                                    isHydrating = false;
                                    hydrationParentFiber = fiber;
                                    return;
                                }
                                deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
                            }
                            hydrationParentFiber = fiber;
                            nextHydratableInstance = getFirstHydratableChild(nextInstance);
                        }
                        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
                            var instance = fiber.stateNode;
                            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
                            fiber.updateQueue = updatePayload;
                            if (updatePayload !== null) {
                                return true;
                            }
                            return false;
                        }
                        function prepareToHydrateHostTextInstance(fiber) {
                            var textInstance = fiber.stateNode;
                            var textContent = fiber.memoizedProps;
                            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
                            {
                                if (shouldUpdate) {
                                    var returnFiber = hydrationParentFiber;
                                    if (returnFiber !== null) {
                                        switch (returnFiber.tag) {
                                          case HostRoot:
                                            {
                                                var parentContainer = returnFiber.stateNode.containerInfo;
                                                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                                                break;
                                            }

                                          case HostComponent:
                                            {
                                                var parentType = returnFiber.type;
                                                var parentProps = returnFiber.memoizedProps;
                                                var parentInstance = returnFiber.stateNode;
                                                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            return shouldUpdate;
                        }
                        function popToNextHostParent(fiber) {
                            var parent = fiber["return"];
                            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
                                parent = parent["return"];
                            }
                            hydrationParentFiber = parent;
                        }
                        function popHydrationState(fiber) {
                            if (fiber !== hydrationParentFiber) {
                                return false;
                            }
                            if (!isHydrating) {
                                popToNextHostParent(fiber);
                                isHydrating = true;
                                return false;
                            }
                            var type = fiber.type;
                            if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps)) {
                                var nextInstance = nextHydratableInstance;
                                while (nextInstance) {
                                    deleteHydratableInstance(fiber, nextInstance);
                                    nextInstance = getNextHydratableSibling(nextInstance);
                                }
                            }
                            popToNextHostParent(fiber);
                            nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
                            return true;
                        }
                        function resetHydrationState() {
                            hydrationParentFiber = null;
                            nextHydratableInstance = null;
                            isHydrating = false;
                        }
                        return {
                            enterHydrationState: enterHydrationState,
                            resetHydrationState: resetHydrationState,
                            tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
                            prepareToHydrateHostInstance: prepareToHydrateHostInstance,
                            prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
                            popHydrationState: popHydrationState
                        };
                    };
                    var ReactFiberInstrumentation = {
                        debugTool: null
                    };
                    var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;
                    var defaultShowDialog = function(capturedError) {
                        return true;
                    };
                    var showDialog = defaultShowDialog;
                    function logCapturedError(capturedError) {
                        var logError = showDialog(capturedError);
                        if (logError === false) {
                            return;
                        }
                        var error = capturedError.error;
                        var suppressLogging = error && error.suppressReactErrorLogging;
                        if (suppressLogging) {
                            return;
                        }
                        {
                            var componentName = capturedError.componentName, componentStack = capturedError.componentStack, errorBoundaryName = capturedError.errorBoundaryName, errorBoundaryFound = capturedError.errorBoundaryFound, willRetry = capturedError.willRetry;
                            var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                            var errorBoundaryMessage = void 0;
                            if (errorBoundaryFound && errorBoundaryName) {
                                if (willRetry) {
                                    errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                                } else {
                                    errorBoundaryMessage = "This error was initially handled by the error boundary " + errorBoundaryName + ".\n" + "Recreating the tree from scratch failed so React will unmount the tree.";
                                }
                            } else {
                                errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\n" + "Visit https://fb.me/react-error-boundaries to learn more about error boundaries.";
                            }
                            var combinedMessage = "" + componentNameMessage + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                            console.error(combinedMessage);
                        }
                    }
                    var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;
                    var hasCaughtError = ReactErrorUtils.hasCaughtError;
                    var clearCaughtError = ReactErrorUtils.clearCaughtError;
                    {
                        var didWarnAboutStateTransition = false;
                        var didWarnSetStateChildContext = false;
                        var didWarnStateUpdateForUnmountedComponent = {};
                        var warnAboutUpdateOnUnmounted = function(fiber) {
                            var componentName = getComponentName(fiber) || "ReactClass";
                            if (didWarnStateUpdateForUnmountedComponent[componentName]) {
                                return;
                            }
                            warning(false, "Can only update a mounted or mounting " + "component. This usually means you called setState, replaceState, " + "or forceUpdate on an unmounted component. This is a no-op.\n\nPlease " + "check the code for the %s component.", componentName);
                            didWarnStateUpdateForUnmountedComponent[componentName] = true;
                        };
                        var warnAboutInvalidUpdates = function(instance) {
                            switch (ReactDebugCurrentFiber.phase) {
                              case "getChildContext":
                                if (didWarnSetStateChildContext) {
                                    return;
                                }
                                warning(false, "setState(...): Cannot call setState() inside getChildContext()");
                                didWarnSetStateChildContext = true;
                                break;

                              case "render":
                                if (didWarnAboutStateTransition) {
                                    return;
                                }
                                warning(false, "Cannot update during an existing state transition (such as within " + "`render` or another component's constructor). Render methods should " + "be a pure function of props and state; constructor side-effects are " + "an anti-pattern, but can be moved to `componentWillMount`.");
                                didWarnAboutStateTransition = true;
                                break;
                            }
                        };
                    }
                    var ReactFiberScheduler = function(config) {
                        var hostContext = ReactFiberHostContext(config);
                        var hydrationContext = ReactFiberHydrationContext(config);
                        var popHostContainer = hostContext.popHostContainer, popHostContext = hostContext.popHostContext, resetHostContainer = hostContext.resetHostContainer;
                        var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber), beginWork = _ReactFiberBeginWork.beginWork, beginFailedWork = _ReactFiberBeginWork.beginFailedWork;
                        var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext), completeWork = _ReactFiberCompleteWo.completeWork;
                        var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError), commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent, commitPlacement = _ReactFiberCommitWork.commitPlacement, commitDeletion = _ReactFiberCommitWork.commitDeletion, commitWork = _ReactFiberCommitWork.commitWork, commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles, commitAttachRef = _ReactFiberCommitWork.commitAttachRef, commitDetachRef = _ReactFiberCommitWork.commitDetachRef;
                        var now = config.now, scheduleDeferredCallback = config.scheduleDeferredCallback, cancelDeferredCallback = config.cancelDeferredCallback, useSyncScheduling = config.useSyncScheduling, prepareForCommit = config.prepareForCommit, resetAfterCommit = config.resetAfterCommit;
                        var startTime = now();
                        var mostRecentCurrentTime = msToExpirationTime(0);
                        var expirationContext = NoWork;
                        var isWorking = false;
                        var nextUnitOfWork = null;
                        var nextRoot = null;
                        var nextRenderExpirationTime = NoWork;
                        var nextEffect = null;
                        var capturedErrors = null;
                        var failedBoundaries = null;
                        var commitPhaseBoundaries = null;
                        var firstUncaughtError = null;
                        var didFatal = false;
                        var isCommitting = false;
                        var isUnmounting = false;
                        var interruptedBy = null;
                        function resetContextStack() {
                            reset$1();
                            resetContext();
                            resetHostContainer();
                        }
                        function commitAllHostEffects() {
                            while (nextEffect !== null) {
                                {
                                    ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
                                }
                                recordEffect();
                                var effectTag = nextEffect.effectTag;
                                if (effectTag & ContentReset) {
                                    commitResetTextContent(nextEffect);
                                }
                                if (effectTag & Ref) {
                                    var current = nextEffect.alternate;
                                    if (current !== null) {
                                        commitDetachRef(current);
                                    }
                                }
                                var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);
                                switch (primaryEffectTag) {
                                  case Placement:
                                    {
                                        commitPlacement(nextEffect);
                                        nextEffect.effectTag &= ~Placement;
                                        break;
                                    }

                                  case PlacementAndUpdate:
                                    {
                                        commitPlacement(nextEffect);
                                        nextEffect.effectTag &= ~Placement;
                                        var _current = nextEffect.alternate;
                                        commitWork(_current, nextEffect);
                                        break;
                                    }

                                  case Update:
                                    {
                                        var _current2 = nextEffect.alternate;
                                        commitWork(_current2, nextEffect);
                                        break;
                                    }

                                  case Deletion:
                                    {
                                        isUnmounting = true;
                                        commitDeletion(nextEffect);
                                        isUnmounting = false;
                                        break;
                                    }
                                }
                                nextEffect = nextEffect.nextEffect;
                            }
                            {
                                ReactDebugCurrentFiber.resetCurrentFiber();
                            }
                        }
                        function commitAllLifeCycles() {
                            while (nextEffect !== null) {
                                var effectTag = nextEffect.effectTag;
                                if (effectTag & (Update | Callback)) {
                                    recordEffect();
                                    var current = nextEffect.alternate;
                                    commitLifeCycles(current, nextEffect);
                                }
                                if (effectTag & Ref) {
                                    recordEffect();
                                    commitAttachRef(nextEffect);
                                }
                                if (effectTag & Err) {
                                    recordEffect();
                                    commitErrorHandling(nextEffect);
                                }
                                var next = nextEffect.nextEffect;
                                nextEffect.nextEffect = null;
                                nextEffect = next;
                            }
                        }
                        function commitRoot(finishedWork) {
                            isWorking = true;
                            isCommitting = true;
                            startCommitTimer();
                            var root = finishedWork.stateNode;
                            !(root.current !== finishedWork) ? invariant(false, "Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            root.isReadyForCommit = false;
                            ReactCurrentOwner.current = null;
                            var firstEffect = void 0;
                            if (finishedWork.effectTag > PerformedWork) {
                                if (finishedWork.lastEffect !== null) {
                                    finishedWork.lastEffect.nextEffect = finishedWork;
                                    firstEffect = finishedWork.firstEffect;
                                } else {
                                    firstEffect = finishedWork;
                                }
                            } else {
                                firstEffect = finishedWork.firstEffect;
                            }
                            prepareForCommit();
                            nextEffect = firstEffect;
                            startCommitHostEffectsTimer();
                            while (nextEffect !== null) {
                                var didError = false;
                                var _error = void 0;
                                {
                                    invokeGuardedCallback$1(null, commitAllHostEffects, null);
                                    if (hasCaughtError()) {
                                        didError = true;
                                        _error = clearCaughtError();
                                    }
                                }
                                if (didError) {
                                    !(nextEffect !== null) ? invariant(false, "Should have next effect. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                                    captureError(nextEffect, _error);
                                    if (nextEffect !== null) {
                                        nextEffect = nextEffect.nextEffect;
                                    }
                                }
                            }
                            stopCommitHostEffectsTimer();
                            resetAfterCommit();
                            root.current = finishedWork;
                            nextEffect = firstEffect;
                            startCommitLifeCyclesTimer();
                            while (nextEffect !== null) {
                                var _didError = false;
                                var _error2 = void 0;
                                {
                                    invokeGuardedCallback$1(null, commitAllLifeCycles, null);
                                    if (hasCaughtError()) {
                                        _didError = true;
                                        _error2 = clearCaughtError();
                                    }
                                }
                                if (_didError) {
                                    !(nextEffect !== null) ? invariant(false, "Should have next effect. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                                    captureError(nextEffect, _error2);
                                    if (nextEffect !== null) {
                                        nextEffect = nextEffect.nextEffect;
                                    }
                                }
                            }
                            isCommitting = false;
                            isWorking = false;
                            stopCommitLifeCyclesTimer();
                            stopCommitTimer();
                            if (typeof onCommitRoot === "function") {
                                onCommitRoot(finishedWork.stateNode);
                            }
                            if (true && ReactFiberInstrumentation_1.debugTool) {
                                ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
                            }
                            if (commitPhaseBoundaries) {
                                commitPhaseBoundaries.forEach(scheduleErrorRecovery);
                                commitPhaseBoundaries = null;
                            }
                            if (firstUncaughtError !== null) {
                                var _error3 = firstUncaughtError;
                                firstUncaughtError = null;
                                onUncaughtError(_error3);
                            }
                            var remainingTime = root.current.expirationTime;
                            if (remainingTime === NoWork) {
                                capturedErrors = null;
                                failedBoundaries = null;
                            }
                            return remainingTime;
                        }
                        function resetExpirationTime(workInProgress, renderTime) {
                            if (renderTime !== Never && workInProgress.expirationTime === Never) {
                                return;
                            }
                            var newExpirationTime = getUpdateExpirationTime(workInProgress);
                            var child = workInProgress.child;
                            while (child !== null) {
                                if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {
                                    newExpirationTime = child.expirationTime;
                                }
                                child = child.sibling;
                            }
                            workInProgress.expirationTime = newExpirationTime;
                        }
                        function completeUnitOfWork(workInProgress) {
                            while (true) {
                                var current = workInProgress.alternate;
                                {
                                    ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
                                }
                                var next = completeWork(current, workInProgress, nextRenderExpirationTime);
                                {
                                    ReactDebugCurrentFiber.resetCurrentFiber();
                                }
                                var returnFiber = workInProgress["return"];
                                var siblingFiber = workInProgress.sibling;
                                resetExpirationTime(workInProgress, nextRenderExpirationTime);
                                if (next !== null) {
                                    stopWorkTimer(workInProgress);
                                    if (true && ReactFiberInstrumentation_1.debugTool) {
                                        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
                                    }
                                    return next;
                                }
                                if (returnFiber !== null) {
                                    if (returnFiber.firstEffect === null) {
                                        returnFiber.firstEffect = workInProgress.firstEffect;
                                    }
                                    if (workInProgress.lastEffect !== null) {
                                        if (returnFiber.lastEffect !== null) {
                                            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
                                        }
                                        returnFiber.lastEffect = workInProgress.lastEffect;
                                    }
                                    var effectTag = workInProgress.effectTag;
                                    if (effectTag > PerformedWork) {
                                        if (returnFiber.lastEffect !== null) {
                                            returnFiber.lastEffect.nextEffect = workInProgress;
                                        } else {
                                            returnFiber.firstEffect = workInProgress;
                                        }
                                        returnFiber.lastEffect = workInProgress;
                                    }
                                }
                                stopWorkTimer(workInProgress);
                                if (true && ReactFiberInstrumentation_1.debugTool) {
                                    ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
                                }
                                if (siblingFiber !== null) {
                                    return siblingFiber;
                                } else if (returnFiber !== null) {
                                    workInProgress = returnFiber;
                                    continue;
                                } else {
                                    var root = workInProgress.stateNode;
                                    root.isReadyForCommit = true;
                                    return null;
                                }
                            }
                            return null;
                        }
                        function performUnitOfWork(workInProgress) {
                            var current = workInProgress.alternate;
                            startWorkTimer(workInProgress);
                            {
                                ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
                            }
                            var next = beginWork(current, workInProgress, nextRenderExpirationTime);
                            {
                                ReactDebugCurrentFiber.resetCurrentFiber();
                            }
                            if (true && ReactFiberInstrumentation_1.debugTool) {
                                ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
                            }
                            if (next === null) {
                                next = completeUnitOfWork(workInProgress);
                            }
                            ReactCurrentOwner.current = null;
                            return next;
                        }
                        function performFailedUnitOfWork(workInProgress) {
                            var current = workInProgress.alternate;
                            startWorkTimer(workInProgress);
                            {
                                ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
                            }
                            var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);
                            {
                                ReactDebugCurrentFiber.resetCurrentFiber();
                            }
                            if (true && ReactFiberInstrumentation_1.debugTool) {
                                ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
                            }
                            if (next === null) {
                                next = completeUnitOfWork(workInProgress);
                            }
                            ReactCurrentOwner.current = null;
                            return next;
                        }
                        function workLoop(expirationTime) {
                            if (capturedErrors !== null) {
                                slowWorkLoopThatChecksForFailedWork(expirationTime);
                                return;
                            }
                            if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
                                return;
                            }
                            if (nextRenderExpirationTime <= mostRecentCurrentTime) {
                                while (nextUnitOfWork !== null) {
                                    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
                                }
                            } else {
                                while (nextUnitOfWork !== null && !shouldYield()) {
                                    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
                                }
                            }
                        }
                        function slowWorkLoopThatChecksForFailedWork(expirationTime) {
                            if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
                                return;
                            }
                            if (nextRenderExpirationTime <= mostRecentCurrentTime) {
                                while (nextUnitOfWork !== null) {
                                    if (hasCapturedError(nextUnitOfWork)) {
                                        nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
                                    } else {
                                        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
                                    }
                                }
                            } else {
                                while (nextUnitOfWork !== null && !shouldYield()) {
                                    if (hasCapturedError(nextUnitOfWork)) {
                                        nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
                                    } else {
                                        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
                                    }
                                }
                            }
                        }
                        function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {
                            unwindContexts(failedWork, boundary);
                            nextUnitOfWork = performFailedUnitOfWork(boundary);
                            workLoop(expirationTime);
                        }
                        function renderRoot(root, expirationTime) {
                            !!isWorking ? invariant(false, "renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            isWorking = true;
                            root.isReadyForCommit = false;
                            if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {
                                resetContextStack();
                                nextRoot = root;
                                nextRenderExpirationTime = expirationTime;
                                nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
                            }
                            startWorkLoopTimer(nextUnitOfWork);
                            var didError = false;
                            var error = null;
                            {
                                invokeGuardedCallback$1(null, workLoop, null, expirationTime);
                                if (hasCaughtError()) {
                                    didError = true;
                                    error = clearCaughtError();
                                }
                            }
                            while (didError) {
                                if (didFatal) {
                                    firstUncaughtError = error;
                                    break;
                                }
                                var failedWork = nextUnitOfWork;
                                if (failedWork === null) {
                                    didFatal = true;
                                    continue;
                                }
                                var boundary = captureError(failedWork, error);
                                !(boundary !== null) ? invariant(false, "Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                                if (didFatal) {
                                    continue;
                                }
                                didError = false;
                                error = null;
                                {
                                    invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);
                                    if (hasCaughtError()) {
                                        didError = true;
                                        error = clearCaughtError();
                                        continue;
                                    }
                                }
                                break;
                            }
                            var uncaughtError = firstUncaughtError;
                            stopWorkLoopTimer(interruptedBy);
                            interruptedBy = null;
                            isWorking = false;
                            didFatal = false;
                            firstUncaughtError = null;
                            if (uncaughtError !== null) {
                                onUncaughtError(uncaughtError);
                            }
                            return root.isReadyForCommit ? root.current.alternate : null;
                        }
                        function captureError(failedWork, error) {
                            ReactCurrentOwner.current = null;
                            {
                                ReactDebugCurrentFiber.resetCurrentFiber();
                            }
                            var boundary = null;
                            var errorBoundaryFound = false;
                            var willRetry = false;
                            var errorBoundaryName = null;
                            if (failedWork.tag === HostRoot) {
                                boundary = failedWork;
                                if (isFailedBoundary(failedWork)) {
                                    didFatal = true;
                                }
                            } else {
                                var node = failedWork["return"];
                                while (node !== null && boundary === null) {
                                    if (node.tag === ClassComponent) {
                                        var instance = node.stateNode;
                                        if (typeof instance.componentDidCatch === "function") {
                                            errorBoundaryFound = true;
                                            errorBoundaryName = getComponentName(node);
                                            boundary = node;
                                            willRetry = true;
                                        }
                                    } else if (node.tag === HostRoot) {
                                        boundary = node;
                                    }
                                    if (isFailedBoundary(node)) {
                                        if (isUnmounting) {
                                            return null;
                                        }
                                        if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {
                                            return null;
                                        }
                                        boundary = null;
                                        willRetry = false;
                                    }
                                    node = node["return"];
                                }
                            }
                            if (boundary !== null) {
                                if (failedBoundaries === null) {
                                    failedBoundaries = new Set();
                                }
                                failedBoundaries.add(boundary);
                                var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);
                                var _componentName = getComponentName(failedWork);
                                if (capturedErrors === null) {
                                    capturedErrors = new Map();
                                }
                                var capturedError = {
                                    componentName: _componentName,
                                    componentStack: _componentStack,
                                    error: error,
                                    errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
                                    errorBoundaryFound: errorBoundaryFound,
                                    errorBoundaryName: errorBoundaryName,
                                    willRetry: willRetry
                                };
                                capturedErrors.set(boundary, capturedError);
                                try {
                                    logCapturedError(capturedError);
                                } catch (e) {
                                    var suppressLogging = e && e.suppressReactErrorLogging;
                                    if (!suppressLogging) {
                                        console.error(e);
                                    }
                                }
                                if (isCommitting) {
                                    if (commitPhaseBoundaries === null) {
                                        commitPhaseBoundaries = new Set();
                                    }
                                    commitPhaseBoundaries.add(boundary);
                                } else {
                                    scheduleErrorRecovery(boundary);
                                }
                                return boundary;
                            } else if (firstUncaughtError === null) {
                                firstUncaughtError = error;
                            }
                            return null;
                        }
                        function hasCapturedError(fiber) {
                            return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));
                        }
                        function isFailedBoundary(fiber) {
                            return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));
                        }
                        function commitErrorHandling(effectfulFiber) {
                            var capturedError = void 0;
                            if (capturedErrors !== null) {
                                capturedError = capturedErrors.get(effectfulFiber);
                                capturedErrors["delete"](effectfulFiber);
                                if (capturedError == null) {
                                    if (effectfulFiber.alternate !== null) {
                                        effectfulFiber = effectfulFiber.alternate;
                                        capturedError = capturedErrors.get(effectfulFiber);
                                        capturedErrors["delete"](effectfulFiber);
                                    }
                                }
                            }
                            !(capturedError != null) ? invariant(false, "No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            switch (effectfulFiber.tag) {
                              case ClassComponent:
                                var instance = effectfulFiber.stateNode;
                                var info = {
                                    componentStack: capturedError.componentStack
                                };
                                instance.componentDidCatch(capturedError.error, info);
                                return;

                              case HostRoot:
                                if (firstUncaughtError === null) {
                                    firstUncaughtError = capturedError.error;
                                }
                                return;

                              default:
                                invariant(false, "Invalid type of work. This error is likely caused by a bug in React. Please file an issue.");
                            }
                        }
                        function unwindContexts(from, to) {
                            var node = from;
                            while (node !== null) {
                                switch (node.tag) {
                                  case ClassComponent:
                                    popContextProvider(node);
                                    break;

                                  case HostComponent:
                                    popHostContext(node);
                                    break;

                                  case HostRoot:
                                    popHostContainer(node);
                                    break;

                                  case HostPortal:
                                    popHostContainer(node);
                                    break;
                                }
                                if (node === to || node.alternate === to) {
                                    stopFailedWorkTimer(node);
                                    break;
                                } else {
                                    stopWorkTimer(node);
                                }
                                node = node["return"];
                            }
                        }
                        function computeAsyncExpiration() {
                            var currentTime = recalculateCurrentTime();
                            var expirationMs = 1e3;
                            var bucketSizeMs = 200;
                            return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
                        }
                        function computeExpirationForFiber(fiber) {
                            var expirationTime = void 0;
                            if (expirationContext !== NoWork) {
                                expirationTime = expirationContext;
                            } else if (isWorking) {
                                if (isCommitting) {
                                    expirationTime = Sync;
                                } else {
                                    expirationTime = nextRenderExpirationTime;
                                }
                            } else {
                                if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {
                                    expirationTime = Sync;
                                } else {
                                    expirationTime = computeAsyncExpiration();
                                }
                            }
                            return expirationTime;
                        }
                        function scheduleWork(fiber, expirationTime) {
                            return scheduleWorkImpl(fiber, expirationTime, false);
                        }
                        function checkRootNeedsClearing(root, fiber, expirationTime) {
                            if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {
                                if (nextUnitOfWork !== null) {
                                    interruptedBy = fiber;
                                }
                                nextRoot = null;
                                nextUnitOfWork = null;
                                nextRenderExpirationTime = NoWork;
                            }
                        }
                        function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {
                            recordScheduleUpdate();
                            {
                                if (!isErrorRecovery && fiber.tag === ClassComponent) {
                                    var instance = fiber.stateNode;
                                    warnAboutInvalidUpdates(instance);
                                }
                            }
                            var node = fiber;
                            while (node !== null) {
                                if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {
                                    node.expirationTime = expirationTime;
                                }
                                if (node.alternate !== null) {
                                    if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {
                                        node.alternate.expirationTime = expirationTime;
                                    }
                                }
                                if (node["return"] === null) {
                                    if (node.tag === HostRoot) {
                                        var root = node.stateNode;
                                        checkRootNeedsClearing(root, fiber, expirationTime);
                                        requestWork(root, expirationTime);
                                        checkRootNeedsClearing(root, fiber, expirationTime);
                                    } else {
                                        {
                                            if (!isErrorRecovery && fiber.tag === ClassComponent) {
                                                warnAboutUpdateOnUnmounted(fiber);
                                            }
                                        }
                                        return;
                                    }
                                }
                                node = node["return"];
                            }
                        }
                        function scheduleErrorRecovery(fiber) {
                            scheduleWorkImpl(fiber, Sync, true);
                        }
                        function recalculateCurrentTime() {
                            var ms = now() - startTime;
                            mostRecentCurrentTime = msToExpirationTime(ms);
                            return mostRecentCurrentTime;
                        }
                        function deferredUpdates(fn) {
                            var previousExpirationContext = expirationContext;
                            expirationContext = computeAsyncExpiration();
                            try {
                                return fn();
                            } finally {
                                expirationContext = previousExpirationContext;
                            }
                        }
                        function syncUpdates(fn) {
                            var previousExpirationContext = expirationContext;
                            expirationContext = Sync;
                            try {
                                return fn();
                            } finally {
                                expirationContext = previousExpirationContext;
                            }
                        }
                        var firstScheduledRoot = null;
                        var lastScheduledRoot = null;
                        var callbackExpirationTime = NoWork;
                        var callbackID = -1;
                        var isRendering = false;
                        var nextFlushedRoot = null;
                        var nextFlushedExpirationTime = NoWork;
                        var deadlineDidExpire = false;
                        var hasUnhandledError = false;
                        var unhandledError = null;
                        var deadline = null;
                        var isBatchingUpdates = false;
                        var isUnbatchingUpdates = false;
                        var NESTED_UPDATE_LIMIT = 1e3;
                        var nestedUpdateCount = 0;
                        var timeHeuristicForUnitOfWork = 1;
                        function scheduleCallbackWithExpiration(expirationTime) {
                            if (callbackExpirationTime !== NoWork) {
                                if (expirationTime > callbackExpirationTime) {
                                    return;
                                } else {
                                    cancelDeferredCallback(callbackID);
                                }
                            } else {
                                startRequestCallbackTimer();
                            }
                            var currentMs = now() - startTime;
                            var expirationMs = expirationTimeToMs(expirationTime);
                            var timeout = expirationMs - currentMs;
                            callbackExpirationTime = expirationTime;
                            callbackID = scheduleDeferredCallback(performAsyncWork, {
                                timeout: timeout
                            });
                        }
                        function requestWork(root, expirationTime) {
                            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
                                invariant(false, "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
                            }
                            if (root.nextScheduledRoot === null) {
                                root.remainingExpirationTime = expirationTime;
                                if (lastScheduledRoot === null) {
                                    firstScheduledRoot = lastScheduledRoot = root;
                                    root.nextScheduledRoot = root;
                                } else {
                                    lastScheduledRoot.nextScheduledRoot = root;
                                    lastScheduledRoot = root;
                                    lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
                                }
                            } else {
                                var remainingExpirationTime = root.remainingExpirationTime;
                                if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
                                    root.remainingExpirationTime = expirationTime;
                                }
                            }
                            if (isRendering) {
                                return;
                            }
                            if (isBatchingUpdates) {
                                if (isUnbatchingUpdates) {
                                    nextFlushedRoot = root;
                                    nextFlushedExpirationTime = Sync;
                                    performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
                                }
                                return;
                            }
                            if (expirationTime === Sync) {
                                performWork(Sync, null);
                            } else {
                                scheduleCallbackWithExpiration(expirationTime);
                            }
                        }
                        function findHighestPriorityRoot() {
                            var highestPriorityWork = NoWork;
                            var highestPriorityRoot = null;
                            if (lastScheduledRoot !== null) {
                                var previousScheduledRoot = lastScheduledRoot;
                                var root = firstScheduledRoot;
                                while (root !== null) {
                                    var remainingExpirationTime = root.remainingExpirationTime;
                                    if (remainingExpirationTime === NoWork) {
                                        !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, "Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                                        if (root === root.nextScheduledRoot) {
                                            root.nextScheduledRoot = null;
                                            firstScheduledRoot = lastScheduledRoot = null;
                                            break;
                                        } else if (root === firstScheduledRoot) {
                                            var next = root.nextScheduledRoot;
                                            firstScheduledRoot = next;
                                            lastScheduledRoot.nextScheduledRoot = next;
                                            root.nextScheduledRoot = null;
                                        } else if (root === lastScheduledRoot) {
                                            lastScheduledRoot = previousScheduledRoot;
                                            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
                                            root.nextScheduledRoot = null;
                                            break;
                                        } else {
                                            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
                                            root.nextScheduledRoot = null;
                                        }
                                        root = previousScheduledRoot.nextScheduledRoot;
                                    } else {
                                        if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
                                            highestPriorityWork = remainingExpirationTime;
                                            highestPriorityRoot = root;
                                        }
                                        if (root === lastScheduledRoot) {
                                            break;
                                        }
                                        previousScheduledRoot = root;
                                        root = root.nextScheduledRoot;
                                    }
                                }
                            }
                            var previousFlushedRoot = nextFlushedRoot;
                            if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {
                                nestedUpdateCount++;
                            } else {
                                nestedUpdateCount = 0;
                            }
                            nextFlushedRoot = highestPriorityRoot;
                            nextFlushedExpirationTime = highestPriorityWork;
                        }
                        function performAsyncWork(dl) {
                            performWork(NoWork, dl);
                        }
                        function performWork(minExpirationTime, dl) {
                            deadline = dl;
                            findHighestPriorityRoot();
                            if (enableUserTimingAPI && deadline !== null) {
                                var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();
                                stopRequestCallbackTimer(didExpire);
                            }
                            while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {
                                performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
                                findHighestPriorityRoot();
                            }
                            if (deadline !== null) {
                                callbackExpirationTime = NoWork;
                                callbackID = -1;
                            }
                            if (nextFlushedExpirationTime !== NoWork) {
                                scheduleCallbackWithExpiration(nextFlushedExpirationTime);
                            }
                            deadline = null;
                            deadlineDidExpire = false;
                            nestedUpdateCount = 0;
                            if (hasUnhandledError) {
                                var _error4 = unhandledError;
                                unhandledError = null;
                                hasUnhandledError = false;
                                throw _error4;
                            }
                        }
                        function performWorkOnRoot(root, expirationTime) {
                            !!isRendering ? invariant(false, "performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            isRendering = true;
                            if (expirationTime <= recalculateCurrentTime()) {
                                var finishedWork = root.finishedWork;
                                if (finishedWork !== null) {
                                    root.finishedWork = null;
                                    root.remainingExpirationTime = commitRoot(finishedWork);
                                } else {
                                    root.finishedWork = null;
                                    finishedWork = renderRoot(root, expirationTime);
                                    if (finishedWork !== null) {
                                        root.remainingExpirationTime = commitRoot(finishedWork);
                                    }
                                }
                            } else {
                                var _finishedWork = root.finishedWork;
                                if (_finishedWork !== null) {
                                    root.finishedWork = null;
                                    root.remainingExpirationTime = commitRoot(_finishedWork);
                                } else {
                                    root.finishedWork = null;
                                    _finishedWork = renderRoot(root, expirationTime);
                                    if (_finishedWork !== null) {
                                        if (!shouldYield()) {
                                            root.remainingExpirationTime = commitRoot(_finishedWork);
                                        } else {
                                            root.finishedWork = _finishedWork;
                                        }
                                    }
                                }
                            }
                            isRendering = false;
                        }
                        function shouldYield() {
                            if (deadline === null) {
                                return false;
                            }
                            if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
                                return false;
                            }
                            deadlineDidExpire = true;
                            return true;
                        }
                        function onUncaughtError(error) {
                            !(nextFlushedRoot !== null) ? invariant(false, "Should be working on a root. This error is likely caused by a bug in React. Please file an issue.") : void 0;
                            nextFlushedRoot.remainingExpirationTime = NoWork;
                            if (!hasUnhandledError) {
                                hasUnhandledError = true;
                                unhandledError = error;
                            }
                        }
                        function batchedUpdates(fn, a) {
                            var previousIsBatchingUpdates = isBatchingUpdates;
                            isBatchingUpdates = true;
                            try {
                                return fn(a);
                            } finally {
                                isBatchingUpdates = previousIsBatchingUpdates;
                                if (!isBatchingUpdates && !isRendering) {
                                    performWork(Sync, null);
                                }
                            }
                        }
                        function unbatchedUpdates(fn) {
                            if (isBatchingUpdates && !isUnbatchingUpdates) {
                                isUnbatchingUpdates = true;
                                try {
                                    return fn();
                                } finally {
                                    isUnbatchingUpdates = false;
                                }
                            }
                            return fn();
                        }
                        function flushSync(fn) {
                            var previousIsBatchingUpdates = isBatchingUpdates;
                            isBatchingUpdates = true;
                            try {
                                return syncUpdates(fn);
                            } finally {
                                isBatchingUpdates = previousIsBatchingUpdates;
                                !!isRendering ? invariant(false, "flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.") : void 0;
                                performWork(Sync, null);
                            }
                        }
                        return {
                            computeAsyncExpiration: computeAsyncExpiration,
                            computeExpirationForFiber: computeExpirationForFiber,
                            scheduleWork: scheduleWork,
                            batchedUpdates: batchedUpdates,
                            unbatchedUpdates: unbatchedUpdates,
                            flushSync: flushSync,
                            deferredUpdates: deferredUpdates
                        };
                    };
                    {
                        var didWarnAboutNestedUpdates = false;
                    }
                    function getContextForSubtree(parentComponent) {
                        if (!parentComponent) {
                            return emptyObject;
                        }
                        var fiber = get(parentComponent);
                        var parentContext = findCurrentUnmaskedContext(fiber);
                        return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;
                    }
                    var ReactFiberReconciler$1 = function(config) {
                        var getPublicInstance = config.getPublicInstance;
                        var _ReactFiberScheduler = ReactFiberScheduler(config), computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration, computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber, scheduleWork = _ReactFiberScheduler.scheduleWork, batchedUpdates = _ReactFiberScheduler.batchedUpdates, unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates, flushSync = _ReactFiberScheduler.flushSync, deferredUpdates = _ReactFiberScheduler.deferredUpdates;
                        function scheduleTopLevelUpdate(current, element, callback) {
                            {
                                if (ReactDebugCurrentFiber.phase === "render" && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
                                    didWarnAboutNestedUpdates = true;
                                    warning(false, "Render methods should be a pure function of props and state; " + "triggering nested component updates from render is not allowed. " + "If necessary, trigger nested updates in componentDidUpdate.\n\n" + "Check the render method of %s.", getComponentName(ReactDebugCurrentFiber.current) || "Unknown");
                                }
                            }
                            callback = callback === undefined ? null : callback;
                            {
                                warning(callback === null || typeof callback === "function", "render(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callback);
                            }
                            var expirationTime = void 0;
                            if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {
                                expirationTime = computeAsyncExpiration();
                            } else {
                                expirationTime = computeExpirationForFiber(current);
                            }
                            var update = {
                                expirationTime: expirationTime,
                                partialState: {
                                    element: element
                                },
                                callback: callback,
                                isReplace: false,
                                isForced: false,
                                nextCallback: null,
                                next: null
                            };
                            insertUpdateIntoFiber(current, update);
                            scheduleWork(current, expirationTime);
                        }
                        function findHostInstance(fiber) {
                            var hostFiber = findCurrentHostFiber(fiber);
                            if (hostFiber === null) {
                                return null;
                            }
                            return hostFiber.stateNode;
                        }
                        return {
                            createContainer: function(containerInfo, hydrate) {
                                return createFiberRoot(containerInfo, hydrate);
                            },
                            updateContainer: function(element, container, parentComponent, callback) {
                                var current = container.current;
                                {
                                    if (ReactFiberInstrumentation_1.debugTool) {
                                        if (current.alternate === null) {
                                            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
                                        } else if (element === null) {
                                            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
                                        } else {
                                            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
                                        }
                                    }
                                }
                                var context = getContextForSubtree(parentComponent);
                                if (container.context === null) {
                                    container.context = context;
                                } else {
                                    container.pendingContext = context;
                                }
                                scheduleTopLevelUpdate(current, element, callback);
                            },
                            batchedUpdates: batchedUpdates,
                            unbatchedUpdates: unbatchedUpdates,
                            deferredUpdates: deferredUpdates,
                            flushSync: flushSync,
                            getPublicRootInstance: function(container) {
                                var containerFiber = container.current;
                                if (!containerFiber.child) {
                                    return null;
                                }
                                switch (containerFiber.child.tag) {
                                  case HostComponent:
                                    return getPublicInstance(containerFiber.child.stateNode);

                                  default:
                                    return containerFiber.child.stateNode;
                                }
                            },
                            findHostInstance: findHostInstance,
                            findHostInstanceWithNoPortals: function(fiber) {
                                var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
                                if (hostFiber === null) {
                                    return null;
                                }
                                return hostFiber.stateNode;
                            },
                            injectIntoDevTools: function(devToolsConfig) {
                                var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
                                return injectInternals(_assign({}, devToolsConfig, {
                                    findHostInstanceByFiber: function(fiber) {
                                        return findHostInstance(fiber);
                                    },
                                    findFiberByHostInstance: function(instance) {
                                        if (!findFiberByHostInstance) {
                                            return null;
                                        }
                                        return findFiberByHostInstance(instance);
                                    }
                                }));
                            }
                        };
                    };
                    var ReactFiberReconciler$2 = Object.freeze({
                        default: ReactFiberReconciler$1
                    });
                    var ReactFiberReconciler$3 = ReactFiberReconciler$2 && ReactFiberReconciler$1 || ReactFiberReconciler$2;
                    var reactReconciler = ReactFiberReconciler$3["default"] ? ReactFiberReconciler$3["default"] : ReactFiberReconciler$3;
                    function createPortal$1(children, containerInfo, implementation) {
                        var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                        return {
                            $$typeof: REACT_PORTAL_TYPE,
                            key: key == null ? null : "" + key,
                            children: children,
                            containerInfo: containerInfo,
                            implementation: implementation
                        };
                    }
                    var ReactVersion = "16.2.0";
                    {
                        if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== "function") {
                            warning(false, "React depends on requestAnimationFrame. Make sure that you load a " + "polyfill in older browsers. http://fb.me/react-polyfills");
                        }
                    }
                    var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
                    var now = void 0;
                    if (hasNativePerformanceNow) {
                        now = function() {
                            return performance.now();
                        };
                    } else {
                        now = function() {
                            return Date.now();
                        };
                    }
                    var rIC = void 0;
                    var cIC = void 0;
                    if (!ExecutionEnvironment.canUseDOM) {
                        rIC = function(frameCallback) {
                            return setTimeout(function() {
                                frameCallback({
                                    timeRemaining: function() {
                                        return Infinity;
                                    }
                                });
                            });
                        };
                        cIC = function(timeoutID) {
                            clearTimeout(timeoutID);
                        };
                    } else if (typeof requestIdleCallback !== "function" || typeof cancelIdleCallback !== "function") {
                        var scheduledRICCallback = null;
                        var isIdleScheduled = false;
                        var timeoutTime = -1;
                        var isAnimationFrameScheduled = false;
                        var frameDeadline = 0;
                        var previousFrameTime = 33;
                        var activeFrameTime = 33;
                        var frameDeadlineObject;
                        if (hasNativePerformanceNow) {
                            frameDeadlineObject = {
                                didTimeout: false,
                                timeRemaining: function() {
                                    var remaining = frameDeadline - performance.now();
                                    return remaining > 0 ? remaining : 0;
                                }
                            };
                        } else {
                            frameDeadlineObject = {
                                didTimeout: false,
                                timeRemaining: function() {
                                    var remaining = frameDeadline - Date.now();
                                    return remaining > 0 ? remaining : 0;
                                }
                            };
                        }
                        var messageKey = "__reactIdleCallback$" + Math.random().toString(36).slice(2);
                        var idleTick = function(event) {
                            if (event.source !== window || event.data !== messageKey) {
                                return;
                            }
                            isIdleScheduled = false;
                            var currentTime = now();
                            if (frameDeadline - currentTime <= 0) {
                                if (timeoutTime !== -1 && timeoutTime <= currentTime) {
                                    frameDeadlineObject.didTimeout = true;
                                } else {
                                    if (!isAnimationFrameScheduled) {
                                        isAnimationFrameScheduled = true;
                                        requestAnimationFrame(animationTick);
                                    }
                                    return;
                                }
                            } else {
                                frameDeadlineObject.didTimeout = false;
                            }
                            timeoutTime = -1;
                            var callback = scheduledRICCallback;
                            scheduledRICCallback = null;
                            if (callback !== null) {
                                callback(frameDeadlineObject);
                            }
                        };
                        window.addEventListener("message", idleTick, false);
                        var animationTick = function(rafTime) {
                            isAnimationFrameScheduled = false;
                            var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
                            if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
                                if (nextFrameTime < 8) {
                                    nextFrameTime = 8;
                                }
                                activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
                            } else {
                                previousFrameTime = nextFrameTime;
                            }
                            frameDeadline = rafTime + activeFrameTime;
                            if (!isIdleScheduled) {
                                isIdleScheduled = true;
                                window.postMessage(messageKey, "*");
                            }
                        };
                        rIC = function(callback, options) {
                            scheduledRICCallback = callback;
                            if (options != null && typeof options.timeout === "number") {
                                timeoutTime = now() + options.timeout;
                            }
                            if (!isAnimationFrameScheduled) {
                                isAnimationFrameScheduled = true;
                                requestAnimationFrame(animationTick);
                            }
                            return 0;
                        };
                        cIC = function() {
                            scheduledRICCallback = null;
                            isIdleScheduled = false;
                            timeoutTime = -1;
                        };
                    } else {
                        rIC = window.requestIdleCallback;
                        cIC = window.cancelIdleCallback;
                    }
                    var lowPriorityWarning = function() {};
                    {
                        var printWarning = function(format) {
                            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                args[_key - 1] = arguments[_key];
                            }
                            var argIndex = 0;
                            var message = "Warning: " + format.replace(/%s/g, function() {
                                return args[argIndex++];
                            });
                            if (typeof console !== "undefined") {
                                console.warn(message);
                            }
                            try {
                                throw new Error(message);
                            } catch (x) {}
                        };
                        lowPriorityWarning = function(condition, format) {
                            if (format === undefined) {
                                throw new Error("`warning(condition, format, ...args)` requires a warning " + "message argument");
                            }
                            if (!condition) {
                                for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                                    args[_key2 - 2] = arguments[_key2];
                                }
                                printWarning.apply(undefined, [ format ].concat(args));
                            }
                        };
                    }
                    var lowPriorityWarning$1 = lowPriorityWarning;
                    var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
                    var illegalAttributeNameCache = {};
                    var validatedAttributeNameCache = {};
                    function isAttributeNameSafe(attributeName) {
                        if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
                            return true;
                        }
                        if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
                            return false;
                        }
                        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
                            validatedAttributeNameCache[attributeName] = true;
                            return true;
                        }
                        illegalAttributeNameCache[attributeName] = true;
                        {
                            warning(false, "Invalid attribute name: `%s`", attributeName);
                        }
                        return false;
                    }
                    function shouldIgnoreValue(propertyInfo, value) {
                        return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
                    }
                    function getValueForProperty(node, name, expected) {
                        {
                            var propertyInfo = getPropertyInfo(name);
                            if (propertyInfo) {
                                var mutationMethod = propertyInfo.mutationMethod;
                                if (mutationMethod || propertyInfo.mustUseProperty) {
                                    return node[propertyInfo.propertyName];
                                } else {
                                    var attributeName = propertyInfo.attributeName;
                                    var stringValue = null;
                                    if (propertyInfo.hasOverloadedBooleanValue) {
                                        if (node.hasAttribute(attributeName)) {
                                            var value = node.getAttribute(attributeName);
                                            if (value === "") {
                                                return true;
                                            }
                                            if (shouldIgnoreValue(propertyInfo, expected)) {
                                                return value;
                                            }
                                            if (value === "" + expected) {
                                                return expected;
                                            }
                                            return value;
                                        }
                                    } else if (node.hasAttribute(attributeName)) {
                                        if (shouldIgnoreValue(propertyInfo, expected)) {
                                            return node.getAttribute(attributeName);
                                        }
                                        if (propertyInfo.hasBooleanValue) {
                                            return expected;
                                        }
                                        stringValue = node.getAttribute(attributeName);
                                    }
                                    if (shouldIgnoreValue(propertyInfo, expected)) {
                                        return stringValue === null ? expected : stringValue;
                                    } else if (stringValue === "" + expected) {
                                        return expected;
                                    } else {
                                        return stringValue;
                                    }
                                }
                            }
                        }
                    }
                    function getValueForAttribute(node, name, expected) {
                        {
                            if (!isAttributeNameSafe(name)) {
                                return;
                            }
                            if (!node.hasAttribute(name)) {
                                return expected === undefined ? undefined : null;
                            }
                            var value = node.getAttribute(name);
                            if (value === "" + expected) {
                                return expected;
                            }
                            return value;
                        }
                    }
                    function setValueForProperty(node, name, value) {
                        var propertyInfo = getPropertyInfo(name);
                        if (propertyInfo && shouldSetAttribute(name, value)) {
                            var mutationMethod = propertyInfo.mutationMethod;
                            if (mutationMethod) {
                                mutationMethod(node, value);
                            } else if (shouldIgnoreValue(propertyInfo, value)) {
                                deleteValueForProperty(node, name);
                                return;
                            } else if (propertyInfo.mustUseProperty) {
                                node[propertyInfo.propertyName] = value;
                            } else {
                                var attributeName = propertyInfo.attributeName;
                                var namespace = propertyInfo.attributeNamespace;
                                if (namespace) {
                                    node.setAttributeNS(namespace, attributeName, "" + value);
                                } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
                                    node.setAttribute(attributeName, "");
                                } else {
                                    node.setAttribute(attributeName, "" + value);
                                }
                            }
                        } else {
                            setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);
                            return;
                        }
                        {}
                    }
                    function setValueForAttribute(node, name, value) {
                        if (!isAttributeNameSafe(name)) {
                            return;
                        }
                        if (value == null) {
                            node.removeAttribute(name);
                        } else {
                            node.setAttribute(name, "" + value);
                        }
                        {}
                    }
                    function deleteValueForAttribute(node, name) {
                        node.removeAttribute(name);
                    }
                    function deleteValueForProperty(node, name) {
                        var propertyInfo = getPropertyInfo(name);
                        if (propertyInfo) {
                            var mutationMethod = propertyInfo.mutationMethod;
                            if (mutationMethod) {
                                mutationMethod(node, undefined);
                            } else if (propertyInfo.mustUseProperty) {
                                var propName = propertyInfo.propertyName;
                                if (propertyInfo.hasBooleanValue) {
                                    node[propName] = false;
                                } else {
                                    node[propName] = "";
                                }
                            } else {
                                node.removeAttribute(propertyInfo.attributeName);
                            }
                        } else {
                            node.removeAttribute(name);
                        }
                    }
                    var ReactControlledValuePropTypes = {
                        checkPropTypes: null
                    };
                    {
                        var hasReadOnlyValue = {
                            button: true,
                            checkbox: true,
                            image: true,
                            hidden: true,
                            radio: true,
                            reset: true,
                            submit: true
                        };
                        var propTypes = {
                            value: function(props, propName, componentName) {
                                if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
                                    return null;
                                }
                                return new Error("You provided a `value` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultValue`. Otherwise, " + "set either `onChange` or `readOnly`.");
                            },
                            checked: function(props, propName, componentName) {
                                if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
                                    return null;
                                }
                                return new Error("You provided a `checked` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultChecked`. Otherwise, " + "set either `onChange` or `readOnly`.");
                            }
                        };
                        ReactControlledValuePropTypes.checkPropTypes = function(tagName, props, getStack) {
                            checkPropTypes(propTypes, props, "prop", tagName, getStack);
                        };
                    }
                    var getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
                    var getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
                    var didWarnValueDefaultValue = false;
                    var didWarnCheckedDefaultChecked = false;
                    var didWarnControlledToUncontrolled = false;
                    var didWarnUncontrolledToControlled = false;
                    function isControlled(props) {
                        var usesChecked = props.type === "checkbox" || props.type === "radio";
                        return usesChecked ? props.checked != null : props.value != null;
                    }
                    function getHostProps(element, props) {
                        var node = element;
                        var value = props.value;
                        var checked = props.checked;
                        var hostProps = _assign({
                            type: undefined,
                            step: undefined,
                            min: undefined,
                            max: undefined
                        }, props, {
                            defaultChecked: undefined,
                            defaultValue: undefined,
                            value: value != null ? value : node._wrapperState.initialValue,
                            checked: checked != null ? checked : node._wrapperState.initialChecked
                        });
                        return hostProps;
                    }
                    function initWrapperState(element, props) {
                        {
                            ReactControlledValuePropTypes.checkPropTypes("input", props, getCurrentFiberStackAddendum$3);
                            if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
                                warning(false, "%s contains an input of type %s with both checked and defaultChecked props. " + "Input elements must be either controlled or uncontrolled " + "(specify either the checked prop, or the defaultChecked prop, but not " + "both). Decide between using a controlled or uncontrolled input " + "element and remove one of these props. More info: " + "https://fb.me/react-controlled-components", getCurrentFiberOwnerName$2() || "A component", props.type);
                                didWarnCheckedDefaultChecked = true;
                            }
                            if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
                                warning(false, "%s contains an input of type %s with both value and defaultValue props. " + "Input elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled input " + "element and remove one of these props. More info: " + "https://fb.me/react-controlled-components", getCurrentFiberOwnerName$2() || "A component", props.type);
                                didWarnValueDefaultValue = true;
                            }
                        }
                        var defaultValue = props.defaultValue;
                        var node = element;
                        node._wrapperState = {
                            initialChecked: props.checked != null ? props.checked : props.defaultChecked,
                            initialValue: props.value != null ? props.value : defaultValue,
                            controlled: isControlled(props)
                        };
                    }
                    function updateChecked(element, props) {
                        var node = element;
                        var checked = props.checked;
                        if (checked != null) {
                            setValueForProperty(node, "checked", checked);
                        }
                    }
                    function updateWrapper(element, props) {
                        var node = element;
                        {
                            var controlled = isControlled(props);
                            if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                                warning(false, "A component is changing an uncontrolled input of type %s to be controlled. " + "Input elements should not switch from uncontrolled to controlled (or vice versa). " + "Decide between using a controlled or uncontrolled input " + "element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s", props.type, getCurrentFiberStackAddendum$3());
                                didWarnUncontrolledToControlled = true;
                            }
                            if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                                warning(false, "A component is changing a controlled input of type %s to be uncontrolled. " + "Input elements should not switch from controlled to uncontrolled (or vice versa). " + "Decide between using a controlled or uncontrolled input " + "element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s", props.type, getCurrentFiberStackAddendum$3());
                                didWarnControlledToUncontrolled = true;
                            }
                        }
                        updateChecked(element, props);
                        var value = props.value;
                        if (value != null) {
                            if (value === 0 && node.value === "") {
                                node.value = "0";
                            } else if (props.type === "number") {
                                var valueAsNumber = parseFloat(node.value) || 0;
                                if (value != valueAsNumber || value == valueAsNumber && node.value != value) {
                                    node.value = "" + value;
                                }
                            } else if (node.value !== "" + value) {
                                node.value = "" + value;
                            }
                        } else {
                            if (props.value == null && props.defaultValue != null) {
                                if (node.defaultValue !== "" + props.defaultValue) {
                                    node.defaultValue = "" + props.defaultValue;
                                }
                            }
                            if (props.checked == null && props.defaultChecked != null) {
                                node.defaultChecked = !!props.defaultChecked;
                            }
                        }
                    }
                    function postMountWrapper(element, props) {
                        var node = element;
                        switch (props.type) {
                          case "submit":
                          case "reset":
                            break;

                          case "color":
                          case "date":
                          case "datetime":
                          case "datetime-local":
                          case "month":
                          case "time":
                          case "week":
                            node.value = "";
                            node.value = node.defaultValue;
                            break;

                          default:
                            node.value = node.value;
                            break;
                        }
                        var name = node.name;
                        if (name !== "") {
                            node.name = "";
                        }
                        node.defaultChecked = !node.defaultChecked;
                        node.defaultChecked = !node.defaultChecked;
                        if (name !== "") {
                            node.name = name;
                        }
                    }
                    function restoreControlledState$1(element, props) {
                        var node = element;
                        updateWrapper(node, props);
                        updateNamedCousins(node, props);
                    }
                    function updateNamedCousins(rootNode, props) {
                        var name = props.name;
                        if (props.type === "radio" && name != null) {
                            var queryRoot = rootNode;
                            while (queryRoot.parentNode) {
                                queryRoot = queryRoot.parentNode;
                            }
                            var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
                            for (var i = 0; i < group.length; i++) {
                                var otherNode = group[i];
                                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                                    continue;
                                }
                                var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
                                !otherProps ? invariant(false, "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.") : void 0;
                                updateValueIfChanged(otherNode);
                                updateWrapper(otherNode, otherProps);
                            }
                        }
                    }
                    function flattenChildren(children) {
                        var content = "";
                        React.Children.forEach(children, function(child) {
                            if (child == null) {
                                return;
                            }
                            if (typeof child === "string" || typeof child === "number") {
                                content += child;
                            }
                        });
                        return content;
                    }
                    function validateProps(element, props) {
                        {
                            warning(props.selected == null, "Use the `defaultValue` or `value` props on <select> instead of " + "setting `selected` on <option>.");
                        }
                    }
                    function postMountWrapper$1(element, props) {
                        if (props.value != null) {
                            element.setAttribute("value", props.value);
                        }
                    }
                    function getHostProps$1(element, props) {
                        var hostProps = _assign({
                            children: undefined
                        }, props);
                        var content = flattenChildren(props.children);
                        if (content) {
                            hostProps.children = content;
                        }
                        return hostProps;
                    }
                    var getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
                    var getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
                    {
                        var didWarnValueDefaultValue$1 = false;
                    }
                    function getDeclarationErrorAddendum() {
                        var ownerName = getCurrentFiberOwnerName$3();
                        if (ownerName) {
                            return "\n\nCheck the render method of `" + ownerName + "`.";
                        }
                        return "";
                    }
                    var valuePropNames = [ "value", "defaultValue" ];
                    function checkSelectPropTypes(props) {
                        ReactControlledValuePropTypes.checkPropTypes("select", props, getCurrentFiberStackAddendum$4);
                        for (var i = 0; i < valuePropNames.length; i++) {
                            var propName = valuePropNames[i];
                            if (props[propName] == null) {
                                continue;
                            }
                            var isArray = Array.isArray(props[propName]);
                            if (props.multiple && !isArray) {
                                warning(false, "The `%s` prop supplied to <select> must be an array if " + "`multiple` is true.%s", propName, getDeclarationErrorAddendum());
                            } else if (!props.multiple && isArray) {
                                warning(false, "The `%s` prop supplied to <select> must be a scalar " + "value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                            }
                        }
                    }
                    function updateOptions(node, multiple, propValue, setDefaultSelected) {
                        var options = node.options;
                        if (multiple) {
                            var selectedValues = propValue;
                            var selectedValue = {};
                            for (var i = 0; i < selectedValues.length; i++) {
                                selectedValue["$" + selectedValues[i]] = true;
                            }
                            for (var _i = 0; _i < options.length; _i++) {
                                var selected = selectedValue.hasOwnProperty("$" + options[_i].value);
                                if (options[_i].selected !== selected) {
                                    options[_i].selected = selected;
                                }
                                if (selected && setDefaultSelected) {
                                    options[_i].defaultSelected = true;
                                }
                            }
                        } else {
                            var _selectedValue = "" + propValue;
                            var defaultSelected = null;
                            for (var _i2 = 0; _i2 < options.length; _i2++) {
                                if (options[_i2].value === _selectedValue) {
                                    options[_i2].selected = true;
                                    if (setDefaultSelected) {
                                        options[_i2].defaultSelected = true;
                                    }
                                    return;
                                }
                                if (defaultSelected === null && !options[_i2].disabled) {
                                    defaultSelected = options[_i2];
                                }
                            }
                            if (defaultSelected !== null) {
                                defaultSelected.selected = true;
                            }
                        }
                    }
                    function getHostProps$2(element, props) {
                        return _assign({}, props, {
                            value: undefined
                        });
                    }
                    function initWrapperState$1(element, props) {
                        var node = element;
                        {
                            checkSelectPropTypes(props);
                        }
                        var value = props.value;
                        node._wrapperState = {
                            initialValue: value != null ? value : props.defaultValue,
                            wasMultiple: !!props.multiple
                        };
                        {
                            if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
                                warning(false, "Select elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled select " + "element and remove one of these props. More info: " + "https://fb.me/react-controlled-components");
                                didWarnValueDefaultValue$1 = true;
                            }
                        }
                    }
                    function postMountWrapper$2(element, props) {
                        var node = element;
                        node.multiple = !!props.multiple;
                        var value = props.value;
                        if (value != null) {
                            updateOptions(node, !!props.multiple, value, false);
                        } else if (props.defaultValue != null) {
                            updateOptions(node, !!props.multiple, props.defaultValue, true);
                        }
                    }
                    function postUpdateWrapper(element, props) {
                        var node = element;
                        node._wrapperState.initialValue = undefined;
                        var wasMultiple = node._wrapperState.wasMultiple;
                        node._wrapperState.wasMultiple = !!props.multiple;
                        var value = props.value;
                        if (value != null) {
                            updateOptions(node, !!props.multiple, value, false);
                        } else if (wasMultiple !== !!props.multiple) {
                            if (props.defaultValue != null) {
                                updateOptions(node, !!props.multiple, props.defaultValue, true);
                            } else {
                                updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
                            }
                        }
                    }
                    function restoreControlledState$2(element, props) {
                        var node = element;
                        var value = props.value;
                        if (value != null) {
                            updateOptions(node, !!props.multiple, value, false);
                        }
                    }
                    var getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
                    var didWarnValDefaultVal = false;
                    function getHostProps$3(element, props) {
                        var node = element;
                        !(props.dangerouslySetInnerHTML == null) ? invariant(false, "`dangerouslySetInnerHTML` does not make sense on <textarea>.") : void 0;
                        var hostProps = _assign({}, props, {
                            value: undefined,
                            defaultValue: undefined,
                            children: "" + node._wrapperState.initialValue
                        });
                        return hostProps;
                    }
                    function initWrapperState$2(element, props) {
                        var node = element;
                        {
                            ReactControlledValuePropTypes.checkPropTypes("textarea", props, getCurrentFiberStackAddendum$5);
                            if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
                                warning(false, "Textarea elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled textarea " + "and remove one of these props. More info: " + "https://fb.me/react-controlled-components");
                                didWarnValDefaultVal = true;
                            }
                        }
                        var initialValue = props.value;
                        if (initialValue == null) {
                            var defaultValue = props.defaultValue;
                            var children = props.children;
                            if (children != null) {
                                {
                                    warning(false, "Use the `defaultValue` or `value` props instead of setting " + "children on <textarea>.");
                                }
                                !(defaultValue == null) ? invariant(false, "If you supply `defaultValue` on a <textarea>, do not pass children.") : void 0;
                                if (Array.isArray(children)) {
                                    !(children.length <= 1) ? invariant(false, "<textarea> can only have at most one child.") : void 0;
                                    children = children[0];
                                }
                                defaultValue = "" + children;
                            }
                            if (defaultValue == null) {
                                defaultValue = "";
                            }
                            initialValue = defaultValue;
                        }
                        node._wrapperState = {
                            initialValue: "" + initialValue
                        };
                    }
                    function updateWrapper$1(element, props) {
                        var node = element;
                        var value = props.value;
                        if (value != null) {
                            var newValue = "" + value;
                            if (newValue !== node.value) {
                                node.value = newValue;
                            }
                            if (props.defaultValue == null) {
                                node.defaultValue = newValue;
                            }
                        }
                        if (props.defaultValue != null) {
                            node.defaultValue = props.defaultValue;
                        }
                    }
                    function postMountWrapper$3(element, props) {
                        var node = element;
                        var textContent = node.textContent;
                        if (textContent === node._wrapperState.initialValue) {
                            node.value = textContent;
                        }
                    }
                    function restoreControlledState$3(element, props) {
                        updateWrapper$1(element, props);
                    }
                    var HTML_NAMESPACE$1 = "http://www.w3.org/1999/xhtml";
                    var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
                    var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                    var Namespaces = {
                        html: HTML_NAMESPACE$1,
                        mathml: MATH_NAMESPACE,
                        svg: SVG_NAMESPACE
                    };
                    function getIntrinsicNamespace(type) {
                        switch (type) {
                          case "svg":
                            return SVG_NAMESPACE;

                          case "math":
                            return MATH_NAMESPACE;

                          default:
                            return HTML_NAMESPACE$1;
                        }
                    }
                    function getChildNamespace(parentNamespace, type) {
                        if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {
                            return getIntrinsicNamespace(type);
                        }
                        if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
                            return HTML_NAMESPACE$1;
                        }
                        return parentNamespace;
                    }
                    var createMicrosoftUnsafeLocalFunction = function(func) {
                        if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
                            return function(arg0, arg1, arg2, arg3) {
                                MSApp.execUnsafeLocalFunction(function() {
                                    return func(arg0, arg1, arg2, arg3);
                                });
                            };
                        } else {
                            return func;
                        }
                    };
                    var reusableSVGContainer = void 0;
                    var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
                        if (node.namespaceURI === Namespaces.svg && !("innerHTML" in node)) {
                            reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                            reusableSVGContainer.innerHTML = "<svg>" + html + "</svg>";
                            var svgNode = reusableSVGContainer.firstChild;
                            while (node.firstChild) {
                                node.removeChild(node.firstChild);
                            }
                            while (svgNode.firstChild) {
                                node.appendChild(svgNode.firstChild);
                            }
                        } else {
                            node.innerHTML = html;
                        }
                    });
                    var setTextContent = function(node, text) {
                        if (text) {
                            var firstChild = node.firstChild;
                            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                                firstChild.nodeValue = text;
                                return;
                            }
                        }
                        node.textContent = text;
                    };
                    var isUnitlessNumber = {
                        animationIterationCount: true,
                        borderImageOutset: true,
                        borderImageSlice: true,
                        borderImageWidth: true,
                        boxFlex: true,
                        boxFlexGroup: true,
                        boxOrdinalGroup: true,
                        columnCount: true,
                        columns: true,
                        flex: true,
                        flexGrow: true,
                        flexPositive: true,
                        flexShrink: true,
                        flexNegative: true,
                        flexOrder: true,
                        gridRow: true,
                        gridRowEnd: true,
                        gridRowSpan: true,
                        gridRowStart: true,
                        gridColumn: true,
                        gridColumnEnd: true,
                        gridColumnSpan: true,
                        gridColumnStart: true,
                        fontWeight: true,
                        lineClamp: true,
                        lineHeight: true,
                        opacity: true,
                        order: true,
                        orphans: true,
                        tabSize: true,
                        widows: true,
                        zIndex: true,
                        zoom: true,
                        fillOpacity: true,
                        floodOpacity: true,
                        stopOpacity: true,
                        strokeDasharray: true,
                        strokeDashoffset: true,
                        strokeMiterlimit: true,
                        strokeOpacity: true,
                        strokeWidth: true
                    };
                    function prefixKey(prefix, key) {
                        return prefix + key.charAt(0).toUpperCase() + key.substring(1);
                    }
                    var prefixes = [ "Webkit", "ms", "Moz", "O" ];
                    Object.keys(isUnitlessNumber).forEach(function(prop) {
                        prefixes.forEach(function(prefix) {
                            isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
                        });
                    });
                    function dangerousStyleValue(name, value, isCustomProperty) {
                        var isEmpty = value == null || typeof value === "boolean" || value === "";
                        if (isEmpty) {
                            return "";
                        }
                        if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
                            return value + "px";
                        }
                        return ("" + value).trim();
                    }
                    var warnValidStyle = emptyFunction;
                    {
                        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
                        var badStyleValueWithSemicolonPattern = /;\s*$/;
                        var warnedStyleNames = {};
                        var warnedStyleValues = {};
                        var warnedForNaNValue = false;
                        var warnedForInfinityValue = false;
                        var warnHyphenatedStyleName = function(name, getStack) {
                            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                                return;
                            }
                            warnedStyleNames[name] = true;
                            warning(false, "Unsupported style property %s. Did you mean %s?%s", name, camelizeStyleName(name), getStack());
                        };
                        var warnBadVendoredStyleName = function(name, getStack) {
                            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                                return;
                            }
                            warnedStyleNames[name] = true;
                            warning(false, "Unsupported vendor-prefixed style property %s. Did you mean %s?%s", name, name.charAt(0).toUpperCase() + name.slice(1), getStack());
                        };
                        var warnStyleValueWithSemicolon = function(name, value, getStack) {
                            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                                return;
                            }
                            warnedStyleValues[value] = true;
                            warning(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ""), getStack());
                        };
                        var warnStyleValueIsNaN = function(name, value, getStack) {
                            if (warnedForNaNValue) {
                                return;
                            }
                            warnedForNaNValue = true;
                            warning(false, "`NaN` is an invalid value for the `%s` css style property.%s", name, getStack());
                        };
                        var warnStyleValueIsInfinity = function(name, value, getStack) {
                            if (warnedForInfinityValue) {
                                return;
                            }
                            warnedForInfinityValue = true;
                            warning(false, "`Infinity` is an invalid value for the `%s` css style property.%s", name, getStack());
                        };
                        warnValidStyle = function(name, value, getStack) {
                            if (name.indexOf("-") > -1) {
                                warnHyphenatedStyleName(name, getStack);
                            } else if (badVendoredStyleNamePattern.test(name)) {
                                warnBadVendoredStyleName(name, getStack);
                            } else if (badStyleValueWithSemicolonPattern.test(value)) {
                                warnStyleValueWithSemicolon(name, value, getStack);
                            }
                            if (typeof value === "number") {
                                if (isNaN(value)) {
                                    warnStyleValueIsNaN(name, value, getStack);
                                } else if (!isFinite(value)) {
                                    warnStyleValueIsInfinity(name, value, getStack);
                                }
                            }
                        };
                    }
                    var warnValidStyle$1 = warnValidStyle;
                    function createDangerousStringForStyles(styles) {
                        {
                            var serialized = "";
                            var delimiter = "";
                            for (var styleName in styles) {
                                if (!styles.hasOwnProperty(styleName)) {
                                    continue;
                                }
                                var styleValue = styles[styleName];
                                if (styleValue != null) {
                                    var isCustomProperty = styleName.indexOf("--") === 0;
                                    serialized += delimiter + hyphenateStyleName(styleName) + ":";
                                    serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                                    delimiter = ";";
                                }
                            }
                            return serialized || null;
                        }
                    }
                    function setValueForStyles(node, styles, getStack) {
                        var style = node.style;
                        for (var styleName in styles) {
                            if (!styles.hasOwnProperty(styleName)) {
                                continue;
                            }
                            var isCustomProperty = styleName.indexOf("--") === 0;
                            {
                                if (!isCustomProperty) {
                                    warnValidStyle$1(styleName, styles[styleName], getStack);
                                }
                            }
                            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
                            if (styleName === "float") {
                                styleName = "cssFloat";
                            }
                            if (isCustomProperty) {
                                style.setProperty(styleName, styleValue);
                            } else {
                                style[styleName] = styleValue;
                            }
                        }
                    }
                    var omittedCloseTags = {
                        area: true,
                        base: true,
                        br: true,
                        col: true,
                        embed: true,
                        hr: true,
                        img: true,
                        input: true,
                        keygen: true,
                        link: true,
                        meta: true,
                        param: true,
                        source: true,
                        track: true,
                        wbr: true
                    };
                    var voidElementTags = _assign({
                        menuitem: true
                    }, omittedCloseTags);
                    var HTML$1 = "__html";
                    function assertValidProps(tag, props, getStack) {
                        if (!props) {
                            return;
                        }
                        if (voidElementTags[tag]) {
                            !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, "%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s", tag, getStack()) : void 0;
                        }
                        if (props.dangerouslySetInnerHTML != null) {
                            !(props.children == null) ? invariant(false, "Can only set one of `children` or `props.dangerouslySetInnerHTML`.") : void 0;
                            !(typeof props.dangerouslySetInnerHTML === "object" && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.") : void 0;
                        }
                        {
                            warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, "A component is `contentEditable` and contains `children` managed by " + "React. It is now your responsibility to guarantee that none of " + "those nodes are unexpectedly modified or duplicated. This is " + "probably not intentional.%s", getStack());
                        }
                        !(props.style == null || typeof props.style === "object") ? invariant(false, "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.%s", getStack()) : void 0;
                    }
                    function isCustomComponent(tagName, props) {
                        if (tagName.indexOf("-") === -1) {
                            return typeof props.is === "string";
                        }
                        switch (tagName) {
                          case "annotation-xml":
                          case "color-profile":
                          case "font-face":
                          case "font-face-src":
                          case "font-face-uri":
                          case "font-face-format":
                          case "font-face-name":
                          case "missing-glyph":
                            return false;

                          default:
                            return true;
                        }
                    }
                    var ariaProperties = {
                        "aria-current": 0,
                        "aria-details": 0,
                        "aria-disabled": 0,
                        "aria-hidden": 0,
                        "aria-invalid": 0,
                        "aria-keyshortcuts": 0,
                        "aria-label": 0,
                        "aria-roledescription": 0,
                        "aria-autocomplete": 0,
                        "aria-checked": 0,
                        "aria-expanded": 0,
                        "aria-haspopup": 0,
                        "aria-level": 0,
                        "aria-modal": 0,
                        "aria-multiline": 0,
                        "aria-multiselectable": 0,
                        "aria-orientation": 0,
                        "aria-placeholder": 0,
                        "aria-pressed": 0,
                        "aria-readonly": 0,
                        "aria-required": 0,
                        "aria-selected": 0,
                        "aria-sort": 0,
                        "aria-valuemax": 0,
                        "aria-valuemin": 0,
                        "aria-valuenow": 0,
                        "aria-valuetext": 0,
                        "aria-atomic": 0,
                        "aria-busy": 0,
                        "aria-live": 0,
                        "aria-relevant": 0,
                        "aria-dropeffect": 0,
                        "aria-grabbed": 0,
                        "aria-activedescendant": 0,
                        "aria-colcount": 0,
                        "aria-colindex": 0,
                        "aria-colspan": 0,
                        "aria-controls": 0,
                        "aria-describedby": 0,
                        "aria-errormessage": 0,
                        "aria-flowto": 0,
                        "aria-labelledby": 0,
                        "aria-owns": 0,
                        "aria-posinset": 0,
                        "aria-rowcount": 0,
                        "aria-rowindex": 0,
                        "aria-rowspan": 0,
                        "aria-setsize": 0
                    };
                    var warnedProperties = {};
                    var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
                    var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
                    var hasOwnProperty = Object.prototype.hasOwnProperty;
                    function getStackAddendum() {
                        var stack = ReactDebugCurrentFrame.getStackAddendum();
                        return stack != null ? stack : "";
                    }
                    function validateProperty(tagName, name) {
                        if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
                            return true;
                        }
                        if (rARIACamel.test(name)) {
                            var ariaName = "aria-" + name.slice(4).toLowerCase();
                            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                            if (correctName == null) {
                                warning(false, "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s", name, getStackAddendum());
                                warnedProperties[name] = true;
                                return true;
                            }
                            if (name !== correctName) {
                                warning(false, "Invalid ARIA attribute `%s`. Did you mean `%s`?%s", name, correctName, getStackAddendum());
                                warnedProperties[name] = true;
                                return true;
                            }
                        }
                        if (rARIA.test(name)) {
                            var lowerCasedName = name.toLowerCase();
                            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                            if (standardName == null) {
                                warnedProperties[name] = true;
                                return false;
                            }
                            if (name !== standardName) {
                                warning(false, "Unknown ARIA attribute `%s`. Did you mean `%s`?%s", name, standardName, getStackAddendum());
                                warnedProperties[name] = true;
                                return true;
                            }
                        }
                        return true;
                    }
                    function warnInvalidARIAProps(type, props) {
                        var invalidProps = [];
                        for (var key in props) {
                            var isValid = validateProperty(type, key);
                            if (!isValid) {
                                invalidProps.push(key);
                            }
                        }
                        var unknownPropString = invalidProps.map(function(prop) {
                            return "`" + prop + "`";
                        }).join(", ");
                        if (invalidProps.length === 1) {
                            warning(false, "Invalid aria prop %s on <%s> tag. " + "For details, see https://fb.me/invalid-aria-prop%s", unknownPropString, type, getStackAddendum());
                        } else if (invalidProps.length > 1) {
                            warning(false, "Invalid aria props %s on <%s> tag. " + "For details, see https://fb.me/invalid-aria-prop%s", unknownPropString, type, getStackAddendum());
                        }
                    }
                    function validateProperties(type, props) {
                        if (isCustomComponent(type, props)) {
                            return;
                        }
                        warnInvalidARIAProps(type, props);
                    }
                    var didWarnValueNull = false;
                    function getStackAddendum$1() {
                        var stack = ReactDebugCurrentFrame.getStackAddendum();
                        return stack != null ? stack : "";
                    }
                    function validateProperties$1(type, props) {
                        if (type !== "input" && type !== "textarea" && type !== "select") {
                            return;
                        }
                        if (props != null && props.value === null && !didWarnValueNull) {
                            didWarnValueNull = true;
                            if (type === "select" && props.multiple) {
                                warning(false, "`value` prop on `%s` should not be null. " + "Consider using an empty array when `multiple` is set to `true` " + "to clear the component or `undefined` for uncontrolled components.%s", type, getStackAddendum$1());
                            } else {
                                warning(false, "`value` prop on `%s` should not be null. " + "Consider using an empty string to clear the component or `undefined` " + "for uncontrolled components.%s", type, getStackAddendum$1());
                            }
                        }
                    }
                    var possibleStandardNames = {
                        accept: "accept",
                        acceptcharset: "acceptCharset",
                        "accept-charset": "acceptCharset",
                        accesskey: "accessKey",
                        action: "action",
                        allowfullscreen: "allowFullScreen",
                        alt: "alt",
                        as: "as",
                        async: "async",
                        autocapitalize: "autoCapitalize",
                        autocomplete: "autoComplete",
                        autocorrect: "autoCorrect",
                        autofocus: "autoFocus",
                        autoplay: "autoPlay",
                        autosave: "autoSave",
                        capture: "capture",
                        cellpadding: "cellPadding",
                        cellspacing: "cellSpacing",
                        challenge: "challenge",
                        charset: "charSet",
                        checked: "checked",
                        children: "children",
                        cite: "cite",
                        class: "className",
                        classid: "classID",
                        classname: "className",
                        cols: "cols",
                        colspan: "colSpan",
                        content: "content",
                        contenteditable: "contentEditable",
                        contextmenu: "contextMenu",
                        controls: "controls",
                        controlslist: "controlsList",
                        coords: "coords",
                        crossorigin: "crossOrigin",
                        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
                        data: "data",
                        datetime: "dateTime",
                        default: "default",
                        defaultchecked: "defaultChecked",
                        defaultvalue: "defaultValue",
                        defer: "defer",
                        dir: "dir",
                        disabled: "disabled",
                        download: "download",
                        draggable: "draggable",
                        enctype: "encType",
                        for: "htmlFor",
                        form: "form",
                        formmethod: "formMethod",
                        formaction: "formAction",
                        formenctype: "formEncType",
                        formnovalidate: "formNoValidate",
                        formtarget: "formTarget",
                        frameborder: "frameBorder",
                        headers: "headers",
                        height: "height",
                        hidden: "hidden",
                        high: "high",
                        href: "href",
                        hreflang: "hrefLang",
                        htmlfor: "htmlFor",
                        httpequiv: "httpEquiv",
                        "http-equiv": "httpEquiv",
                        icon: "icon",
                        id: "id",
                        innerhtml: "innerHTML",
                        inputmode: "inputMode",
                        integrity: "integrity",
                        is: "is",
                        itemid: "itemID",
                        itemprop: "itemProp",
                        itemref: "itemRef",
                        itemscope: "itemScope",
                        itemtype: "itemType",
                        keyparams: "keyParams",
                        keytype: "keyType",
                        kind: "kind",
                        label: "label",
                        lang: "lang",
                        list: "list",
                        loop: "loop",
                        low: "low",
                        manifest: "manifest",
                        marginwidth: "marginWidth",
                        marginheight: "marginHeight",
                        max: "max",
                        maxlength: "maxLength",
                        media: "media",
                        mediagroup: "mediaGroup",
                        method: "method",
                        min: "min",
                        minlength: "minLength",
                        multiple: "multiple",
                        muted: "muted",
                        name: "name",
                        nonce: "nonce",
                        novalidate: "noValidate",
                        open: "open",
                        optimum: "optimum",
                        pattern: "pattern",
                        placeholder: "placeholder",
                        playsinline: "playsInline",
                        poster: "poster",
                        preload: "preload",
                        profile: "profile",
                        radiogroup: "radioGroup",
                        readonly: "readOnly",
                        referrerpolicy: "referrerPolicy",
                        rel: "rel",
                        required: "required",
                        reversed: "reversed",
                        role: "role",
                        rows: "rows",
                        rowspan: "rowSpan",
                        sandbox: "sandbox",
                        scope: "scope",
                        scoped: "scoped",
                        scrolling: "scrolling",
                        seamless: "seamless",
                        selected: "selected",
                        shape: "shape",
                        size: "size",
                        sizes: "sizes",
                        span: "span",
                        spellcheck: "spellCheck",
                        src: "src",
                        srcdoc: "srcDoc",
                        srclang: "srcLang",
                        srcset: "srcSet",
                        start: "start",
                        step: "step",
                        style: "style",
                        summary: "summary",
                        tabindex: "tabIndex",
                        target: "target",
                        title: "title",
                        type: "type",
                        usemap: "useMap",
                        value: "value",
                        width: "width",
                        wmode: "wmode",
                        wrap: "wrap",
                        about: "about",
                        accentheight: "accentHeight",
                        "accent-height": "accentHeight",
                        accumulate: "accumulate",
                        additive: "additive",
                        alignmentbaseline: "alignmentBaseline",
                        "alignment-baseline": "alignmentBaseline",
                        allowreorder: "allowReorder",
                        alphabetic: "alphabetic",
                        amplitude: "amplitude",
                        arabicform: "arabicForm",
                        "arabic-form": "arabicForm",
                        ascent: "ascent",
                        attributename: "attributeName",
                        attributetype: "attributeType",
                        autoreverse: "autoReverse",
                        azimuth: "azimuth",
                        basefrequency: "baseFrequency",
                        baselineshift: "baselineShift",
                        "baseline-shift": "baselineShift",
                        baseprofile: "baseProfile",
                        bbox: "bbox",
                        begin: "begin",
                        bias: "bias",
                        by: "by",
                        calcmode: "calcMode",
                        capheight: "capHeight",
                        "cap-height": "capHeight",
                        clip: "clip",
                        clippath: "clipPath",
                        "clip-path": "clipPath",
                        clippathunits: "clipPathUnits",
                        cliprule: "clipRule",
                        "clip-rule": "clipRule",
                        color: "color",
                        colorinterpolation: "colorInterpolation",
                        "color-interpolation": "colorInterpolation",
                        colorinterpolationfilters: "colorInterpolationFilters",
                        "color-interpolation-filters": "colorInterpolationFilters",
                        colorprofile: "colorProfile",
                        "color-profile": "colorProfile",
                        colorrendering: "colorRendering",
                        "color-rendering": "colorRendering",
                        contentscripttype: "contentScriptType",
                        contentstyletype: "contentStyleType",
                        cursor: "cursor",
                        cx: "cx",
                        cy: "cy",
                        d: "d",
                        datatype: "datatype",
                        decelerate: "decelerate",
                        descent: "descent",
                        diffuseconstant: "diffuseConstant",
                        direction: "direction",
                        display: "display",
                        divisor: "divisor",
                        dominantbaseline: "dominantBaseline",
                        "dominant-baseline": "dominantBaseline",
                        dur: "dur",
                        dx: "dx",
                        dy: "dy",
                        edgemode: "edgeMode",
                        elevation: "elevation",
                        enablebackground: "enableBackground",
                        "enable-background": "enableBackground",
                        end: "end",
                        exponent: "exponent",
                        externalresourcesrequired: "externalResourcesRequired",
                        fill: "fill",
                        fillopacity: "fillOpacity",
                        "fill-opacity": "fillOpacity",
                        fillrule: "fillRule",
                        "fill-rule": "fillRule",
                        filter: "filter",
                        filterres: "filterRes",
                        filterunits: "filterUnits",
                        floodopacity: "floodOpacity",
                        "flood-opacity": "floodOpacity",
                        floodcolor: "floodColor",
                        "flood-color": "floodColor",
                        focusable: "focusable",
                        fontfamily: "fontFamily",
                        "font-family": "fontFamily",
                        fontsize: "fontSize",
                        "font-size": "fontSize",
                        fontsizeadjust: "fontSizeAdjust",
                        "font-size-adjust": "fontSizeAdjust",
                        fontstretch: "fontStretch",
                        "font-stretch": "fontStretch",
                        fontstyle: "fontStyle",
                        "font-style": "fontStyle",
                        fontvariant: "fontVariant",
                        "font-variant": "fontVariant",
                        fontweight: "fontWeight",
                        "font-weight": "fontWeight",
                        format: "format",
                        from: "from",
                        fx: "fx",
                        fy: "fy",
                        g1: "g1",
                        g2: "g2",
                        glyphname: "glyphName",
                        "glyph-name": "glyphName",
                        glyphorientationhorizontal: "glyphOrientationHorizontal",
                        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
                        glyphorientationvertical: "glyphOrientationVertical",
                        "glyph-orientation-vertical": "glyphOrientationVertical",
                        glyphref: "glyphRef",
                        gradienttransform: "gradientTransform",
                        gradientunits: "gradientUnits",
                        hanging: "hanging",
                        horizadvx: "horizAdvX",
                        "horiz-adv-x": "horizAdvX",
                        horizoriginx: "horizOriginX",
                        "horiz-origin-x": "horizOriginX",
                        ideographic: "ideographic",
                        imagerendering: "imageRendering",
                        "image-rendering": "imageRendering",
                        in2: "in2",
                        in: "in",
                        inlist: "inlist",
                        intercept: "intercept",
                        k1: "k1",
                        k2: "k2",
                        k3: "k3",
                        k4: "k4",
                        k: "k",
                        kernelmatrix: "kernelMatrix",
                        kernelunitlength: "kernelUnitLength",
                        kerning: "kerning",
                        keypoints: "keyPoints",
                        keysplines: "keySplines",
                        keytimes: "keyTimes",
                        lengthadjust: "lengthAdjust",
                        letterspacing: "letterSpacing",
                        "letter-spacing": "letterSpacing",
                        lightingcolor: "lightingColor",
                        "lighting-color": "lightingColor",
                        limitingconeangle: "limitingConeAngle",
                        local: "local",
                        markerend: "markerEnd",
                        "marker-end": "markerEnd",
                        markerheight: "markerHeight",
                        markermid: "markerMid",
                        "marker-mid": "markerMid",
                        markerstart: "markerStart",
                        "marker-start": "markerStart",
                        markerunits: "markerUnits",
                        markerwidth: "markerWidth",
                        mask: "mask",
                        maskcontentunits: "maskContentUnits",
                        maskunits: "maskUnits",
                        mathematical: "mathematical",
                        mode: "mode",
                        numoctaves: "numOctaves",
                        offset: "offset",
                        opacity: "opacity",
                        operator: "operator",
                        order: "order",
                        orient: "orient",
                        orientation: "orientation",
                        origin: "origin",
                        overflow: "overflow",
                        overlineposition: "overlinePosition",
                        "overline-position": "overlinePosition",
                        overlinethickness: "overlineThickness",
                        "overline-thickness": "overlineThickness",
                        paintorder: "paintOrder",
                        "paint-order": "paintOrder",
                        panose1: "panose1",
                        "panose-1": "panose1",
                        pathlength: "pathLength",
                        patterncontentunits: "patternContentUnits",
                        patterntransform: "patternTransform",
                        patternunits: "patternUnits",
                        pointerevents: "pointerEvents",
                        "pointer-events": "pointerEvents",
                        points: "points",
                        pointsatx: "pointsAtX",
                        pointsaty: "pointsAtY",
                        pointsatz: "pointsAtZ",
                        prefix: "prefix",
                        preservealpha: "preserveAlpha",
                        preserveaspectratio: "preserveAspectRatio",
                        primitiveunits: "primitiveUnits",
                        property: "property",
                        r: "r",
                        radius: "radius",
                        refx: "refX",
                        refy: "refY",
                        renderingintent: "renderingIntent",
                        "rendering-intent": "renderingIntent",
                        repeatcount: "repeatCount",
                        repeatdur: "repeatDur",
                        requiredextensions: "requiredExtensions",
                        requiredfeatures: "requiredFeatures",
                        resource: "resource",
                        restart: "restart",
                        result: "result",
                        results: "results",
                        rotate: "rotate",
                        rx: "rx",
                        ry: "ry",
                        scale: "scale",
                        security: "security",
                        seed: "seed",
                        shaperendering: "shapeRendering",
                        "shape-rendering": "shapeRendering",
                        slope: "slope",
                        spacing: "spacing",
                        specularconstant: "specularConstant",
                        specularexponent: "specularExponent",
                        speed: "speed",
                        spreadmethod: "spreadMethod",
                        startoffset: "startOffset",
                        stddeviation: "stdDeviation",
                        stemh: "stemh",
                        stemv: "stemv",
                        stitchtiles: "stitchTiles",
                        stopcolor: "stopColor",
                        "stop-color": "stopColor",
                        stopopacity: "stopOpacity",
                        "stop-opacity": "stopOpacity",
                        strikethroughposition: "strikethroughPosition",
                        "strikethrough-position": "strikethroughPosition",
                        strikethroughthickness: "strikethroughThickness",
                        "strikethrough-thickness": "strikethroughThickness",
                        string: "string",
                        stroke: "stroke",
                        strokedasharray: "strokeDasharray",
                        "stroke-dasharray": "strokeDasharray",
                        strokedashoffset: "strokeDashoffset",
                        "stroke-dashoffset": "strokeDashoffset",
                        strokelinecap: "strokeLinecap",
                        "stroke-linecap": "strokeLinecap",
                        strokelinejoin: "strokeLinejoin",
                        "stroke-linejoin": "strokeLinejoin",
                        strokemiterlimit: "strokeMiterlimit",
                        "stroke-miterlimit": "strokeMiterlimit",
                        strokewidth: "strokeWidth",
                        "stroke-width": "strokeWidth",
                        strokeopacity: "strokeOpacity",
                        "stroke-opacity": "strokeOpacity",
                        suppresscontenteditablewarning: "suppressContentEditableWarning",
                        suppresshydrationwarning: "suppressHydrationWarning",
                        surfacescale: "surfaceScale",
                        systemlanguage: "systemLanguage",
                        tablevalues: "tableValues",
                        targetx: "targetX",
                        targety: "targetY",
                        textanchor: "textAnchor",
                        "text-anchor": "textAnchor",
                        textdecoration: "textDecoration",
                        "text-decoration": "textDecoration",
                        textlength: "textLength",
                        textrendering: "textRendering",
                        "text-rendering": "textRendering",
                        to: "to",
                        transform: "transform",
                        typeof: "typeof",
                        u1: "u1",
                        u2: "u2",
                        underlineposition: "underlinePosition",
                        "underline-position": "underlinePosition",
                        underlinethickness: "underlineThickness",
                        "underline-thickness": "underlineThickness",
                        unicode: "unicode",
                        unicodebidi: "unicodeBidi",
                        "unicode-bidi": "unicodeBidi",
                        unicoderange: "unicodeRange",
                        "unicode-range": "unicodeRange",
                        unitsperem: "unitsPerEm",
                        "units-per-em": "unitsPerEm",
                        unselectable: "unselectable",
                        valphabetic: "vAlphabetic",
                        "v-alphabetic": "vAlphabetic",
                        values: "values",
                        vectoreffect: "vectorEffect",
                        "vector-effect": "vectorEffect",
                        version: "version",
                        vertadvy: "vertAdvY",
                        "vert-adv-y": "vertAdvY",
                        vertoriginx: "vertOriginX",
                        "vert-origin-x": "vertOriginX",
                        vertoriginy: "vertOriginY",
                        "vert-origin-y": "vertOriginY",
                        vhanging: "vHanging",
                        "v-hanging": "vHanging",
                        videographic: "vIdeographic",
                        "v-ideographic": "vIdeographic",
                        viewbox: "viewBox",
                        viewtarget: "viewTarget",
                        visibility: "visibility",
                        vmathematical: "vMathematical",
                        "v-mathematical": "vMathematical",
                        vocab: "vocab",
                        widths: "widths",
                        wordspacing: "wordSpacing",
                        "word-spacing": "wordSpacing",
                        writingmode: "writingMode",
                        "writing-mode": "writingMode",
                        x1: "x1",
                        x2: "x2",
                        x: "x",
                        xchannelselector: "xChannelSelector",
                        xheight: "xHeight",
                        "x-height": "xHeight",
                        xlinkactuate: "xlinkActuate",
                        "xlink:actuate": "xlinkActuate",
                        xlinkarcrole: "xlinkArcrole",
                        "xlink:arcrole": "xlinkArcrole",
                        xlinkhref: "xlinkHref",
                        "xlink:href": "xlinkHref",
                        xlinkrole: "xlinkRole",
                        "xlink:role": "xlinkRole",
                        xlinkshow: "xlinkShow",
                        "xlink:show": "xlinkShow",
                        xlinktitle: "xlinkTitle",
                        "xlink:title": "xlinkTitle",
                        xlinktype: "xlinkType",
                        "xlink:type": "xlinkType",
                        xmlbase: "xmlBase",
                        "xml:base": "xmlBase",
                        xmllang: "xmlLang",
                        "xml:lang": "xmlLang",
                        xmlns: "xmlns",
                        "xml:space": "xmlSpace",
                        xmlnsxlink: "xmlnsXlink",
                        "xmlns:xlink": "xmlnsXlink",
                        xmlspace: "xmlSpace",
                        y1: "y1",
                        y2: "y2",
                        y: "y",
                        ychannelselector: "yChannelSelector",
                        z: "z",
                        zoomandpan: "zoomAndPan"
                    };
                    function getStackAddendum$2() {
                        var stack = ReactDebugCurrentFrame.getStackAddendum();
                        return stack != null ? stack : "";
                    }
                    {
                        var warnedProperties$1 = {};
                        var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
                        var EVENT_NAME_REGEX = /^on./;
                        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
                        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
                        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
                        var validateProperty$1 = function(tagName, name, value, canUseEventSystem) {
                            if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                                return true;
                            }
                            var lowerCasedName = name.toLowerCase();
                            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                                warning(false, "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. " + "All React events are normalized to bubble, so onFocusIn and onFocusOut " + "are not needed/supported by React.");
                                warnedProperties$1[name] = true;
                                return true;
                            }
                            if (canUseEventSystem) {
                                if (registrationNameModules.hasOwnProperty(name)) {
                                    return true;
                                }
                                var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
                                if (registrationName != null) {
                                    warning(false, "Invalid event handler property `%s`. Did you mean `%s`?%s", name, registrationName, getStackAddendum$2());
                                    warnedProperties$1[name] = true;
                                    return true;
                                }
                                if (EVENT_NAME_REGEX.test(name)) {
                                    warning(false, "Unknown event handler property `%s`. It will be ignored.%s", name, getStackAddendum$2());
                                    warnedProperties$1[name] = true;
                                    return true;
                                }
                            } else if (EVENT_NAME_REGEX.test(name)) {
                                if (INVALID_EVENT_NAME_REGEX.test(name)) {
                                    warning(false, "Invalid event handler property `%s`. " + "React events use the camelCase naming convention, for example `onClick`.%s", name, getStackAddendum$2());
                                }
                                warnedProperties$1[name] = true;
                                return true;
                            }
                            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                                return true;
                            }
                            if (lowerCasedName === "innerhtml") {
                                warning(false, "Directly setting property `innerHTML` is not permitted. " + "For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                                warnedProperties$1[name] = true;
                                return true;
                            }
                            if (lowerCasedName === "aria") {
                                warning(false, "The `aria` attribute is reserved for future use in React. " + "Pass individual `aria-` attributes instead.");
                                warnedProperties$1[name] = true;
                                return true;
                            }
                            if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string") {
                                warning(false, "Received a `%s` for a string attribute `is`. If this is expected, cast " + "the value to a string.%s", typeof value, getStackAddendum$2());
                                warnedProperties$1[name] = true;
                                return true;
                            }
                            if (typeof value === "number" && isNaN(value)) {
                                warning(false, "Received NaN for the `%s` attribute. If this is expected, cast " + "the value to a string.%s", name, getStackAddendum$2());
                                warnedProperties$1[name] = true;
                                return true;
                            }
                            var isReserved = isReservedProp(name);
                            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                                var standardName = possibleStandardNames[lowerCasedName];
                                if (standardName !== name) {
                                    warning(false, "Invalid DOM property `%s`. Did you mean `%s`?%s", name, standardName, getStackAddendum$2());
                                    warnedProperties$1[name] = true;
                                    return true;
                                }
                            } else if (!isReserved && name !== lowerCasedName) {
                                warning(false, "React does not recognize the `%s` prop on a DOM element. If you " + "intentionally want it to appear in the DOM as a custom " + "attribute, spell it as lowercase `%s` instead. " + "If you accidentally passed it from a parent component, remove " + "it from the DOM element.%s", name, lowerCasedName, getStackAddendum$2());
                                warnedProperties$1[name] = true;
                                return true;
                            }
                            if (typeof value === "boolean" && !shouldAttributeAcceptBooleanValue(name)) {
                                if (value) {
                                    warning(false, "Received `%s` for a non-boolean attribute `%s`.\n\n" + "If you want to write it to the DOM, pass a string instead: " + '%s="%s" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());
                                } else {
                                    warning(false, "Received `%s` for a non-boolean attribute `%s`.\n\n" + "If you want to write it to the DOM, pass a string instead: " + '%s="%s" or %s={value.toString()}.\n\n' + "If you used to conditionally omit it with %s={condition && value}, " + "pass %s={condition ? value : undefined} instead.%s", value, name, name, value, name, name, name, getStackAddendum$2());
                                }
                                warnedProperties$1[name] = true;
                                return true;
                            }
                            if (isReserved) {
                                return true;
                            }
                            if (!shouldSetAttribute(name, value)) {
                                warnedProperties$1[name] = true;
                                return false;
                            }
                            return true;
                        };
                    }
                    var warnUnknownProperties = function(type, props, canUseEventSystem) {
                        var unknownProps = [];
                        for (var key in props) {
                            var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);
                            if (!isValid) {
                                unknownProps.push(key);
                            }
                        }
                        var unknownPropString = unknownProps.map(function(prop) {
                            return "`" + prop + "`";
                        }).join(", ");
                        if (unknownProps.length === 1) {
                            warning(false, "Invalid value for prop %s on <%s> tag. Either remove it from the element, " + "or pass a string or number value to keep it in the DOM. " + "For details, see https://fb.me/react-attribute-behavior%s", unknownPropString, type, getStackAddendum$2());
                        } else if (unknownProps.length > 1) {
                            warning(false, "Invalid values for props %s on <%s> tag. Either remove them from the element, " + "or pass a string or number value to keep them in the DOM. " + "For details, see https://fb.me/react-attribute-behavior%s", unknownPropString, type, getStackAddendum$2());
                        }
                    };
                    function validateProperties$2(type, props, canUseEventSystem) {
                        if (isCustomComponent(type, props)) {
                            return;
                        }
                        warnUnknownProperties(type, props, canUseEventSystem);
                    }
                    var getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
                    var getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
                    var didWarnInvalidHydration = false;
                    var didWarnShadyDOM = false;
                    var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
                    var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
                    var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
                    var AUTOFOCUS = "autoFocus";
                    var CHILDREN = "children";
                    var STYLE = "style";
                    var HTML = "__html";
                    var HTML_NAMESPACE = Namespaces.html;
                    var getStack = emptyFunction.thatReturns("");
                    {
                        getStack = getCurrentFiberStackAddendum$2;
                        var warnedUnknownTags = {
                            time: true,
                            dialog: true
                        };
                        var validatePropertiesInDevelopment = function(type, props) {
                            validateProperties(type, props);
                            validateProperties$1(type, props);
                            validateProperties$2(type, props, true);
                        };
                        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
                        var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
                        var normalizeMarkupForTextOrAttribute = function(markup) {
                            var markupString = typeof markup === "string" ? markup : "" + markup;
                            return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
                        };
                        var warnForTextDifference = function(serverText, clientText) {
                            if (didWarnInvalidHydration) {
                                return;
                            }
                            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
                            var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
                            if (normalizedServerText === normalizedClientText) {
                                return;
                            }
                            didWarnInvalidHydration = true;
                            warning(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
                        };
                        var warnForPropDifference = function(propName, serverValue, clientValue) {
                            if (didWarnInvalidHydration) {
                                return;
                            }
                            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
                            var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
                            if (normalizedServerValue === normalizedClientValue) {
                                return;
                            }
                            didWarnInvalidHydration = true;
                            warning(false, "Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
                        };
                        var warnForExtraAttributes = function(attributeNames) {
                            if (didWarnInvalidHydration) {
                                return;
                            }
                            didWarnInvalidHydration = true;
                            var names = [];
                            attributeNames.forEach(function(name) {
                                names.push(name);
                            });
                            warning(false, "Extra attributes from the server: %s", names);
                        };
                        var warnForInvalidEventListener = function(registrationName, listener) {
                            if (listener === false) {
                                warning(false, "Expected `%s` listener to be a function, instead got `false`.\n\n" + "If you used to conditionally omit it with %s={condition && value}, " + "pass %s={condition ? value : undefined} instead.%s", registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());
                            } else {
                                warning(false, "Expected `%s` listener to be a function, instead got a value of `%s` type.%s", registrationName, typeof listener, getCurrentFiberStackAddendum$2());
                            }
                        };
                        var normalizeHTML = function(parent, html) {
                            var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
                            testElement.innerHTML = html;
                            return testElement.innerHTML;
                        };
                    }
                    function ensureListeningTo(rootContainerElement, registrationName) {
                        var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
                        var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
                        listenTo(registrationName, doc);
                    }
                    function getOwnerDocumentFromRootContainer(rootContainerElement) {
                        return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
                    }
                    var mediaEvents = {
                        topAbort: "abort",
                        topCanPlay: "canplay",
                        topCanPlayThrough: "canplaythrough",
                        topDurationChange: "durationchange",
                        topEmptied: "emptied",
                        topEncrypted: "encrypted",
                        topEnded: "ended",
                        topError: "error",
                        topLoadedData: "loadeddata",
                        topLoadedMetadata: "loadedmetadata",
                        topLoadStart: "loadstart",
                        topPause: "pause",
                        topPlay: "play",
                        topPlaying: "playing",
                        topProgress: "progress",
                        topRateChange: "ratechange",
                        topSeeked: "seeked",
                        topSeeking: "seeking",
                        topStalled: "stalled",
                        topSuspend: "suspend",
                        topTimeUpdate: "timeupdate",
                        topVolumeChange: "volumechange",
                        topWaiting: "waiting"
                    };
                    function trapClickOnNonInteractiveElement(node) {
                        node.onclick = emptyFunction;
                    }
                    function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
                        for (var propKey in nextProps) {
                            if (!nextProps.hasOwnProperty(propKey)) {
                                continue;
                            }
                            var nextProp = nextProps[propKey];
                            if (propKey === STYLE) {
                                {
                                    if (nextProp) {
                                        Object.freeze(nextProp);
                                    }
                                }
                                setValueForStyles(domElement, nextProp, getStack);
                            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                                var nextHtml = nextProp ? nextProp[HTML] : undefined;
                                if (nextHtml != null) {
                                    setInnerHTML(domElement, nextHtml);
                                }
                            } else if (propKey === CHILDREN) {
                                if (typeof nextProp === "string") {
                                    var canSetTextContent = tag !== "textarea" || nextProp !== "";
                                    if (canSetTextContent) {
                                        setTextContent(domElement, nextProp);
                                    }
                                } else if (typeof nextProp === "number") {
                                    setTextContent(domElement, "" + nextProp);
                                }
                            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {} else if (propKey === AUTOFOCUS) {} else if (registrationNameModules.hasOwnProperty(propKey)) {
                                if (nextProp != null) {
                                    if (true && typeof nextProp !== "function") {
                                        warnForInvalidEventListener(propKey, nextProp);
                                    }
                                    ensureListeningTo(rootContainerElement, propKey);
                                }
                            } else if (isCustomComponentTag) {
                                setValueForAttribute(domElement, propKey, nextProp);
                            } else if (nextProp != null) {
                                setValueForProperty(domElement, propKey, nextProp);
                            }
                        }
                    }
                    function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
                        for (var i = 0; i < updatePayload.length; i += 2) {
                            var propKey = updatePayload[i];
                            var propValue = updatePayload[i + 1];
                            if (propKey === STYLE) {
                                setValueForStyles(domElement, propValue, getStack);
                            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                                setInnerHTML(domElement, propValue);
                            } else if (propKey === CHILDREN) {
                                setTextContent(domElement, propValue);
                            } else if (isCustomComponentTag) {
                                if (propValue != null) {
                                    setValueForAttribute(domElement, propKey, propValue);
                                } else {
                                    deleteValueForAttribute(domElement, propKey);
                                }
                            } else if (propValue != null) {
                                setValueForProperty(domElement, propKey, propValue);
                            } else {
                                deleteValueForProperty(domElement, propKey);
                            }
                        }
                    }
                    function createElement$1(type, props, rootContainerElement, parentNamespace) {
                        var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
                        var domElement;
                        var namespaceURI = parentNamespace;
                        if (namespaceURI === HTML_NAMESPACE) {
                            namespaceURI = getIntrinsicNamespace(type);
                        }
                        if (namespaceURI === HTML_NAMESPACE) {
                            {
                                var isCustomComponentTag = isCustomComponent(type, props);
                                warning(isCustomComponentTag || type === type.toLowerCase(), "<%s /> is using uppercase HTML. Always use lowercase HTML tags " + "in React.", type);
                            }
                            if (type === "script") {
                                var div = ownerDocument.createElement("div");
                                div.innerHTML = "<script><" + "/script>";
                                var firstChild = div.firstChild;
                                domElement = div.removeChild(firstChild);
                            } else if (typeof props.is === "string") {
                                domElement = ownerDocument.createElement(type, {
                                    is: props.is
                                });
                            } else {
                                domElement = ownerDocument.createElement(type);
                            }
                        } else {
                            domElement = ownerDocument.createElementNS(namespaceURI, type);
                        }
                        {
                            if (namespaceURI === HTML_NAMESPACE) {
                                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
                                    warnedUnknownTags[type] = true;
                                    warning(false, "The tag <%s> is unrecognized in this browser. " + "If you meant to render a React component, start its name with " + "an uppercase letter.", type);
                                }
                            }
                        }
                        return domElement;
                    }
                    function createTextNode$1(text, rootContainerElement) {
                        return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
                    }
                    function setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {
                        var isCustomComponentTag = isCustomComponent(tag, rawProps);
                        {
                            validatePropertiesInDevelopment(tag, rawProps);
                            if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
                                warning(false, "%s is using shady DOM. Using shady DOM with React can " + "cause things to break subtly.", getCurrentFiberOwnerName$1() || "A component");
                                didWarnShadyDOM = true;
                            }
                        }
                        var props;
                        switch (tag) {
                          case "iframe":
                          case "object":
                            trapBubbledEvent("topLoad", "load", domElement);
                            props = rawProps;
                            break;

                          case "video":
                          case "audio":
                            for (var event in mediaEvents) {
                                if (mediaEvents.hasOwnProperty(event)) {
                                    trapBubbledEvent(event, mediaEvents[event], domElement);
                                }
                            }
                            props = rawProps;
                            break;

                          case "source":
                            trapBubbledEvent("topError", "error", domElement);
                            props = rawProps;
                            break;

                          case "img":
                          case "image":
                            trapBubbledEvent("topError", "error", domElement);
                            trapBubbledEvent("topLoad", "load", domElement);
                            props = rawProps;
                            break;

                          case "form":
                            trapBubbledEvent("topReset", "reset", domElement);
                            trapBubbledEvent("topSubmit", "submit", domElement);
                            props = rawProps;
                            break;

                          case "details":
                            trapBubbledEvent("topToggle", "toggle", domElement);
                            props = rawProps;
                            break;

                          case "input":
                            initWrapperState(domElement, rawProps);
                            props = getHostProps(domElement, rawProps);
                            trapBubbledEvent("topInvalid", "invalid", domElement);
                            ensureListeningTo(rootContainerElement, "onChange");
                            break;

                          case "option":
                            validateProps(domElement, rawProps);
                            props = getHostProps$1(domElement, rawProps);
                            break;

                          case "select":
                            initWrapperState$1(domElement, rawProps);
                            props = getHostProps$2(domElement, rawProps);
                            trapBubbledEvent("topInvalid", "invalid", domElement);
                            ensureListeningTo(rootContainerElement, "onChange");
                            break;

                          case "textarea":
                            initWrapperState$2(domElement, rawProps);
                            props = getHostProps$3(domElement, rawProps);
                            trapBubbledEvent("topInvalid", "invalid", domElement);
                            ensureListeningTo(rootContainerElement, "onChange");
                            break;

                          default:
                            props = rawProps;
                        }
                        assertValidProps(tag, props, getStack);
                        setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
                        switch (tag) {
                          case "input":
                            track(domElement);
                            postMountWrapper(domElement, rawProps);
                            break;

                          case "textarea":
                            track(domElement);
                            postMountWrapper$3(domElement, rawProps);
                            break;

                          case "option":
                            postMountWrapper$1(domElement, rawProps);
                            break;

                          case "select":
                            postMountWrapper$2(domElement, rawProps);
                            break;

                          default:
                            if (typeof props.onClick === "function") {
                                trapClickOnNonInteractiveElement(domElement);
                            }
                            break;
                        }
                    }
                    function diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
                        {
                            validatePropertiesInDevelopment(tag, nextRawProps);
                        }
                        var updatePayload = null;
                        var lastProps;
                        var nextProps;
                        switch (tag) {
                          case "input":
                            lastProps = getHostProps(domElement, lastRawProps);
                            nextProps = getHostProps(domElement, nextRawProps);
                            updatePayload = [];
                            break;

                          case "option":
                            lastProps = getHostProps$1(domElement, lastRawProps);
                            nextProps = getHostProps$1(domElement, nextRawProps);
                            updatePayload = [];
                            break;

                          case "select":
                            lastProps = getHostProps$2(domElement, lastRawProps);
                            nextProps = getHostProps$2(domElement, nextRawProps);
                            updatePayload = [];
                            break;

                          case "textarea":
                            lastProps = getHostProps$3(domElement, lastRawProps);
                            nextProps = getHostProps$3(domElement, nextRawProps);
                            updatePayload = [];
                            break;

                          default:
                            lastProps = lastRawProps;
                            nextProps = nextRawProps;
                            if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                                trapClickOnNonInteractiveElement(domElement);
                            }
                            break;
                        }
                        assertValidProps(tag, nextProps, getStack);
                        var propKey;
                        var styleName;
                        var styleUpdates = null;
                        for (propKey in lastProps) {
                            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                                continue;
                            }
                            if (propKey === STYLE) {
                                var lastStyle = lastProps[propKey];
                                for (styleName in lastStyle) {
                                    if (lastStyle.hasOwnProperty(styleName)) {
                                        if (!styleUpdates) {
                                            styleUpdates = {};
                                        }
                                        styleUpdates[styleName] = "";
                                    }
                                }
                            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {} else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {} else if (propKey === AUTOFOCUS) {} else if (registrationNameModules.hasOwnProperty(propKey)) {
                                if (!updatePayload) {
                                    updatePayload = [];
                                }
                            } else {
                                (updatePayload = updatePayload || []).push(propKey, null);
                            }
                        }
                        for (propKey in nextProps) {
                            var nextProp = nextProps[propKey];
                            var lastProp = lastProps != null ? lastProps[propKey] : undefined;
                            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                                continue;
                            }
                            if (propKey === STYLE) {
                                {
                                    if (nextProp) {
                                        Object.freeze(nextProp);
                                    }
                                }
                                if (lastProp) {
                                    for (styleName in lastProp) {
                                        if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                                            if (!styleUpdates) {
                                                styleUpdates = {};
                                            }
                                            styleUpdates[styleName] = "";
                                        }
                                    }
                                    for (styleName in nextProp) {
                                        if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                                            if (!styleUpdates) {
                                                styleUpdates = {};
                                            }
                                            styleUpdates[styleName] = nextProp[styleName];
                                        }
                                    }
                                } else {
                                    if (!styleUpdates) {
                                        if (!updatePayload) {
                                            updatePayload = [];
                                        }
                                        updatePayload.push(propKey, styleUpdates);
                                    }
                                    styleUpdates = nextProp;
                                }
                            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                                var nextHtml = nextProp ? nextProp[HTML] : undefined;
                                var lastHtml = lastProp ? lastProp[HTML] : undefined;
                                if (nextHtml != null) {
                                    if (lastHtml !== nextHtml) {
                                        (updatePayload = updatePayload || []).push(propKey, "" + nextHtml);
                                    }
                                } else {}
                            } else if (propKey === CHILDREN) {
                                if (lastProp !== nextProp && (typeof nextProp === "string" || typeof nextProp === "number")) {
                                    (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                                }
                            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {} else if (registrationNameModules.hasOwnProperty(propKey)) {
                                if (nextProp != null) {
                                    if (true && typeof nextProp !== "function") {
                                        warnForInvalidEventListener(propKey, nextProp);
                                    }
                                    ensureListeningTo(rootContainerElement, propKey);
                                }
                                if (!updatePayload && lastProp !== nextProp) {
                                    updatePayload = [];
                                }
                            } else {
                                (updatePayload = updatePayload || []).push(propKey, nextProp);
                            }
                        }
                        if (styleUpdates) {
                            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
                        }
                        return updatePayload;
                    }
                    function updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
                        if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
                            updateChecked(domElement, nextRawProps);
                        }
                        var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
                        var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
                        updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
                        switch (tag) {
                          case "input":
                            updateWrapper(domElement, nextRawProps);
                            break;

                          case "textarea":
                            updateWrapper$1(domElement, nextRawProps);
                            break;

                          case "select":
                            postUpdateWrapper(domElement, nextRawProps);
                            break;
                        }
                    }
                    function diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
                        {
                            var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
                            var isCustomComponentTag = isCustomComponent(tag, rawProps);
                            validatePropertiesInDevelopment(tag, rawProps);
                            if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
                                warning(false, "%s is using shady DOM. Using shady DOM with React can " + "cause things to break subtly.", getCurrentFiberOwnerName$1() || "A component");
                                didWarnShadyDOM = true;
                            }
                        }
                        switch (tag) {
                          case "iframe":
                          case "object":
                            trapBubbledEvent("topLoad", "load", domElement);
                            break;

                          case "video":
                          case "audio":
                            for (var event in mediaEvents) {
                                if (mediaEvents.hasOwnProperty(event)) {
                                    trapBubbledEvent(event, mediaEvents[event], domElement);
                                }
                            }
                            break;

                          case "source":
                            trapBubbledEvent("topError", "error", domElement);
                            break;

                          case "img":
                          case "image":
                            trapBubbledEvent("topError", "error", domElement);
                            trapBubbledEvent("topLoad", "load", domElement);
                            break;

                          case "form":
                            trapBubbledEvent("topReset", "reset", domElement);
                            trapBubbledEvent("topSubmit", "submit", domElement);
                            break;

                          case "details":
                            trapBubbledEvent("topToggle", "toggle", domElement);
                            break;

                          case "input":
                            initWrapperState(domElement, rawProps);
                            trapBubbledEvent("topInvalid", "invalid", domElement);
                            ensureListeningTo(rootContainerElement, "onChange");
                            break;

                          case "option":
                            validateProps(domElement, rawProps);
                            break;

                          case "select":
                            initWrapperState$1(domElement, rawProps);
                            trapBubbledEvent("topInvalid", "invalid", domElement);
                            ensureListeningTo(rootContainerElement, "onChange");
                            break;

                          case "textarea":
                            initWrapperState$2(domElement, rawProps);
                            trapBubbledEvent("topInvalid", "invalid", domElement);
                            ensureListeningTo(rootContainerElement, "onChange");
                            break;
                        }
                        assertValidProps(tag, rawProps, getStack);
                        {
                            var extraAttributeNames = new Set();
                            var attributes = domElement.attributes;
                            for (var i = 0; i < attributes.length; i++) {
                                var name = attributes[i].name.toLowerCase();
                                switch (name) {
                                  case "data-reactroot":
                                    break;

                                  case "value":
                                    break;

                                  case "checked":
                                    break;

                                  case "selected":
                                    break;

                                  default:
                                    extraAttributeNames.add(attributes[i].name);
                                }
                            }
                        }
                        var updatePayload = null;
                        for (var propKey in rawProps) {
                            if (!rawProps.hasOwnProperty(propKey)) {
                                continue;
                            }
                            var nextProp = rawProps[propKey];
                            if (propKey === CHILDREN) {
                                if (typeof nextProp === "string") {
                                    if (domElement.textContent !== nextProp) {
                                        if (true && !suppressHydrationWarning) {
                                            warnForTextDifference(domElement.textContent, nextProp);
                                        }
                                        updatePayload = [ CHILDREN, nextProp ];
                                    }
                                } else if (typeof nextProp === "number") {
                                    if (domElement.textContent !== "" + nextProp) {
                                        if (true && !suppressHydrationWarning) {
                                            warnForTextDifference(domElement.textContent, nextProp);
                                        }
                                        updatePayload = [ CHILDREN, "" + nextProp ];
                                    }
                                }
                            } else if (registrationNameModules.hasOwnProperty(propKey)) {
                                if (nextProp != null) {
                                    if (true && typeof nextProp !== "function") {
                                        warnForInvalidEventListener(propKey, nextProp);
                                    }
                                    ensureListeningTo(rootContainerElement, propKey);
                                }
                            } else {
                                var serverValue;
                                var propertyInfo;
                                if (suppressHydrationWarning) {} else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 || propKey === "value" || propKey === "checked" || propKey === "selected") {} else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                                    var rawHtml = nextProp ? nextProp[HTML] || "" : "";
                                    var serverHTML = domElement.innerHTML;
                                    var expectedHTML = normalizeHTML(domElement, rawHtml);
                                    if (expectedHTML !== serverHTML) {
                                        warnForPropDifference(propKey, serverHTML, expectedHTML);
                                    }
                                } else if (propKey === STYLE) {
                                    extraAttributeNames["delete"](propKey);
                                    var expectedStyle = createDangerousStringForStyles(nextProp);
                                    serverValue = domElement.getAttribute("style");
                                    if (expectedStyle !== serverValue) {
                                        warnForPropDifference(propKey, serverValue, expectedStyle);
                                    }
                                } else if (isCustomComponentTag) {
                                    extraAttributeNames["delete"](propKey.toLowerCase());
                                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                                    if (nextProp !== serverValue) {
                                        warnForPropDifference(propKey, serverValue, nextProp);
                                    }
                                } else if (shouldSetAttribute(propKey, nextProp)) {
                                    if (propertyInfo = getPropertyInfo(propKey)) {
                                        extraAttributeNames["delete"](propertyInfo.attributeName);
                                        serverValue = getValueForProperty(domElement, propKey, nextProp);
                                    } else {
                                        var ownNamespace = parentNamespace;
                                        if (ownNamespace === HTML_NAMESPACE) {
                                            ownNamespace = getIntrinsicNamespace(tag);
                                        }
                                        if (ownNamespace === HTML_NAMESPACE) {
                                            extraAttributeNames["delete"](propKey.toLowerCase());
                                        } else {
                                            extraAttributeNames["delete"](propKey);
                                        }
                                        serverValue = getValueForAttribute(domElement, propKey, nextProp);
                                    }
                                    if (nextProp !== serverValue) {
                                        warnForPropDifference(propKey, serverValue, nextProp);
                                    }
                                }
                            }
                        }
                        {
                            if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
                                warnForExtraAttributes(extraAttributeNames);
                            }
                        }
                        switch (tag) {
                          case "input":
                            track(domElement);
                            postMountWrapper(domElement, rawProps);
                            break;

                          case "textarea":
                            track(domElement);
                            postMountWrapper$3(domElement, rawProps);
                            break;

                          case "select":
                          case "option":
                            break;

                          default:
                            if (typeof rawProps.onClick === "function") {
                                trapClickOnNonInteractiveElement(domElement);
                            }
                            break;
                        }
                        return updatePayload;
                    }
                    function diffHydratedText$1(textNode, text) {
                        var isDifferent = textNode.nodeValue !== text;
                        return isDifferent;
                    }
                    function warnForUnmatchedText$1(textNode, text) {
                        {
                            warnForTextDifference(textNode.nodeValue, text);
                        }
                    }
                    function warnForDeletedHydratableElement$1(parentNode, child) {
                        {
                            if (didWarnInvalidHydration) {
                                return;
                            }
                            didWarnInvalidHydration = true;
                            warning(false, "Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
                        }
                    }
                    function warnForDeletedHydratableText$1(parentNode, child) {
                        {
                            if (didWarnInvalidHydration) {
                                return;
                            }
                            didWarnInvalidHydration = true;
                            warning(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
                        }
                    }
                    function warnForInsertedHydratedElement$1(parentNode, tag, props) {
                        {
                            if (didWarnInvalidHydration) {
                                return;
                            }
                            didWarnInvalidHydration = true;
                            warning(false, "Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
                        }
                    }
                    function warnForInsertedHydratedText$1(parentNode, text) {
                        {
                            if (text === "") {
                                return;
                            }
                            if (didWarnInvalidHydration) {
                                return;
                            }
                            didWarnInvalidHydration = true;
                            warning(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
                        }
                    }
                    function restoreControlledState(domElement, tag, props) {
                        switch (tag) {
                          case "input":
                            restoreControlledState$1(domElement, props);
                            return;

                          case "textarea":
                            restoreControlledState$3(domElement, props);
                            return;

                          case "select":
                            restoreControlledState$2(domElement, props);
                            return;
                        }
                    }
                    var ReactDOMFiberComponent = Object.freeze({
                        createElement: createElement$1,
                        createTextNode: createTextNode$1,
                        setInitialProperties: setInitialProperties$1,
                        diffProperties: diffProperties$1,
                        updateProperties: updateProperties$1,
                        diffHydratedProperties: diffHydratedProperties$1,
                        diffHydratedText: diffHydratedText$1,
                        warnForUnmatchedText: warnForUnmatchedText$1,
                        warnForDeletedHydratableElement: warnForDeletedHydratableElement$1,
                        warnForDeletedHydratableText: warnForDeletedHydratableText$1,
                        warnForInsertedHydratedElement: warnForInsertedHydratedElement$1,
                        warnForInsertedHydratedText: warnForInsertedHydratedText$1,
                        restoreControlledState: restoreControlledState
                    });
                    var getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
                    var validateDOMNesting = emptyFunction;
                    {
                        var specialTags = [ "address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp" ];
                        var inScopeTags = [ "applet", "caption", "html", "table", "td", "th", "marquee", "object", "template", "foreignObject", "desc", "title" ];
                        var buttonScopeTags = inScopeTags.concat([ "button" ]);
                        var impliedEndTags = [ "dd", "dt", "li", "option", "optgroup", "p", "rp", "rt" ];
                        var emptyAncestorInfo = {
                            current: null,
                            formTag: null,
                            aTagInScope: null,
                            buttonTagInScope: null,
                            nobrTagInScope: null,
                            pTagInButtonScope: null,
                            listItemTagAutoclosing: null,
                            dlItemTagAutoclosing: null
                        };
                        var updatedAncestorInfo$1 = function(oldInfo, tag, instance) {
                            var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
                            var info = {
                                tag: tag,
                                instance: instance
                            };
                            if (inScopeTags.indexOf(tag) !== -1) {
                                ancestorInfo.aTagInScope = null;
                                ancestorInfo.buttonTagInScope = null;
                                ancestorInfo.nobrTagInScope = null;
                            }
                            if (buttonScopeTags.indexOf(tag) !== -1) {
                                ancestorInfo.pTagInButtonScope = null;
                            }
                            if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
                                ancestorInfo.listItemTagAutoclosing = null;
                                ancestorInfo.dlItemTagAutoclosing = null;
                            }
                            ancestorInfo.current = info;
                            if (tag === "form") {
                                ancestorInfo.formTag = info;
                            }
                            if (tag === "a") {
                                ancestorInfo.aTagInScope = info;
                            }
                            if (tag === "button") {
                                ancestorInfo.buttonTagInScope = info;
                            }
                            if (tag === "nobr") {
                                ancestorInfo.nobrTagInScope = info;
                            }
                            if (tag === "p") {
                                ancestorInfo.pTagInButtonScope = info;
                            }
                            if (tag === "li") {
                                ancestorInfo.listItemTagAutoclosing = info;
                            }
                            if (tag === "dd" || tag === "dt") {
                                ancestorInfo.dlItemTagAutoclosing = info;
                            }
                            return ancestorInfo;
                        };
                        var isTagValidWithParent = function(tag, parentTag) {
                            switch (parentTag) {
                              case "select":
                                return tag === "option" || tag === "optgroup" || tag === "#text";

                              case "optgroup":
                                return tag === "option" || tag === "#text";

                              case "option":
                                return tag === "#text";

                              case "tr":
                                return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";

                              case "tbody":
                              case "thead":
                              case "tfoot":
                                return tag === "tr" || tag === "style" || tag === "script" || tag === "template";

                              case "colgroup":
                                return tag === "col" || tag === "template";

                              case "table":
                                return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";

                              case "head":
                                return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";

                              case "html":
                                return tag === "head" || tag === "body";

                              case "#document":
                                return tag === "html";
                            }
                            switch (tag) {
                              case "h1":
                              case "h2":
                              case "h3":
                              case "h4":
                              case "h5":
                              case "h6":
                                return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";

                              case "rp":
                              case "rt":
                                return impliedEndTags.indexOf(parentTag) === -1;

                              case "body":
                              case "caption":
                              case "col":
                              case "colgroup":
                              case "frame":
                              case "head":
                              case "html":
                              case "tbody":
                              case "td":
                              case "tfoot":
                              case "th":
                              case "thead":
                              case "tr":
                                return parentTag == null;
                            }
                            return true;
                        };
                        var findInvalidAncestorForTag = function(tag, ancestorInfo) {
                            switch (tag) {
                              case "address":
                              case "article":
                              case "aside":
                              case "blockquote":
                              case "center":
                              case "details":
                              case "dialog":
                              case "dir":
                              case "div":
                              case "dl":
                              case "fieldset":
                              case "figcaption":
                              case "figure":
                              case "footer":
                              case "header":
                              case "hgroup":
                              case "main":
                              case "menu":
                              case "nav":
                              case "ol":
                              case "p":
                              case "section":
                              case "summary":
                              case "ul":
                              case "pre":
                              case "listing":
                              case "table":
                              case "hr":
                              case "xmp":
                              case "h1":
                              case "h2":
                              case "h3":
                              case "h4":
                              case "h5":
                              case "h6":
                                return ancestorInfo.pTagInButtonScope;

                              case "form":
                                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

                              case "li":
                                return ancestorInfo.listItemTagAutoclosing;

                              case "dd":
                              case "dt":
                                return ancestorInfo.dlItemTagAutoclosing;

                              case "button":
                                return ancestorInfo.buttonTagInScope;

                              case "a":
                                return ancestorInfo.aTagInScope;

                              case "nobr":
                                return ancestorInfo.nobrTagInScope;
                            }
                            return null;
                        };
                        var didWarn = {};
                        validateDOMNesting = function(childTag, childText, ancestorInfo) {
                            ancestorInfo = ancestorInfo || emptyAncestorInfo;
                            var parentInfo = ancestorInfo.current;
                            var parentTag = parentInfo && parentInfo.tag;
                            if (childText != null) {
                                warning(childTag == null, "validateDOMNesting: when childText is passed, childTag should be null");
                                childTag = "#text";
                            }
                            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
                            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
                            var invalidParentOrAncestor = invalidParent || invalidAncestor;
                            if (!invalidParentOrAncestor) {
                                return;
                            }
                            var ancestorTag = invalidParentOrAncestor.tag;
                            var addendum = getCurrentFiberStackAddendum$6();
                            var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag + "|" + addendum;
                            if (didWarn[warnKey]) {
                                return;
                            }
                            didWarn[warnKey] = true;
                            var tagDisplayName = childTag;
                            var whitespaceInfo = "";
                            if (childTag === "#text") {
                                if (/\S/.test(childText)) {
                                    tagDisplayName = "Text nodes";
                                } else {
                                    tagDisplayName = "Whitespace text nodes";
                                    whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + "each line of your source code.";
                                }
                            } else {
                                tagDisplayName = "<" + childTag + ">";
                            }
                            if (invalidParent) {
                                var info = "";
                                if (ancestorTag === "table" && childTag === "tr") {
                                    info += " Add a <tbody> to your code to match the DOM tree generated by " + "the browser.";
                                }
                                warning(false, "validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
                            } else {
                                warning(false, "validateDOMNesting(...): %s cannot appear as a descendant of " + "<%s>.%s", tagDisplayName, ancestorTag, addendum);
                            }
                        };
                        validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;
                        validateDOMNesting.isTagValidInContext = function(tag, ancestorInfo) {
                            ancestorInfo = ancestorInfo || emptyAncestorInfo;
                            var parentInfo = ancestorInfo.current;
                            var parentTag = parentInfo && parentInfo.tag;
                            return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
                        };
                    }
                    var validateDOMNesting$1 = validateDOMNesting;
                    var createElement = createElement$1;
                    var createTextNode = createTextNode$1;
                    var setInitialProperties = setInitialProperties$1;
                    var diffProperties = diffProperties$1;
                    var updateProperties = updateProperties$1;
                    var diffHydratedProperties = diffHydratedProperties$1;
                    var diffHydratedText = diffHydratedText$1;
                    var warnForUnmatchedText = warnForUnmatchedText$1;
                    var warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;
                    var warnForDeletedHydratableText = warnForDeletedHydratableText$1;
                    var warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;
                    var warnForInsertedHydratedText = warnForInsertedHydratedText$1;
                    var updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;
                    var precacheFiberNode = precacheFiberNode$1;
                    var updateFiberProps = updateFiberProps$1;
                    {
                        var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
                        if (typeof Map !== "function" || Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
                            warning(false, "React depends on Map and Set built-in types. Make sure that you load a " + "polyfill in older browsers. http://fb.me/react-polyfills");
                        }
                    }
                    injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);
                    var eventsEnabled = null;
                    var selectionInformation = null;
                    function isValidContainer(node) {
                        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
                    }
                    function getReactRootElementInContainer(container) {
                        if (!container) {
                            return null;
                        }
                        if (container.nodeType === DOCUMENT_NODE) {
                            return container.documentElement;
                        } else {
                            return container.firstChild;
                        }
                    }
                    function shouldHydrateDueToLegacyHeuristic(container) {
                        var rootElement = getReactRootElementInContainer(container);
                        return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
                    }
                    function shouldAutoFocusHostComponent(type, props) {
                        switch (type) {
                          case "button":
                          case "input":
                          case "select":
                          case "textarea":
                            return !!props.autoFocus;
                        }
                        return false;
                    }
                    var DOMRenderer = reactReconciler({
                        getRootHostContext: function(rootContainerInstance) {
                            var type = void 0;
                            var namespace = void 0;
                            var nodeType = rootContainerInstance.nodeType;
                            switch (nodeType) {
                              case DOCUMENT_NODE:
                              case DOCUMENT_FRAGMENT_NODE:
                                {
                                    type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                                    var root = rootContainerInstance.documentElement;
                                    namespace = root ? root.namespaceURI : getChildNamespace(null, "");
                                    break;
                                }

                              default:
                                {
                                    var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                                    var ownNamespace = container.namespaceURI || null;
                                    type = container.tagName;
                                    namespace = getChildNamespace(ownNamespace, type);
                                    break;
                                }
                            }
                            {
                                var validatedTag = type.toLowerCase();
                                var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);
                                return {
                                    namespace: namespace,
                                    ancestorInfo: _ancestorInfo
                                };
                            }
                            return namespace;
                        },
                        getChildHostContext: function(parentHostContext, type) {
                            {
                                var parentHostContextDev = parentHostContext;
                                var _namespace = getChildNamespace(parentHostContextDev.namespace, type);
                                var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);
                                return {
                                    namespace: _namespace,
                                    ancestorInfo: _ancestorInfo2
                                };
                            }
                            var parentNamespace = parentHostContext;
                            return getChildNamespace(parentNamespace, type);
                        },
                        getPublicInstance: function(instance) {
                            return instance;
                        },
                        prepareForCommit: function() {
                            eventsEnabled = isEnabled();
                            selectionInformation = getSelectionInformation();
                            setEnabled(false);
                        },
                        resetAfterCommit: function() {
                            restoreSelection(selectionInformation);
                            selectionInformation = null;
                            setEnabled(eventsEnabled);
                            eventsEnabled = null;
                        },
                        createInstance: function(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
                            var parentNamespace = void 0;
                            {
                                var hostContextDev = hostContext;
                                validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);
                                if (typeof props.children === "string" || typeof props.children === "number") {
                                    var string = "" + props.children;
                                    var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
                                    validateDOMNesting$1(null, string, ownAncestorInfo);
                                }
                                parentNamespace = hostContextDev.namespace;
                            }
                            var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
                            precacheFiberNode(internalInstanceHandle, domElement);
                            updateFiberProps(domElement, props);
                            return domElement;
                        },
                        appendInitialChild: function(parentInstance, child) {
                            parentInstance.appendChild(child);
                        },
                        finalizeInitialChildren: function(domElement, type, props, rootContainerInstance) {
                            setInitialProperties(domElement, type, props, rootContainerInstance);
                            return shouldAutoFocusHostComponent(type, props);
                        },
                        prepareUpdate: function(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
                            {
                                var hostContextDev = hostContext;
                                if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                                    var string = "" + newProps.children;
                                    var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
                                    validateDOMNesting$1(null, string, ownAncestorInfo);
                                }
                            }
                            return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
                        },
                        shouldSetTextContent: function(type, props) {
                            return type === "textarea" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === "string";
                        },
                        shouldDeprioritizeSubtree: function(type, props) {
                            return !!props.hidden;
                        },
                        createTextInstance: function(text, rootContainerInstance, hostContext, internalInstanceHandle) {
                            {
                                var hostContextDev = hostContext;
                                validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);
                            }
                            var textNode = createTextNode(text, rootContainerInstance);
                            precacheFiberNode(internalInstanceHandle, textNode);
                            return textNode;
                        },
                        now: now,
                        mutation: {
                            commitMount: function(domElement, type, newProps, internalInstanceHandle) {
                                domElement.focus();
                            },
                            commitUpdate: function(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
                                updateFiberProps(domElement, newProps);
                                updateProperties(domElement, updatePayload, type, oldProps, newProps);
                            },
                            resetTextContent: function(domElement) {
                                domElement.textContent = "";
                            },
                            commitTextUpdate: function(textInstance, oldText, newText) {
                                textInstance.nodeValue = newText;
                            },
                            appendChild: function(parentInstance, child) {
                                parentInstance.appendChild(child);
                            },
                            appendChildToContainer: function(container, child) {
                                if (container.nodeType === COMMENT_NODE) {
                                    container.parentNode.insertBefore(child, container);
                                } else {
                                    container.appendChild(child);
                                }
                            },
                            insertBefore: function(parentInstance, child, beforeChild) {
                                parentInstance.insertBefore(child, beforeChild);
                            },
                            insertInContainerBefore: function(container, child, beforeChild) {
                                if (container.nodeType === COMMENT_NODE) {
                                    container.parentNode.insertBefore(child, beforeChild);
                                } else {
                                    container.insertBefore(child, beforeChild);
                                }
                            },
                            removeChild: function(parentInstance, child) {
                                parentInstance.removeChild(child);
                            },
                            removeChildFromContainer: function(container, child) {
                                if (container.nodeType === COMMENT_NODE) {
                                    container.parentNode.removeChild(child);
                                } else {
                                    container.removeChild(child);
                                }
                            }
                        },
                        hydration: {
                            canHydrateInstance: function(instance, type, props) {
                                if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
                                    return null;
                                }
                                return instance;
                            },
                            canHydrateTextInstance: function(instance, text) {
                                if (text === "" || instance.nodeType !== TEXT_NODE) {
                                    return null;
                                }
                                return instance;
                            },
                            getNextHydratableSibling: function(instance) {
                                var node = instance.nextSibling;
                                while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {
                                    node = node.nextSibling;
                                }
                                return node;
                            },
                            getFirstHydratableChild: function(parentInstance) {
                                var next = parentInstance.firstChild;
                                while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {
                                    next = next.nextSibling;
                                }
                                return next;
                            },
                            hydrateInstance: function(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
                                precacheFiberNode(internalInstanceHandle, instance);
                                updateFiberProps(instance, props);
                                var parentNamespace = void 0;
                                {
                                    var hostContextDev = hostContext;
                                    parentNamespace = hostContextDev.namespace;
                                }
                                return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
                            },
                            hydrateTextInstance: function(textInstance, text, internalInstanceHandle) {
                                precacheFiberNode(internalInstanceHandle, textInstance);
                                return diffHydratedText(textInstance, text);
                            },
                            didNotMatchHydratedContainerTextInstance: function(parentContainer, textInstance, text) {
                                {
                                    warnForUnmatchedText(textInstance, text);
                                }
                            },
                            didNotMatchHydratedTextInstance: function(parentType, parentProps, parentInstance, textInstance, text) {
                                if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                                    warnForUnmatchedText(textInstance, text);
                                }
                            },
                            didNotHydrateContainerInstance: function(parentContainer, instance) {
                                {
                                    if (instance.nodeType === 1) {
                                        warnForDeletedHydratableElement(parentContainer, instance);
                                    } else {
                                        warnForDeletedHydratableText(parentContainer, instance);
                                    }
                                }
                            },
                            didNotHydrateInstance: function(parentType, parentProps, parentInstance, instance) {
                                if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                                    if (instance.nodeType === 1) {
                                        warnForDeletedHydratableElement(parentInstance, instance);
                                    } else {
                                        warnForDeletedHydratableText(parentInstance, instance);
                                    }
                                }
                            },
                            didNotFindHydratableContainerInstance: function(parentContainer, type, props) {
                                {
                                    warnForInsertedHydratedElement(parentContainer, type, props);
                                }
                            },
                            didNotFindHydratableContainerTextInstance: function(parentContainer, text) {
                                {
                                    warnForInsertedHydratedText(parentContainer, text);
                                }
                            },
                            didNotFindHydratableInstance: function(parentType, parentProps, parentInstance, type, props) {
                                if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                                    warnForInsertedHydratedElement(parentInstance, type, props);
                                }
                            },
                            didNotFindHydratableTextInstance: function(parentType, parentProps, parentInstance, text) {
                                if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                                    warnForInsertedHydratedText(parentInstance, text);
                                }
                            }
                        },
                        scheduleDeferredCallback: rIC,
                        cancelDeferredCallback: cIC,
                        useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM
                    });
                    injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);
                    var warnedAboutHydrateAPI = false;
                    function renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
                        !isValidContainer(container) ? invariant(false, "Target container is not a DOM element.") : void 0;
                        {
                            if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
                                var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);
                                if (hostInstance) {
                                    warning(hostInstance.parentNode === container, "render(...): It looks like the React-rendered content of this " + "container was removed without using React. This is not " + "supported and will cause errors. Instead, call " + "ReactDOM.unmountComponentAtNode to empty a container.");
                                }
                            }
                            var isRootRenderedBySomeReact = !!container._reactRootContainer;
                            var rootEl = getReactRootElementInContainer(container);
                            var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));
                            warning(!hasNonRootReactChild || isRootRenderedBySomeReact, "render(...): Replacing React-rendered children with a new root " + "component. If you intended to update the children of this node, " + "you should instead have the existing children update their state " + "and render the new components instead of calling ReactDOM.render.");
                            warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== "BODY", "render(): Rendering components directly into document.body is " + "discouraged, since its children are often manipulated by third-party " + "scripts and browser extensions. This may lead to subtle " + "reconciliation issues. Try rendering into a container element created " + "for your app.");
                        }
                        var root = container._reactRootContainer;
                        if (!root) {
                            var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
                            if (!shouldHydrate) {
                                var warned = false;
                                var rootSibling = void 0;
                                while (rootSibling = container.lastChild) {
                                    {
                                        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
                                            warned = true;
                                            warning(false, "render(): Target node has markup rendered by React, but there " + "are unrelated nodes as well. This is most commonly caused by " + "white-space inserted around server-rendered markup.");
                                        }
                                    }
                                    container.removeChild(rootSibling);
                                }
                            }
                            {
                                if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
                                    warnedAboutHydrateAPI = true;
                                    lowPriorityWarning$1(false, "render(): Calling ReactDOM.render() to hydrate server-rendered markup " + "will stop working in React v17. Replace the ReactDOM.render() call " + "with ReactDOM.hydrate() if you want React to attach to the server HTML.");
                                }
                            }
                            var newRoot = DOMRenderer.createContainer(container, shouldHydrate);
                            root = container._reactRootContainer = newRoot;
                            DOMRenderer.unbatchedUpdates(function() {
                                DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);
                            });
                        } else {
                            DOMRenderer.updateContainer(children, root, parentComponent, callback);
                        }
                        return DOMRenderer.getPublicRootInstance(root);
                    }
                    function createPortal(children, container) {
                        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                        !isValidContainer(container) ? invariant(false, "Target container is not a DOM element.") : void 0;
                        return createPortal$1(children, container, null, key);
                    }
                    function ReactRoot(container, hydrate) {
                        var root = DOMRenderer.createContainer(container, hydrate);
                        this._reactRootContainer = root;
                    }
                    ReactRoot.prototype.render = function(children, callback) {
                        var root = this._reactRootContainer;
                        DOMRenderer.updateContainer(children, root, null, callback);
                    };
                    ReactRoot.prototype.unmount = function(callback) {
                        var root = this._reactRootContainer;
                        DOMRenderer.updateContainer(null, root, null, callback);
                    };
                    var ReactDOM = {
                        createPortal: createPortal,
                        findDOMNode: function(componentOrElement) {
                            {
                                var owner = ReactCurrentOwner.current;
                                if (owner !== null) {
                                    var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                                    warning(warnedAboutRefsInRender, "%s is accessing findDOMNode inside its render(). " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(owner) || "A component");
                                    owner.stateNode._warnedAboutRefsInRender = true;
                                }
                            }
                            if (componentOrElement == null) {
                                return null;
                            }
                            if (componentOrElement.nodeType === ELEMENT_NODE) {
                                return componentOrElement;
                            }
                            var inst = get(componentOrElement);
                            if (inst) {
                                return DOMRenderer.findHostInstance(inst);
                            }
                            if (typeof componentOrElement.render === "function") {
                                invariant(false, "Unable to find node on an unmounted component.");
                            } else {
                                invariant(false, "Element appears to be neither ReactComponent nor DOMNode. Keys: %s", Object.keys(componentOrElement));
                            }
                        },
                        hydrate: function(element, container, callback) {
                            return renderSubtreeIntoContainer(null, element, container, true, callback);
                        },
                        render: function(element, container, callback) {
                            return renderSubtreeIntoContainer(null, element, container, false, callback);
                        },
                        unstable_renderSubtreeIntoContainer: function(parentComponent, element, containerNode, callback) {
                            !(parentComponent != null && has(parentComponent)) ? invariant(false, "parentComponent must be a valid React Component") : void 0;
                            return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
                        },
                        unmountComponentAtNode: function(container) {
                            !isValidContainer(container) ? invariant(false, "unmountComponentAtNode(...): Target container is not a DOM element.") : void 0;
                            if (container._reactRootContainer) {
                                {
                                    var rootEl = getReactRootElementInContainer(container);
                                    var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
                                    warning(!renderedByDifferentReact, "unmountComponentAtNode(): The node you're attempting to unmount " + "was rendered by another copy of React.");
                                }
                                DOMRenderer.unbatchedUpdates(function() {
                                    renderSubtreeIntoContainer(null, null, container, false, function() {
                                        container._reactRootContainer = null;
                                    });
                                });
                                return true;
                            } else {
                                {
                                    var _rootEl = getReactRootElementInContainer(container);
                                    var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));
                                    var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;
                                    warning(!hasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + "was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead " + "of its container." : "Instead, have the parent component update its state and " + "rerender in order to remove this component.");
                                }
                                return false;
                            }
                        },
                        unstable_createPortal: createPortal,
                        unstable_batchedUpdates: batchedUpdates,
                        unstable_deferredUpdates: DOMRenderer.deferredUpdates,
                        flushSync: DOMRenderer.flushSync,
                        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                            EventPluginHub: EventPluginHub,
                            EventPluginRegistry: EventPluginRegistry,
                            EventPropagators: EventPropagators,
                            ReactControlledComponent: ReactControlledComponent,
                            ReactDOMComponentTree: ReactDOMComponentTree,
                            ReactDOMEventListener: ReactDOMEventListener
                        }
                    };
                    if (enableCreateRoot) {
                        ReactDOM.createRoot = function createRoot(container, options) {
                            var hydrate = options != null && options.hydrate === true;
                            return new ReactRoot(container, hydrate);
                        };
                    }
                    var foundDevTools = DOMRenderer.injectIntoDevTools({
                        findFiberByHostInstance: getClosestInstanceFromNode,
                        bundleType: 1,
                        version: ReactVersion,
                        rendererPackageName: "react-dom"
                    });
                    {
                        if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {
                            if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                                var protocol = window.location.protocol;
                                if (/^(https?|file):$/.test(protocol)) {
                                    console.info("%cDownload the React DevTools " + "for a better development experience: " + "https://fb.me/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): " + "https://fb.me/react-devtools-faq" : ""), "font-weight:bold");
                                }
                            }
                        }
                    }
                    var ReactDOM$2 = Object.freeze({
                        default: ReactDOM
                    });
                    var ReactDOM$3 = ReactDOM$2 && ReactDOM || ReactDOM$2;
                    var reactDom = ReactDOM$3["default"] ? ReactDOM$3["default"] : ReactDOM$3;
                    module.exports = reactDom;
                })();
            }
        }).call(this, require("_process"));
    }, {
        _process: 19,
        "fbjs/lib/EventListener": 1,
        "fbjs/lib/ExecutionEnvironment": 2,
        "fbjs/lib/camelizeStyleName": 4,
        "fbjs/lib/containsNode": 5,
        "fbjs/lib/emptyFunction": 6,
        "fbjs/lib/emptyObject": 7,
        "fbjs/lib/focusNode": 8,
        "fbjs/lib/getActiveElement": 9,
        "fbjs/lib/hyphenateStyleName": 11,
        "fbjs/lib/invariant": 12,
        "fbjs/lib/shallowEqual": 15,
        "fbjs/lib/warning": 16,
        "object-assign": 18,
        "prop-types/checkPropTypes": 20,
        react: "react"
    } ],
    23: [ function(require, module, exports) {
        "use strict";
        var aa = require("react"), l = require("fbjs/lib/ExecutionEnvironment"), B = require("object-assign"), C = require("fbjs/lib/emptyFunction"), ba = require("fbjs/lib/EventListener"), da = require("fbjs/lib/getActiveElement"), ea = require("fbjs/lib/shallowEqual"), fa = require("fbjs/lib/containsNode"), ia = require("fbjs/lib/focusNode"), D = require("fbjs/lib/emptyObject");
        function E(a) {
            for (var b = arguments.length - 1, c = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant=" + a, d = 0; d < b; d++) c += "&args[]=" + encodeURIComponent(arguments[d + 1]);
            b = Error(c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");
            b.name = "Invariant Violation";
            b.framesToPop = 1;
            throw b;
        }
        aa ? void 0 : E("227");
        var oa = {
            children: !0,
            dangerouslySetInnerHTML: !0,
            defaultValue: !0,
            defaultChecked: !0,
            innerHTML: !0,
            suppressContentEditableWarning: !0,
            suppressHydrationWarning: !0,
            style: !0
        };
        function pa(a, b) {
            return (a & b) === b;
        }
        var ta = {
            MUST_USE_PROPERTY: 1,
            HAS_BOOLEAN_VALUE: 4,
            HAS_NUMERIC_VALUE: 8,
            HAS_POSITIVE_NUMERIC_VALUE: 24,
            HAS_OVERLOADED_BOOLEAN_VALUE: 32,
            HAS_STRING_BOOLEAN_VALUE: 64,
            injectDOMPropertyConfig: function(a) {
                var b = ta, c = a.Properties || {}, d = a.DOMAttributeNamespaces || {}, e = a.DOMAttributeNames || {};
                a = a.DOMMutationMethods || {};
                for (var f in c) {
                    ua.hasOwnProperty(f) ? E("48", f) : void 0;
                    var g = f.toLowerCase(), h = c[f];
                    g = {
                        attributeName: g,
                        attributeNamespace: null,
                        propertyName: f,
                        mutationMethod: null,
                        mustUseProperty: pa(h, b.MUST_USE_PROPERTY),
                        hasBooleanValue: pa(h, b.HAS_BOOLEAN_VALUE),
                        hasNumericValue: pa(h, b.HAS_NUMERIC_VALUE),
                        hasPositiveNumericValue: pa(h, b.HAS_POSITIVE_NUMERIC_VALUE),
                        hasOverloadedBooleanValue: pa(h, b.HAS_OVERLOADED_BOOLEAN_VALUE),
                        hasStringBooleanValue: pa(h, b.HAS_STRING_BOOLEAN_VALUE)
                    };
                    1 >= g.hasBooleanValue + g.hasNumericValue + g.hasOverloadedBooleanValue ? void 0 : E("50", f);
                    e.hasOwnProperty(f) && (g.attributeName = e[f]);
                    d.hasOwnProperty(f) && (g.attributeNamespace = d[f]);
                    a.hasOwnProperty(f) && (g.mutationMethod = a[f]);
                    ua[f] = g;
                }
            }
        }, ua = {};
        function va(a, b) {
            if (oa.hasOwnProperty(a) || 2 < a.length && ("o" === a[0] || "O" === a[0]) && ("n" === a[1] || "N" === a[1])) return !1;
            if (null === b) return !0;
            switch (typeof b) {
              case "boolean":
                return oa.hasOwnProperty(a) ? a = !0 : (b = wa(a)) ? a = b.hasBooleanValue || b.hasStringBooleanValue || b.hasOverloadedBooleanValue : (a = a.toLowerCase().slice(0, 5), 
                a = "data-" === a || "aria-" === a), a;

              case "undefined":
              case "number":
              case "string":
              case "object":
                return !0;

              default:
                return !1;
            }
        }
        function wa(a) {
            return ua.hasOwnProperty(a) ? ua[a] : null;
        }
        var xa = ta, ya = xa.MUST_USE_PROPERTY, K = xa.HAS_BOOLEAN_VALUE, za = xa.HAS_NUMERIC_VALUE, Aa = xa.HAS_POSITIVE_NUMERIC_VALUE, Ba = xa.HAS_OVERLOADED_BOOLEAN_VALUE, Ca = xa.HAS_STRING_BOOLEAN_VALUE, Da = {
            Properties: {
                allowFullScreen: K,
                async: K,
                autoFocus: K,
                autoPlay: K,
                capture: Ba,
                checked: ya | K,
                cols: Aa,
                contentEditable: Ca,
                controls: K,
                default: K,
                defer: K,
                disabled: K,
                download: Ba,
                draggable: Ca,
                formNoValidate: K,
                hidden: K,
                loop: K,
                multiple: ya | K,
                muted: ya | K,
                noValidate: K,
                open: K,
                playsInline: K,
                readOnly: K,
                required: K,
                reversed: K,
                rows: Aa,
                rowSpan: za,
                scoped: K,
                seamless: K,
                selected: ya | K,
                size: Aa,
                start: za,
                span: Aa,
                spellCheck: Ca,
                style: 0,
                tabIndex: 0,
                itemScope: K,
                acceptCharset: 0,
                className: 0,
                htmlFor: 0,
                httpEquiv: 0,
                value: Ca
            },
            DOMAttributeNames: {
                acceptCharset: "accept-charset",
                className: "class",
                htmlFor: "for",
                httpEquiv: "http-equiv"
            },
            DOMMutationMethods: {
                value: function(a, b) {
                    if (null == b) return a.removeAttribute("value");
                    "number" !== a.type || !1 === a.hasAttribute("value") ? a.setAttribute("value", "" + b) : a.validity && !a.validity.badInput && a.ownerDocument.activeElement !== a && a.setAttribute("value", "" + b);
                }
            }
        }, Ea = xa.HAS_STRING_BOOLEAN_VALUE, M = {
            xlink: "http://www.w3.org/1999/xlink",
            xml: "http://www.w3.org/XML/1998/namespace"
        }, Ga = {
            Properties: {
                autoReverse: Ea,
                externalResourcesRequired: Ea,
                preserveAlpha: Ea
            },
            DOMAttributeNames: {
                autoReverse: "autoReverse",
                externalResourcesRequired: "externalResourcesRequired",
                preserveAlpha: "preserveAlpha"
            },
            DOMAttributeNamespaces: {
                xlinkActuate: M.xlink,
                xlinkArcrole: M.xlink,
                xlinkHref: M.xlink,
                xlinkRole: M.xlink,
                xlinkShow: M.xlink,
                xlinkTitle: M.xlink,
                xlinkType: M.xlink,
                xmlBase: M.xml,
                xmlLang: M.xml,
                xmlSpace: M.xml
            }
        }, Ha = /[\-\:]([a-z])/g;
        function Ia(a) {
            return a[1].toUpperCase();
        }
        "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function(a) {
            var b = a.replace(Ha, Ia);
            Ga.Properties[b] = 0;
            Ga.DOMAttributeNames[b] = a;
        });
        xa.injectDOMPropertyConfig(Da);
        xa.injectDOMPropertyConfig(Ga);
        var P = {
            _caughtError: null,
            _hasCaughtError: !1,
            _rethrowError: null,
            _hasRethrowError: !1,
            injection: {
                injectErrorUtils: function(a) {
                    "function" !== typeof a.invokeGuardedCallback ? E("197") : void 0;
                    Ja = a.invokeGuardedCallback;
                }
            },
            invokeGuardedCallback: function(a, b, c, d, e, f, g, h, k) {
                Ja.apply(P, arguments);
            },
            invokeGuardedCallbackAndCatchFirstError: function(a, b, c, d, e, f, g, h, k) {
                P.invokeGuardedCallback.apply(this, arguments);
                if (P.hasCaughtError()) {
                    var q = P.clearCaughtError();
                    P._hasRethrowError || (P._hasRethrowError = !0, P._rethrowError = q);
                }
            },
            rethrowCaughtError: function() {
                return Ka.apply(P, arguments);
            },
            hasCaughtError: function() {
                return P._hasCaughtError;
            },
            clearCaughtError: function() {
                if (P._hasCaughtError) {
                    var a = P._caughtError;
                    P._caughtError = null;
                    P._hasCaughtError = !1;
                    return a;
                }
                E("198");
            }
        };
        function Ja(a, b, c, d, e, f, g, h, k) {
            P._hasCaughtError = !1;
            P._caughtError = null;
            var q = Array.prototype.slice.call(arguments, 3);
            try {
                b.apply(c, q);
            } catch (v) {
                P._caughtError = v, P._hasCaughtError = !0;
            }
        }
        function Ka() {
            if (P._hasRethrowError) {
                var a = P._rethrowError;
                P._rethrowError = null;
                P._hasRethrowError = !1;
                throw a;
            }
        }
        var La = null, Ma = {};
        function Na() {
            if (La) for (var a in Ma) {
                var b = Ma[a], c = La.indexOf(a);
                -1 < c ? void 0 : E("96", a);
                if (!Oa[c]) {
                    b.extractEvents ? void 0 : E("97", a);
                    Oa[c] = b;
                    c = b.eventTypes;
                    for (var d in c) {
                        var e = void 0;
                        var f = c[d], g = b, h = d;
                        Pa.hasOwnProperty(h) ? E("99", h) : void 0;
                        Pa[h] = f;
                        var k = f.phasedRegistrationNames;
                        if (k) {
                            for (e in k) k.hasOwnProperty(e) && Qa(k[e], g, h);
                            e = !0;
                        } else f.registrationName ? (Qa(f.registrationName, g, h), e = !0) : e = !1;
                        e ? void 0 : E("98", d, a);
                    }
                }
            }
        }
        function Qa(a, b, c) {
            Ra[a] ? E("100", a) : void 0;
            Ra[a] = b;
            Sa[a] = b.eventTypes[c].dependencies;
        }
        var Oa = [], Pa = {}, Ra = {}, Sa = {};
        function Ta(a) {
            La ? E("101") : void 0;
            La = Array.prototype.slice.call(a);
            Na();
        }
        function Ua(a) {
            var b = !1, c;
            for (c in a) if (a.hasOwnProperty(c)) {
                var d = a[c];
                Ma.hasOwnProperty(c) && Ma[c] === d || (Ma[c] ? E("102", c) : void 0, Ma[c] = d, 
                b = !0);
            }
            b && Na();
        }
        var Va = Object.freeze({
            plugins: Oa,
            eventNameDispatchConfigs: Pa,
            registrationNameModules: Ra,
            registrationNameDependencies: Sa,
            possibleRegistrationNames: null,
            injectEventPluginOrder: Ta,
            injectEventPluginsByName: Ua
        }), Wa = null, Xa = null, Ya = null;
        function Za(a, b, c, d) {
            b = a.type || "unknown-event";
            a.currentTarget = Ya(d);
            P.invokeGuardedCallbackAndCatchFirstError(b, c, void 0, a);
            a.currentTarget = null;
        }
        function $a(a, b) {
            null == b ? E("30") : void 0;
            if (null == a) return b;
            if (Array.isArray(a)) {
                if (Array.isArray(b)) return a.push.apply(a, b), a;
                a.push(b);
                return a;
            }
            return Array.isArray(b) ? [ a ].concat(b) : [ a, b ];
        }
        function ab(a, b, c) {
            Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a);
        }
        var bb = null;
        function cb(a, b) {
            if (a) {
                var c = a._dispatchListeners, d = a._dispatchInstances;
                if (Array.isArray(c)) for (var e = 0; e < c.length && !a.isPropagationStopped(); e++) Za(a, b, c[e], d[e]); else c && Za(a, b, c, d);
                a._dispatchListeners = null;
                a._dispatchInstances = null;
                a.isPersistent() || a.constructor.release(a);
            }
        }
        function db(a) {
            return cb(a, !0);
        }
        function gb(a) {
            return cb(a, !1);
        }
        var hb = {
            injectEventPluginOrder: Ta,
            injectEventPluginsByName: Ua
        };
        function ib(a, b) {
            var c = a.stateNode;
            if (!c) return null;
            var d = Wa(c);
            if (!d) return null;
            c = d[b];
            a: switch (b) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
                (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
                a = !d;
                break a;

              default:
                a = !1;
            }
            if (a) return null;
            c && "function" !== typeof c ? E("231", b, typeof c) : void 0;
            return c;
        }
        function jb(a, b, c, d) {
            for (var e, f = 0; f < Oa.length; f++) {
                var g = Oa[f];
                g && (g = g.extractEvents(a, b, c, d)) && (e = $a(e, g));
            }
            return e;
        }
        function kb(a) {
            a && (bb = $a(bb, a));
        }
        function lb(a) {
            var b = bb;
            bb = null;
            b && (a ? ab(b, db) : ab(b, gb), bb ? E("95") : void 0, P.rethrowCaughtError());
        }
        var mb = Object.freeze({
            injection: hb,
            getListener: ib,
            extractEvents: jb,
            enqueueEvents: kb,
            processEventQueue: lb
        }), nb = Math.random().toString(36).slice(2), Q = "__reactInternalInstance$" + nb, ob = "__reactEventHandlers$" + nb;
        function pb(a) {
            if (a[Q]) return a[Q];
            for (var b = []; !a[Q]; ) if (b.push(a), a.parentNode) a = a.parentNode; else return null;
            var c = void 0, d = a[Q];
            if (5 === d.tag || 6 === d.tag) return d;
            for (;a && (d = a[Q]); a = b.pop()) c = d;
            return c;
        }
        function qb(a) {
            if (5 === a.tag || 6 === a.tag) return a.stateNode;
            E("33");
        }
        function rb(a) {
            return a[ob] || null;
        }
        var sb = Object.freeze({
            precacheFiberNode: function(a, b) {
                b[Q] = a;
            },
            getClosestInstanceFromNode: pb,
            getInstanceFromNode: function(a) {
                a = a[Q];
                return !a || 5 !== a.tag && 6 !== a.tag ? null : a;
            },
            getNodeFromInstance: qb,
            getFiberCurrentPropsFromNode: rb,
            updateFiberProps: function(a, b) {
                a[ob] = b;
            }
        });
        function tb(a) {
            do {
                a = a["return"];
            } while (a && 5 !== a.tag);
            return a ? a : null;
        }
        function ub(a, b, c) {
            for (var d = []; a; ) d.push(a), a = tb(a);
            for (a = d.length; 0 < a--; ) b(d[a], "captured", c);
            for (a = 0; a < d.length; a++) b(d[a], "bubbled", c);
        }
        function vb(a, b, c) {
            if (b = ib(a, c.dispatchConfig.phasedRegistrationNames[b])) c._dispatchListeners = $a(c._dispatchListeners, b), 
            c._dispatchInstances = $a(c._dispatchInstances, a);
        }
        function wb(a) {
            a && a.dispatchConfig.phasedRegistrationNames && ub(a._targetInst, vb, a);
        }
        function xb(a) {
            if (a && a.dispatchConfig.phasedRegistrationNames) {
                var b = a._targetInst;
                b = b ? tb(b) : null;
                ub(b, vb, a);
            }
        }
        function yb(a, b, c) {
            a && c && c.dispatchConfig.registrationName && (b = ib(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = $a(c._dispatchListeners, b), 
            c._dispatchInstances = $a(c._dispatchInstances, a));
        }
        function zb(a) {
            a && a.dispatchConfig.registrationName && yb(a._targetInst, null, a);
        }
        function Ab(a) {
            ab(a, wb);
        }
        function Bb(a, b, c, d) {
            if (c && d) a: {
                var e = c;
                for (var f = d, g = 0, h = e; h; h = tb(h)) g++;
                h = 0;
                for (var k = f; k; k = tb(k)) h++;
                for (;0 < g - h; ) e = tb(e), g--;
                for (;0 < h - g; ) f = tb(f), h--;
                for (;g--; ) {
                    if (e === f || e === f.alternate) break a;
                    e = tb(e);
                    f = tb(f);
                }
                e = null;
            } else e = null;
            f = e;
            for (e = []; c && c !== f; ) {
                g = c.alternate;
                if (null !== g && g === f) break;
                e.push(c);
                c = tb(c);
            }
            for (c = []; d && d !== f; ) {
                g = d.alternate;
                if (null !== g && g === f) break;
                c.push(d);
                d = tb(d);
            }
            for (d = 0; d < e.length; d++) yb(e[d], "bubbled", a);
            for (a = c.length; 0 < a--; ) yb(c[a], "captured", b);
        }
        var Cb = Object.freeze({
            accumulateTwoPhaseDispatches: Ab,
            accumulateTwoPhaseDispatchesSkipTarget: function(a) {
                ab(a, xb);
            },
            accumulateEnterLeaveDispatches: Bb,
            accumulateDirectDispatches: function(a) {
                ab(a, zb);
            }
        }), Db = null;
        function Eb() {
            !Db && l.canUseDOM && (Db = "textContent" in document.documentElement ? "textContent" : "innerText");
            return Db;
        }
        var S = {
            _root: null,
            _startText: null,
            _fallbackText: null
        };
        function Fb() {
            if (S._fallbackText) return S._fallbackText;
            var a, b = S._startText, c = b.length, d, e = Gb(), f = e.length;
            for (a = 0; a < c && b[a] === e[a]; a++) ;
            var g = c - a;
            for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
            S._fallbackText = e.slice(a, 1 < d ? 1 - d : void 0);
            return S._fallbackText;
        }
        function Gb() {
            return "value" in S._root ? S._root.value : S._root[Eb()];
        }
        var Hb = "dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "), Ib = {
            type: null,
            target: null,
            currentTarget: C.thatReturnsNull,
            eventPhase: null,
            bubbles: null,
            cancelable: null,
            timeStamp: function(a) {
                return a.timeStamp || Date.now();
            },
            defaultPrevented: null,
            isTrusted: null
        };
        function T(a, b, c, d) {
            this.dispatchConfig = a;
            this._targetInst = b;
            this.nativeEvent = c;
            a = this.constructor.Interface;
            for (var e in a) a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]);
            this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : !1 === c.returnValue) ? C.thatReturnsTrue : C.thatReturnsFalse;
            this.isPropagationStopped = C.thatReturnsFalse;
            return this;
        }
        B(T.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var a = this.nativeEvent;
                a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), 
                this.isDefaultPrevented = C.thatReturnsTrue);
            },
            stopPropagation: function() {
                var a = this.nativeEvent;
                a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), 
                this.isPropagationStopped = C.thatReturnsTrue);
            },
            persist: function() {
                this.isPersistent = C.thatReturnsTrue;
            },
            isPersistent: C.thatReturnsFalse,
            destructor: function() {
                var a = this.constructor.Interface, b;
                for (b in a) this[b] = null;
                for (a = 0; a < Hb.length; a++) this[Hb[a]] = null;
            }
        });
        T.Interface = Ib;
        T.augmentClass = function(a, b) {
            function c() {}
            c.prototype = this.prototype;
            var d = new c();
            B(d, a.prototype);
            a.prototype = d;
            a.prototype.constructor = a;
            a.Interface = B({}, this.Interface, b);
            a.augmentClass = this.augmentClass;
            Jb(a);
        };
        Jb(T);
        function Kb(a, b, c, d) {
            if (this.eventPool.length) {
                var e = this.eventPool.pop();
                this.call(e, a, b, c, d);
                return e;
            }
            return new this(a, b, c, d);
        }
        function Lb(a) {
            a instanceof this ? void 0 : E("223");
            a.destructor();
            10 > this.eventPool.length && this.eventPool.push(a);
        }
        function Jb(a) {
            a.eventPool = [];
            a.getPooled = Kb;
            a.release = Lb;
        }
        function Mb(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        T.augmentClass(Mb, {
            data: null
        });
        function Nb(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        T.augmentClass(Nb, {
            data: null
        });
        var Pb = [ 9, 13, 27, 32 ], Vb = l.canUseDOM && "CompositionEvent" in window, Wb = null;
        l.canUseDOM && "documentMode" in document && (Wb = document.documentMode);
        var Xb;
        if (Xb = l.canUseDOM && "TextEvent" in window && !Wb) {
            var Yb = window.opera;
            Xb = !("object" === typeof Yb && "function" === typeof Yb.version && 12 >= parseInt(Yb.version(), 10));
        }
        var Zb = Xb, $b = l.canUseDOM && (!Vb || Wb && 8 < Wb && 11 >= Wb), ac = String.fromCharCode(32), bc = {
            beforeInput: {
                phasedRegistrationNames: {
                    bubbled: "onBeforeInput",
                    captured: "onBeforeInputCapture"
                },
                dependencies: [ "topCompositionEnd", "topKeyPress", "topTextInput", "topPaste" ]
            },
            compositionEnd: {
                phasedRegistrationNames: {
                    bubbled: "onCompositionEnd",
                    captured: "onCompositionEndCapture"
                },
                dependencies: "topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")
            },
            compositionStart: {
                phasedRegistrationNames: {
                    bubbled: "onCompositionStart",
                    captured: "onCompositionStartCapture"
                },
                dependencies: "topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")
            },
            compositionUpdate: {
                phasedRegistrationNames: {
                    bubbled: "onCompositionUpdate",
                    captured: "onCompositionUpdateCapture"
                },
                dependencies: "topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")
            }
        }, cc = !1;
        function dc(a, b) {
            switch (a) {
              case "topKeyUp":
                return -1 !== Pb.indexOf(b.keyCode);

              case "topKeyDown":
                return 229 !== b.keyCode;

              case "topKeyPress":
              case "topMouseDown":
              case "topBlur":
                return !0;

              default:
                return !1;
            }
        }
        function ec(a) {
            a = a.detail;
            return "object" === typeof a && "data" in a ? a.data : null;
        }
        var fc = !1;
        function gc(a, b) {
            switch (a) {
              case "topCompositionEnd":
                return ec(b);

              case "topKeyPress":
                if (32 !== b.which) return null;
                cc = !0;
                return ac;

              case "topTextInput":
                return a = b.data, a === ac && cc ? null : a;

              default:
                return null;
            }
        }
        function hc(a, b) {
            if (fc) return "topCompositionEnd" === a || !Vb && dc(a, b) ? (a = Fb(), S._root = null, 
            S._startText = null, S._fallbackText = null, fc = !1, a) : null;
            switch (a) {
              case "topPaste":
                return null;

              case "topKeyPress":
                if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
                    if (b.char && 1 < b.char.length) return b.char;
                    if (b.which) return String.fromCharCode(b.which);
                }
                return null;

              case "topCompositionEnd":
                return $b ? null : b.data;

              default:
                return null;
            }
        }
        var ic = {
            eventTypes: bc,
            extractEvents: function(a, b, c, d) {
                var e;
                if (Vb) b: {
                    switch (a) {
                      case "topCompositionStart":
                        var f = bc.compositionStart;
                        break b;

                      case "topCompositionEnd":
                        f = bc.compositionEnd;
                        break b;

                      case "topCompositionUpdate":
                        f = bc.compositionUpdate;
                        break b;
                    }
                    f = void 0;
                } else fc ? dc(a, c) && (f = bc.compositionEnd) : "topKeyDown" === a && 229 === c.keyCode && (f = bc.compositionStart);
                f ? ($b && (fc || f !== bc.compositionStart ? f === bc.compositionEnd && fc && (e = Fb()) : (S._root = d, 
                S._startText = Gb(), fc = !0)), f = Mb.getPooled(f, b, c, d), e ? f.data = e : (e = ec(c), 
                null !== e && (f.data = e)), Ab(f), e = f) : e = null;
                (a = Zb ? gc(a, c) : hc(a, c)) ? (b = Nb.getPooled(bc.beforeInput, b, c, d), b.data = a, 
                Ab(b)) : b = null;
                return [ e, b ];
            }
        }, jc = null, kc = null, lc = null;
        function mc(a) {
            if (a = Xa(a)) {
                jc && "function" === typeof jc.restoreControlledState ? void 0 : E("194");
                var b = Wa(a.stateNode);
                jc.restoreControlledState(a.stateNode, a.type, b);
            }
        }
        var nc = {
            injectFiberControlledHostComponent: function(a) {
                jc = a;
            }
        };
        function oc(a) {
            kc ? lc ? lc.push(a) : lc = [ a ] : kc = a;
        }
        function pc() {
            if (kc) {
                var a = kc, b = lc;
                lc = kc = null;
                mc(a);
                if (b) for (a = 0; a < b.length; a++) mc(b[a]);
            }
        }
        var qc = Object.freeze({
            injection: nc,
            enqueueStateRestore: oc,
            restoreStateIfNeeded: pc
        });
        function rc(a, b) {
            return a(b);
        }
        var sc = !1;
        function tc(a, b) {
            if (sc) return rc(a, b);
            sc = !0;
            try {
                return rc(a, b);
            } finally {
                sc = !1, pc();
            }
        }
        var uc = {
            color: !0,
            date: !0,
            datetime: !0,
            "datetime-local": !0,
            email: !0,
            month: !0,
            number: !0,
            password: !0,
            range: !0,
            search: !0,
            tel: !0,
            text: !0,
            time: !0,
            url: !0,
            week: !0
        };
        function vc(a) {
            var b = a && a.nodeName && a.nodeName.toLowerCase();
            return "input" === b ? !!uc[a.type] : "textarea" === b ? !0 : !1;
        }
        function wc(a) {
            a = a.target || a.srcElement || window;
            a.correspondingUseElement && (a = a.correspondingUseElement);
            return 3 === a.nodeType ? a.parentNode : a;
        }
        var xc;
        l.canUseDOM && (xc = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", ""));
        function yc(a, b) {
            if (!l.canUseDOM || b && !("addEventListener" in document)) return !1;
            b = "on" + a;
            var c = b in document;
            c || (c = document.createElement("div"), c.setAttribute(b, "return;"), c = "function" === typeof c[b]);
            !c && xc && "wheel" === a && (c = document.implementation.hasFeature("Events.wheel", "3.0"));
            return c;
        }
        function zc(a) {
            var b = a.type;
            return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
        }
        function Ac(a) {
            var b = zc(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
            if (!a.hasOwnProperty(b) && "function" === typeof c.get && "function" === typeof c.set) return Object.defineProperty(a, b, {
                enumerable: c.enumerable,
                configurable: !0,
                get: function() {
                    return c.get.call(this);
                },
                set: function(a) {
                    d = "" + a;
                    c.set.call(this, a);
                }
            }), {
                getValue: function() {
                    return d;
                },
                setValue: function(a) {
                    d = "" + a;
                },
                stopTracking: function() {
                    a._valueTracker = null;
                    delete a[b];
                }
            };
        }
        function Bc(a) {
            a._valueTracker || (a._valueTracker = Ac(a));
        }
        function Cc(a) {
            if (!a) return !1;
            var b = a._valueTracker;
            if (!b) return !0;
            var c = b.getValue();
            var d = "";
            a && (d = zc(a) ? a.checked ? "true" : "false" : a.value);
            a = d;
            return a !== c ? (b.setValue(a), !0) : !1;
        }
        var Dc = {
            change: {
                phasedRegistrationNames: {
                    bubbled: "onChange",
                    captured: "onChangeCapture"
                },
                dependencies: "topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ")
            }
        };
        function Ec(a, b, c) {
            a = T.getPooled(Dc.change, a, b, c);
            a.type = "change";
            oc(c);
            Ab(a);
            return a;
        }
        var Fc = null, Gc = null;
        function Hc(a) {
            kb(a);
            lb(!1);
        }
        function Ic(a) {
            var b = qb(a);
            if (Cc(b)) return a;
        }
        function Jc(a, b) {
            if ("topChange" === a) return b;
        }
        var Kc = !1;
        l.canUseDOM && (Kc = yc("input") && (!document.documentMode || 9 < document.documentMode));
        function Lc() {
            Fc && (Fc.detachEvent("onpropertychange", Mc), Gc = Fc = null);
        }
        function Mc(a) {
            "value" === a.propertyName && Ic(Gc) && (a = Ec(Gc, a, wc(a)), tc(Hc, a));
        }
        function Nc(a, b, c) {
            "topFocus" === a ? (Lc(), Fc = b, Gc = c, Fc.attachEvent("onpropertychange", Mc)) : "topBlur" === a && Lc();
        }
        function Oc(a) {
            if ("topSelectionChange" === a || "topKeyUp" === a || "topKeyDown" === a) return Ic(Gc);
        }
        function Pc(a, b) {
            if ("topClick" === a) return Ic(b);
        }
        function $c(a, b) {
            if ("topInput" === a || "topChange" === a) return Ic(b);
        }
        var ad = {
            eventTypes: Dc,
            _isInputEventSupported: Kc,
            extractEvents: function(a, b, c, d) {
                var e = b ? qb(b) : window, f = e.nodeName && e.nodeName.toLowerCase();
                if ("select" === f || "input" === f && "file" === e.type) var g = Jc; else if (vc(e)) if (Kc) g = $c; else {
                    g = Oc;
                    var h = Nc;
                } else f = e.nodeName, !f || "input" !== f.toLowerCase() || "checkbox" !== e.type && "radio" !== e.type || (g = Pc);
                if (g && (g = g(a, b))) return Ec(g, c, d);
                h && h(a, e, b);
                "topBlur" === a && null != b && (a = b._wrapperState || e._wrapperState) && a.controlled && "number" === e.type && (a = "" + e.value, 
                e.getAttribute("value") !== a && e.setAttribute("value", a));
            }
        };
        function bd(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        T.augmentClass(bd, {
            view: null,
            detail: null
        });
        var cd = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
        };
        function dd(a) {
            var b = this.nativeEvent;
            return b.getModifierState ? b.getModifierState(a) : (a = cd[a]) ? !!b[a] : !1;
        }
        function ed() {
            return dd;
        }
        function fd(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        bd.augmentClass(fd, {
            screenX: null,
            screenY: null,
            clientX: null,
            clientY: null,
            pageX: null,
            pageY: null,
            ctrlKey: null,
            shiftKey: null,
            altKey: null,
            metaKey: null,
            getModifierState: ed,
            button: null,
            buttons: null,
            relatedTarget: function(a) {
                return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
            }
        });
        var gd = {
            mouseEnter: {
                registrationName: "onMouseEnter",
                dependencies: [ "topMouseOut", "topMouseOver" ]
            },
            mouseLeave: {
                registrationName: "onMouseLeave",
                dependencies: [ "topMouseOut", "topMouseOver" ]
            }
        }, hd = {
            eventTypes: gd,
            extractEvents: function(a, b, c, d) {
                if ("topMouseOver" === a && (c.relatedTarget || c.fromElement) || "topMouseOut" !== a && "topMouseOver" !== a) return null;
                var e = d.window === d ? d : (e = d.ownerDocument) ? e.defaultView || e.parentWindow : window;
                "topMouseOut" === a ? (a = b, b = (b = c.relatedTarget || c.toElement) ? pb(b) : null) : a = null;
                if (a === b) return null;
                var f = null == a ? e : qb(a);
                e = null == b ? e : qb(b);
                var g = fd.getPooled(gd.mouseLeave, a, c, d);
                g.type = "mouseleave";
                g.target = f;
                g.relatedTarget = e;
                c = fd.getPooled(gd.mouseEnter, b, c, d);
                c.type = "mouseenter";
                c.target = e;
                c.relatedTarget = f;
                Bb(g, c, a, b);
                return [ g, c ];
            }
        }, id = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
        function jd(a) {
            a = a.type;
            return "string" === typeof a ? a : "function" === typeof a ? a.displayName || a.name : null;
        }
        function kd(a) {
            var b = a;
            if (a.alternate) for (;b["return"]; ) b = b["return"]; else {
                if (0 !== (b.effectTag & 2)) return 1;
                for (;b["return"]; ) if (b = b["return"], 0 !== (b.effectTag & 2)) return 1;
            }
            return 3 === b.tag ? 2 : 3;
        }
        function ld(a) {
            return (a = a._reactInternalFiber) ? 2 === kd(a) : !1;
        }
        function md(a) {
            2 !== kd(a) ? E("188") : void 0;
        }
        function nd(a) {
            var b = a.alternate;
            if (!b) return b = kd(a), 3 === b ? E("188") : void 0, 1 === b ? null : a;
            for (var c = a, d = b; ;) {
                var e = c["return"], f = e ? e.alternate : null;
                if (!e || !f) break;
                if (e.child === f.child) {
                    for (var g = e.child; g; ) {
                        if (g === c) return md(e), a;
                        if (g === d) return md(e), b;
                        g = g.sibling;
                    }
                    E("188");
                }
                if (c["return"] !== d["return"]) c = e, d = f; else {
                    g = !1;
                    for (var h = e.child; h; ) {
                        if (h === c) {
                            g = !0;
                            c = e;
                            d = f;
                            break;
                        }
                        if (h === d) {
                            g = !0;
                            d = e;
                            c = f;
                            break;
                        }
                        h = h.sibling;
                    }
                    if (!g) {
                        for (h = f.child; h; ) {
                            if (h === c) {
                                g = !0;
                                c = f;
                                d = e;
                                break;
                            }
                            if (h === d) {
                                g = !0;
                                d = f;
                                c = e;
                                break;
                            }
                            h = h.sibling;
                        }
                        g ? void 0 : E("189");
                    }
                }
                c.alternate !== d ? E("190") : void 0;
            }
            3 !== c.tag ? E("188") : void 0;
            return c.stateNode.current === c ? a : b;
        }
        function od(a) {
            a = nd(a);
            if (!a) return null;
            for (var b = a; ;) {
                if (5 === b.tag || 6 === b.tag) return b;
                if (b.child) b.child["return"] = b, b = b.child; else {
                    if (b === a) break;
                    for (;!b.sibling; ) {
                        if (!b["return"] || b["return"] === a) return null;
                        b = b["return"];
                    }
                    b.sibling["return"] = b["return"];
                    b = b.sibling;
                }
            }
            return null;
        }
        function pd(a) {
            a = nd(a);
            if (!a) return null;
            for (var b = a; ;) {
                if (5 === b.tag || 6 === b.tag) return b;
                if (b.child && 4 !== b.tag) b.child["return"] = b, b = b.child; else {
                    if (b === a) break;
                    for (;!b.sibling; ) {
                        if (!b["return"] || b["return"] === a) return null;
                        b = b["return"];
                    }
                    b.sibling["return"] = b["return"];
                    b = b.sibling;
                }
            }
            return null;
        }
        var qd = [];
        function rd(a) {
            var b = a.targetInst;
            do {
                if (!b) {
                    a.ancestors.push(b);
                    break;
                }
                var c;
                for (c = b; c["return"]; ) c = c["return"];
                c = 3 !== c.tag ? null : c.stateNode.containerInfo;
                if (!c) break;
                a.ancestors.push(b);
                b = pb(c);
            } while (b);
            for (c = 0; c < a.ancestors.length; c++) b = a.ancestors[c], sd(a.topLevelType, b, a.nativeEvent, wc(a.nativeEvent));
        }
        var td = !0, sd = void 0;
        function ud(a) {
            td = !!a;
        }
        function U(a, b, c) {
            return c ? ba.listen(c, b, vd.bind(null, a)) : null;
        }
        function wd(a, b, c) {
            return c ? ba.capture(c, b, vd.bind(null, a)) : null;
        }
        function vd(a, b) {
            if (td) {
                var c = wc(b);
                c = pb(c);
                null === c || "number" !== typeof c.tag || 2 === kd(c) || (c = null);
                if (qd.length) {
                    var d = qd.pop();
                    d.topLevelType = a;
                    d.nativeEvent = b;
                    d.targetInst = c;
                    a = d;
                } else a = {
                    topLevelType: a,
                    nativeEvent: b,
                    targetInst: c,
                    ancestors: []
                };
                try {
                    tc(rd, a);
                } finally {
                    a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 
                    10 > qd.length && qd.push(a);
                }
            }
        }
        var xd = Object.freeze({
            get _enabled() {
                return td;
            },
            get _handleTopLevel() {
                return sd;
            },
            setHandleTopLevel: function(a) {
                sd = a;
            },
            setEnabled: ud,
            isEnabled: function() {
                return td;
            },
            trapBubbledEvent: U,
            trapCapturedEvent: wd,
            dispatchEvent: vd
        });
        function yd(a, b) {
            var c = {};
            c[a.toLowerCase()] = b.toLowerCase();
            c["Webkit" + a] = "webkit" + b;
            c["Moz" + a] = "moz" + b;
            c["ms" + a] = "MS" + b;
            c["O" + a] = "o" + b.toLowerCase();
            return c;
        }
        var zd = {
            animationend: yd("Animation", "AnimationEnd"),
            animationiteration: yd("Animation", "AnimationIteration"),
            animationstart: yd("Animation", "AnimationStart"),
            transitionend: yd("Transition", "TransitionEnd")
        }, Ad = {}, Bd = {};
        l.canUseDOM && (Bd = document.createElement("div").style, "AnimationEvent" in window || (delete zd.animationend.animation, 
        delete zd.animationiteration.animation, delete zd.animationstart.animation), "TransitionEvent" in window || delete zd.transitionend.transition);
        function Cd(a) {
            if (Ad[a]) return Ad[a];
            if (!zd[a]) return a;
            var b = zd[a], c;
            for (c in b) if (b.hasOwnProperty(c) && c in Bd) return Ad[a] = b[c];
            return "";
        }
        var Dd = {
            topAbort: "abort",
            topAnimationEnd: Cd("animationend") || "animationend",
            topAnimationIteration: Cd("animationiteration") || "animationiteration",
            topAnimationStart: Cd("animationstart") || "animationstart",
            topBlur: "blur",
            topCancel: "cancel",
            topCanPlay: "canplay",
            topCanPlayThrough: "canplaythrough",
            topChange: "change",
            topClick: "click",
            topClose: "close",
            topCompositionEnd: "compositionend",
            topCompositionStart: "compositionstart",
            topCompositionUpdate: "compositionupdate",
            topContextMenu: "contextmenu",
            topCopy: "copy",
            topCut: "cut",
            topDoubleClick: "dblclick",
            topDrag: "drag",
            topDragEnd: "dragend",
            topDragEnter: "dragenter",
            topDragExit: "dragexit",
            topDragLeave: "dragleave",
            topDragOver: "dragover",
            topDragStart: "dragstart",
            topDrop: "drop",
            topDurationChange: "durationchange",
            topEmptied: "emptied",
            topEncrypted: "encrypted",
            topEnded: "ended",
            topError: "error",
            topFocus: "focus",
            topInput: "input",
            topKeyDown: "keydown",
            topKeyPress: "keypress",
            topKeyUp: "keyup",
            topLoadedData: "loadeddata",
            topLoad: "load",
            topLoadedMetadata: "loadedmetadata",
            topLoadStart: "loadstart",
            topMouseDown: "mousedown",
            topMouseMove: "mousemove",
            topMouseOut: "mouseout",
            topMouseOver: "mouseover",
            topMouseUp: "mouseup",
            topPaste: "paste",
            topPause: "pause",
            topPlay: "play",
            topPlaying: "playing",
            topProgress: "progress",
            topRateChange: "ratechange",
            topScroll: "scroll",
            topSeeked: "seeked",
            topSeeking: "seeking",
            topSelectionChange: "selectionchange",
            topStalled: "stalled",
            topSuspend: "suspend",
            topTextInput: "textInput",
            topTimeUpdate: "timeupdate",
            topToggle: "toggle",
            topTouchCancel: "touchcancel",
            topTouchEnd: "touchend",
            topTouchMove: "touchmove",
            topTouchStart: "touchstart",
            topTransitionEnd: Cd("transitionend") || "transitionend",
            topVolumeChange: "volumechange",
            topWaiting: "waiting",
            topWheel: "wheel"
        }, Ed = {}, Fd = 0, Gd = "_reactListenersID" + ("" + Math.random()).slice(2);
        function Hd(a) {
            Object.prototype.hasOwnProperty.call(a, Gd) || (a[Gd] = Fd++, Ed[a[Gd]] = {});
            return Ed[a[Gd]];
        }
        function Id(a) {
            for (;a && a.firstChild; ) a = a.firstChild;
            return a;
        }
        function Jd(a, b) {
            var c = Id(a);
            a = 0;
            for (var d; c; ) {
                if (3 === c.nodeType) {
                    d = a + c.textContent.length;
                    if (a <= b && d >= b) return {
                        node: c,
                        offset: b - a
                    };
                    a = d;
                }
                a: {
                    for (;c; ) {
                        if (c.nextSibling) {
                            c = c.nextSibling;
                            break a;
                        }
                        c = c.parentNode;
                    }
                    c = void 0;
                }
                c = Id(c);
            }
        }
        function Kd(a) {
            var b = a && a.nodeName && a.nodeName.toLowerCase();
            return b && ("input" === b && "text" === a.type || "textarea" === b || "true" === a.contentEditable);
        }
        var Ld = l.canUseDOM && "documentMode" in document && 11 >= document.documentMode, Md = {
            select: {
                phasedRegistrationNames: {
                    bubbled: "onSelect",
                    captured: "onSelectCapture"
                },
                dependencies: "topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ")
            }
        }, Nd = null, Od = null, Pd = null, Qd = !1;
        function Rd(a, b) {
            if (Qd || null == Nd || Nd !== da()) return null;
            var c = Nd;
            "selectionStart" in c && Kd(c) ? c = {
                start: c.selectionStart,
                end: c.selectionEnd
            } : window.getSelection ? (c = window.getSelection(), c = {
                anchorNode: c.anchorNode,
                anchorOffset: c.anchorOffset,
                focusNode: c.focusNode,
                focusOffset: c.focusOffset
            }) : c = void 0;
            return Pd && ea(Pd, c) ? null : (Pd = c, a = T.getPooled(Md.select, Od, a, b), a.type = "select", 
            a.target = Nd, Ab(a), a);
        }
        var Sd = {
            eventTypes: Md,
            extractEvents: function(a, b, c, d) {
                var e = d.window === d ? d.document : 9 === d.nodeType ? d : d.ownerDocument, f;
                if (!(f = !e)) {
                    a: {
                        e = Hd(e);
                        f = Sa.onSelect;
                        for (var g = 0; g < f.length; g++) {
                            var h = f[g];
                            if (!e.hasOwnProperty(h) || !e[h]) {
                                e = !1;
                                break a;
                            }
                        }
                        e = !0;
                    }
                    f = !e;
                }
                if (f) return null;
                e = b ? qb(b) : window;
                switch (a) {
                  case "topFocus":
                    if (vc(e) || "true" === e.contentEditable) Nd = e, Od = b, Pd = null;
                    break;

                  case "topBlur":
                    Pd = Od = Nd = null;
                    break;

                  case "topMouseDown":
                    Qd = !0;
                    break;

                  case "topContextMenu":
                  case "topMouseUp":
                    return Qd = !1, Rd(c, d);

                  case "topSelectionChange":
                    if (Ld) break;

                  case "topKeyDown":
                  case "topKeyUp":
                    return Rd(c, d);
                }
                return null;
            }
        };
        function Td(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        T.augmentClass(Td, {
            animationName: null,
            elapsedTime: null,
            pseudoElement: null
        });
        function Ud(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        T.augmentClass(Ud, {
            clipboardData: function(a) {
                return "clipboardData" in a ? a.clipboardData : window.clipboardData;
            }
        });
        function Vd(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        bd.augmentClass(Vd, {
            relatedTarget: null
        });
        function Wd(a) {
            var b = a.keyCode;
            "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
            return 32 <= a || 13 === a ? a : 0;
        }
        var Xd = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
        }, Yd = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
        };
        function Zd(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        bd.augmentClass(Zd, {
            key: function(a) {
                if (a.key) {
                    var b = Xd[a.key] || a.key;
                    if ("Unidentified" !== b) return b;
                }
                return "keypress" === a.type ? (a = Wd(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Yd[a.keyCode] || "Unidentified" : "";
            },
            location: null,
            ctrlKey: null,
            shiftKey: null,
            altKey: null,
            metaKey: null,
            repeat: null,
            locale: null,
            getModifierState: ed,
            charCode: function(a) {
                return "keypress" === a.type ? Wd(a) : 0;
            },
            keyCode: function(a) {
                return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
            },
            which: function(a) {
                return "keypress" === a.type ? Wd(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
            }
        });
        function $d(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        fd.augmentClass($d, {
            dataTransfer: null
        });
        function ae(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        bd.augmentClass(ae, {
            touches: null,
            targetTouches: null,
            changedTouches: null,
            altKey: null,
            metaKey: null,
            ctrlKey: null,
            shiftKey: null,
            getModifierState: ed
        });
        function be(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        T.augmentClass(be, {
            propertyName: null,
            elapsedTime: null,
            pseudoElement: null
        });
        function ce(a, b, c, d) {
            return T.call(this, a, b, c, d);
        }
        fd.augmentClass(ce, {
            deltaX: function(a) {
                return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
            },
            deltaY: function(a) {
                return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
            },
            deltaZ: null,
            deltaMode: null
        });
        var de = {}, ee = {};
        "abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function(a) {
            var b = a[0].toUpperCase() + a.slice(1), c = "on" + b;
            b = "top" + b;
            c = {
                phasedRegistrationNames: {
                    bubbled: c,
                    captured: c + "Capture"
                },
                dependencies: [ b ]
            };
            de[a] = c;
            ee[b] = c;
        });
        var fe = {
            eventTypes: de,
            extractEvents: function(a, b, c, d) {
                var e = ee[a];
                if (!e) return null;
                switch (a) {
                  case "topKeyPress":
                    if (0 === Wd(c)) return null;

                  case "topKeyDown":
                  case "topKeyUp":
                    a = Zd;
                    break;

                  case "topBlur":
                  case "topFocus":
                    a = Vd;
                    break;

                  case "topClick":
                    if (2 === c.button) return null;

                  case "topDoubleClick":
                  case "topMouseDown":
                  case "topMouseMove":
                  case "topMouseUp":
                  case "topMouseOut":
                  case "topMouseOver":
                  case "topContextMenu":
                    a = fd;
                    break;

                  case "topDrag":
                  case "topDragEnd":
                  case "topDragEnter":
                  case "topDragExit":
                  case "topDragLeave":
                  case "topDragOver":
                  case "topDragStart":
                  case "topDrop":
                    a = $d;
                    break;

                  case "topTouchCancel":
                  case "topTouchEnd":
                  case "topTouchMove":
                  case "topTouchStart":
                    a = ae;
                    break;

                  case "topAnimationEnd":
                  case "topAnimationIteration":
                  case "topAnimationStart":
                    a = Td;
                    break;

                  case "topTransitionEnd":
                    a = be;
                    break;

                  case "topScroll":
                    a = bd;
                    break;

                  case "topWheel":
                    a = ce;
                    break;

                  case "topCopy":
                  case "topCut":
                  case "topPaste":
                    a = Ud;
                    break;

                  default:
                    a = T;
                }
                b = a.getPooled(e, b, c, d);
                Ab(b);
                return b;
            }
        };
        sd = function(a, b, c, d) {
            a = jb(a, b, c, d);
            kb(a);
            lb(!1);
        };
        hb.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
        Wa = sb.getFiberCurrentPropsFromNode;
        Xa = sb.getInstanceFromNode;
        Ya = sb.getNodeFromInstance;
        hb.injectEventPluginsByName({
            SimpleEventPlugin: fe,
            EnterLeaveEventPlugin: hd,
            ChangeEventPlugin: ad,
            SelectEventPlugin: Sd,
            BeforeInputEventPlugin: ic
        });
        var ge = [], he = -1;
        function V(a) {
            0 > he || (a.current = ge[he], ge[he] = null, he--);
        }
        function W(a, b) {
            he++;
            ge[he] = a.current;
            a.current = b;
        }
        new Set();
        var ie = {
            current: D
        }, X = {
            current: !1
        }, je = D;
        function ke(a) {
            return le(a) ? je : ie.current;
        }
        function me(a, b) {
            var c = a.type.contextTypes;
            if (!c) return D;
            var d = a.stateNode;
            if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
            var e = {}, f;
            for (f in c) e[f] = b[f];
            d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
            return e;
        }
        function le(a) {
            return 2 === a.tag && null != a.type.childContextTypes;
        }
        function ne(a) {
            le(a) && (V(X, a), V(ie, a));
        }
        function oe(a, b, c) {
            null != ie.cursor ? E("168") : void 0;
            W(ie, b, a);
            W(X, c, a);
        }
        function pe(a, b) {
            var c = a.stateNode, d = a.type.childContextTypes;
            if ("function" !== typeof c.getChildContext) return b;
            c = c.getChildContext();
            for (var e in c) e in d ? void 0 : E("108", jd(a) || "Unknown", e);
            return B({}, b, c);
        }
        function qe(a) {
            if (!le(a)) return !1;
            var b = a.stateNode;
            b = b && b.__reactInternalMemoizedMergedChildContext || D;
            je = ie.current;
            W(ie, b, a);
            W(X, X.current, a);
            return !0;
        }
        function re(a, b) {
            var c = a.stateNode;
            c ? void 0 : E("169");
            if (b) {
                var d = pe(a, je);
                c.__reactInternalMemoizedMergedChildContext = d;
                V(X, a);
                V(ie, a);
                W(ie, d, a);
            } else V(X, a);
            W(X, b, a);
        }
        function Y(a, b, c) {
            this.tag = a;
            this.key = b;
            this.stateNode = this.type = null;
            this.sibling = this.child = this["return"] = null;
            this.index = 0;
            this.memoizedState = this.updateQueue = this.memoizedProps = this.pendingProps = this.ref = null;
            this.internalContextTag = c;
            this.effectTag = 0;
            this.lastEffect = this.firstEffect = this.nextEffect = null;
            this.expirationTime = 0;
            this.alternate = null;
        }
        function se(a, b, c) {
            var d = a.alternate;
            null === d ? (d = new Y(a.tag, a.key, a.internalContextTag), d.type = a.type, d.stateNode = a.stateNode, 
            d.alternate = a, a.alternate = d) : (d.effectTag = 0, d.nextEffect = null, d.firstEffect = null, 
            d.lastEffect = null);
            d.expirationTime = c;
            d.pendingProps = b;
            d.child = a.child;
            d.memoizedProps = a.memoizedProps;
            d.memoizedState = a.memoizedState;
            d.updateQueue = a.updateQueue;
            d.sibling = a.sibling;
            d.index = a.index;
            d.ref = a.ref;
            return d;
        }
        function te(a, b, c) {
            var d = void 0, e = a.type, f = a.key;
            "function" === typeof e ? (d = e.prototype && e.prototype.isReactComponent ? new Y(2, f, b) : new Y(0, f, b), 
            d.type = e, d.pendingProps = a.props) : "string" === typeof e ? (d = new Y(5, f, b), 
            d.type = e, d.pendingProps = a.props) : "object" === typeof e && null !== e && "number" === typeof e.tag ? (d = e, 
            d.pendingProps = a.props) : E("130", null == e ? e : typeof e, "");
            d.expirationTime = c;
            return d;
        }
        function ue(a, b, c, d) {
            b = new Y(10, d, b);
            b.pendingProps = a;
            b.expirationTime = c;
            return b;
        }
        function ve(a, b, c) {
            b = new Y(6, null, b);
            b.pendingProps = a;
            b.expirationTime = c;
            return b;
        }
        function we(a, b, c) {
            b = new Y(7, a.key, b);
            b.type = a.handler;
            b.pendingProps = a;
            b.expirationTime = c;
            return b;
        }
        function xe(a, b, c) {
            a = new Y(9, null, b);
            a.expirationTime = c;
            return a;
        }
        function ye(a, b, c) {
            b = new Y(4, a.key, b);
            b.pendingProps = a.children || [];
            b.expirationTime = c;
            b.stateNode = {
                containerInfo: a.containerInfo,
                pendingChildren: null,
                implementation: a.implementation
            };
            return b;
        }
        var ze = null, Ae = null;
        function Be(a) {
            return function(b) {
                try {
                    return a(b);
                } catch (c) {}
            };
        }
        function Ce(a) {
            if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
            var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (b.isDisabled || !b.supportsFiber) return !0;
            try {
                var c = b.inject(a);
                ze = Be(function(a) {
                    return b.onCommitFiberRoot(c, a);
                });
                Ae = Be(function(a) {
                    return b.onCommitFiberUnmount(c, a);
                });
            } catch (d) {}
            return !0;
        }
        function De(a) {
            "function" === typeof ze && ze(a);
        }
        function Ee(a) {
            "function" === typeof Ae && Ae(a);
        }
        function Fe(a) {
            return {
                baseState: a,
                expirationTime: 0,
                first: null,
                last: null,
                callbackList: null,
                hasForceUpdate: !1,
                isInitialized: !1
            };
        }
        function Ge(a, b) {
            null === a.last ? a.first = a.last = b : (a.last.next = b, a.last = b);
            if (0 === a.expirationTime || a.expirationTime > b.expirationTime) a.expirationTime = b.expirationTime;
        }
        function He(a, b) {
            var c = a.alternate, d = a.updateQueue;
            null === d && (d = a.updateQueue = Fe(null));
            null !== c ? (a = c.updateQueue, null === a && (a = c.updateQueue = Fe(null))) : a = null;
            a = a !== d ? a : null;
            null === a ? Ge(d, b) : null === d.last || null === a.last ? (Ge(d, b), Ge(a, b)) : (Ge(d, b), 
            a.last = b);
        }
        function Ie(a, b, c, d) {
            a = a.partialState;
            return "function" === typeof a ? a.call(b, c, d) : a;
        }
        function Je(a, b, c, d, e, f) {
            null !== a && a.updateQueue === c && (c = b.updateQueue = {
                baseState: c.baseState,
                expirationTime: c.expirationTime,
                first: c.first,
                last: c.last,
                isInitialized: c.isInitialized,
                callbackList: null,
                hasForceUpdate: !1
            });
            c.expirationTime = 0;
            c.isInitialized ? a = c.baseState : (a = c.baseState = b.memoizedState, c.isInitialized = !0);
            for (var g = !0, h = c.first, k = !1; null !== h; ) {
                var q = h.expirationTime;
                if (q > f) {
                    var v = c.expirationTime;
                    if (0 === v || v > q) c.expirationTime = q;
                    k || (k = !0, c.baseState = a);
                } else {
                    k || (c.first = h.next, null === c.first && (c.last = null));
                    if (h.isReplace) a = Ie(h, d, a, e), g = !0; else if (q = Ie(h, d, a, e)) a = g ? B({}, a, q) : B(a, q), 
                    g = !1;
                    h.isForced && (c.hasForceUpdate = !0);
                    null !== h.callback && (q = c.callbackList, null === q && (q = c.callbackList = []), 
                    q.push(h));
                }
                h = h.next;
            }
            null !== c.callbackList ? b.effectTag |= 32 : null !== c.first || c.hasForceUpdate || (b.updateQueue = null);
            k || (c.baseState = a);
            return a;
        }
        function Ke(a, b) {
            var c = a.callbackList;
            if (null !== c) for (a.callbackList = null, a = 0; a < c.length; a++) {
                var d = c[a], e = d.callback;
                d.callback = null;
                "function" !== typeof e ? E("191", e) : void 0;
                e.call(b);
            }
        }
        function Le(a, b, c, d) {
            function e(a, b) {
                b.updater = f;
                a.stateNode = b;
                b._reactInternalFiber = a;
            }
            var f = {
                isMounted: ld,
                enqueueSetState: function(c, d, e) {
                    c = c._reactInternalFiber;
                    e = void 0 === e ? null : e;
                    var g = b(c);
                    He(c, {
                        expirationTime: g,
                        partialState: d,
                        callback: e,
                        isReplace: !1,
                        isForced: !1,
                        nextCallback: null,
                        next: null
                    });
                    a(c, g);
                },
                enqueueReplaceState: function(c, d, e) {
                    c = c._reactInternalFiber;
                    e = void 0 === e ? null : e;
                    var g = b(c);
                    He(c, {
                        expirationTime: g,
                        partialState: d,
                        callback: e,
                        isReplace: !0,
                        isForced: !1,
                        nextCallback: null,
                        next: null
                    });
                    a(c, g);
                },
                enqueueForceUpdate: function(c, d) {
                    c = c._reactInternalFiber;
                    d = void 0 === d ? null : d;
                    var e = b(c);
                    He(c, {
                        expirationTime: e,
                        partialState: null,
                        callback: d,
                        isReplace: !1,
                        isForced: !0,
                        nextCallback: null,
                        next: null
                    });
                    a(c, e);
                }
            };
            return {
                adoptClassInstance: e,
                constructClassInstance: function(a, b) {
                    var c = a.type, d = ke(a), f = 2 === a.tag && null != a.type.contextTypes, g = f ? me(a, d) : D;
                    b = new c(b, g);
                    e(a, b);
                    f && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = d, a.__reactInternalMemoizedMaskedChildContext = g);
                    return b;
                },
                mountClassInstance: function(a, b) {
                    var c = a.alternate, d = a.stateNode, e = d.state || null, g = a.pendingProps;
                    g ? void 0 : E("158");
                    var h = ke(a);
                    d.props = g;
                    d.state = a.memoizedState = e;
                    d.refs = D;
                    d.context = me(a, h);
                    null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent && (a.internalContextTag |= 1);
                    "function" === typeof d.componentWillMount && (e = d.state, d.componentWillMount(), 
                    e !== d.state && f.enqueueReplaceState(d, d.state, null), e = a.updateQueue, null !== e && (d.state = Je(c, a, e, d, g, b)));
                    "function" === typeof d.componentDidMount && (a.effectTag |= 4);
                },
                updateClassInstance: function(a, b, e) {
                    var g = b.stateNode;
                    g.props = b.memoizedProps;
                    g.state = b.memoizedState;
                    var h = b.memoizedProps, k = b.pendingProps;
                    k || (k = h, null == k ? E("159") : void 0);
                    var u = g.context, z = ke(b);
                    z = me(b, z);
                    "function" !== typeof g.componentWillReceiveProps || h === k && u === z || (u = g.state, 
                    g.componentWillReceiveProps(k, z), g.state !== u && f.enqueueReplaceState(g, g.state, null));
                    u = b.memoizedState;
                    e = null !== b.updateQueue ? Je(a, b, b.updateQueue, g, k, e) : u;
                    if (!(h !== k || u !== e || X.current || null !== b.updateQueue && b.updateQueue.hasForceUpdate)) return "function" !== typeof g.componentDidUpdate || h === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), 
                    !1;
                    var G = k;
                    if (null === h || null !== b.updateQueue && b.updateQueue.hasForceUpdate) G = !0; else {
                        var I = b.stateNode, L = b.type;
                        G = "function" === typeof I.shouldComponentUpdate ? I.shouldComponentUpdate(G, e, z) : L.prototype && L.prototype.isPureReactComponent ? !ea(h, G) || !ea(u, e) : !0;
                    }
                    G ? ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(k, e, z), 
                    "function" === typeof g.componentDidUpdate && (b.effectTag |= 4)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), 
                    c(b, k), d(b, e));
                    g.props = k;
                    g.state = e;
                    g.context = z;
                    return G;
                }
            };
        }
        var Qe = "function" === typeof Symbol && Symbol["for"], Re = Qe ? Symbol["for"]("react.element") : 60103, Se = Qe ? Symbol["for"]("react.call") : 60104, Te = Qe ? Symbol["for"]("react.return") : 60105, Ue = Qe ? Symbol["for"]("react.portal") : 60106, Ve = Qe ? Symbol["for"]("react.fragment") : 60107, We = "function" === typeof Symbol && Symbol.iterator;
        function Xe(a) {
            if (null === a || "undefined" === typeof a) return null;
            a = We && a[We] || a["@@iterator"];
            return "function" === typeof a ? a : null;
        }
        var Ye = Array.isArray;
        function Ze(a, b) {
            var c = b.ref;
            if (null !== c && "function" !== typeof c) {
                if (b._owner) {
                    b = b._owner;
                    var d = void 0;
                    b && (2 !== b.tag ? E("110") : void 0, d = b.stateNode);
                    d ? void 0 : E("147", c);
                    var e = "" + c;
                    if (null !== a && null !== a.ref && a.ref._stringRef === e) return a.ref;
                    a = function(a) {
                        var b = d.refs === D ? d.refs = {} : d.refs;
                        null === a ? delete b[e] : b[e] = a;
                    };
                    a._stringRef = e;
                    return a;
                }
                "string" !== typeof c ? E("148") : void 0;
                b._owner ? void 0 : E("149", c);
            }
            return c;
        }
        function $e(a, b) {
            "textarea" !== a.type && E("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "");
        }
        function af(a) {
            function b(b, c) {
                if (a) {
                    var d = b.lastEffect;
                    null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;
                    c.nextEffect = null;
                    c.effectTag = 8;
                }
            }
            function c(c, d) {
                if (!a) return null;
                for (;null !== d; ) b(c, d), d = d.sibling;
                return null;
            }
            function d(a, b) {
                for (a = new Map(); null !== b; ) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), 
                b = b.sibling;
                return a;
            }
            function e(a, b, c) {
                a = se(a, b, c);
                a.index = 0;
                a.sibling = null;
                return a;
            }
            function f(b, c, d) {
                b.index = d;
                if (!a) return c;
                d = b.alternate;
                if (null !== d) return d = d.index, d < c ? (b.effectTag = 2, c) : d;
                b.effectTag = 2;
                return c;
            }
            function g(b) {
                a && null === b.alternate && (b.effectTag = 2);
                return b;
            }
            function h(a, b, c, d) {
                if (null === b || 6 !== b.tag) return b = ve(c, a.internalContextTag, d), b["return"] = a, 
                b;
                b = e(b, c, d);
                b["return"] = a;
                return b;
            }
            function k(a, b, c, d) {
                if (null !== b && b.type === c.type) return d = e(b, c.props, d), d.ref = Ze(b, c), 
                d["return"] = a, d;
                d = te(c, a.internalContextTag, d);
                d.ref = Ze(b, c);
                d["return"] = a;
                return d;
            }
            function q(a, b, c, d) {
                if (null === b || 7 !== b.tag) return b = we(c, a.internalContextTag, d), b["return"] = a, 
                b;
                b = e(b, c, d);
                b["return"] = a;
                return b;
            }
            function v(a, b, c, d) {
                if (null === b || 9 !== b.tag) return b = xe(c, a.internalContextTag, d), b.type = c.value, 
                b["return"] = a, b;
                b = e(b, null, d);
                b.type = c.value;
                b["return"] = a;
                return b;
            }
            function y(a, b, c, d) {
                if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = ye(c, a.internalContextTag, d), 
                b["return"] = a, b;
                b = e(b, c.children || [], d);
                b["return"] = a;
                return b;
            }
            function u(a, b, c, d, f) {
                if (null === b || 10 !== b.tag) return b = ue(c, a.internalContextTag, d, f), b["return"] = a, 
                b;
                b = e(b, c, d);
                b["return"] = a;
                return b;
            }
            function z(a, b, c) {
                if ("string" === typeof b || "number" === typeof b) return b = ve("" + b, a.internalContextTag, c), 
                b["return"] = a, b;
                if ("object" === typeof b && null !== b) {
                    switch (b.$$typeof) {
                      case Re:
                        if (b.type === Ve) return b = ue(b.props.children, a.internalContextTag, c, b.key), 
                        b["return"] = a, b;
                        c = te(b, a.internalContextTag, c);
                        c.ref = Ze(null, b);
                        c["return"] = a;
                        return c;

                      case Se:
                        return b = we(b, a.internalContextTag, c), b["return"] = a, b;

                      case Te:
                        return c = xe(b, a.internalContextTag, c), c.type = b.value, c["return"] = a, c;

                      case Ue:
                        return b = ye(b, a.internalContextTag, c), b["return"] = a, b;
                    }
                    if (Ye(b) || Xe(b)) return b = ue(b, a.internalContextTag, c, null), b["return"] = a, 
                    b;
                    $e(a, b);
                }
                return null;
            }
            function G(a, b, c, d) {
                var e = null !== b ? b.key : null;
                if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);
                if ("object" === typeof c && null !== c) {
                    switch (c.$$typeof) {
                      case Re:
                        return c.key === e ? c.type === Ve ? u(a, b, c.props.children, d, e) : k(a, b, c, d) : null;

                      case Se:
                        return c.key === e ? q(a, b, c, d) : null;

                      case Te:
                        return null === e ? v(a, b, c, d) : null;

                      case Ue:
                        return c.key === e ? y(a, b, c, d) : null;
                    }
                    if (Ye(c) || Xe(c)) return null !== e ? null : u(a, b, c, d, null);
                    $e(a, c);
                }
                return null;
            }
            function I(a, b, c, d, e) {
                if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, 
                h(b, a, "" + d, e);
                if ("object" === typeof d && null !== d) {
                    switch (d.$$typeof) {
                      case Re:
                        return a = a.get(null === d.key ? c : d.key) || null, d.type === Ve ? u(b, a, d.props.children, e, d.key) : k(b, a, d, e);

                      case Se:
                        return a = a.get(null === d.key ? c : d.key) || null, q(b, a, d, e);

                      case Te:
                        return a = a.get(c) || null, v(b, a, d, e);

                      case Ue:
                        return a = a.get(null === d.key ? c : d.key) || null, y(b, a, d, e);
                    }
                    if (Ye(d) || Xe(d)) return a = a.get(c) || null, u(b, a, d, e, null);
                    $e(b, d);
                }
                return null;
            }
            function L(e, g, m, A) {
                for (var h = null, r = null, n = g, w = g = 0, k = null; null !== n && w < m.length; w++) {
                    n.index > w ? (k = n, n = null) : k = n.sibling;
                    var x = G(e, n, m[w], A);
                    if (null === x) {
                        null === n && (n = k);
                        break;
                    }
                    a && n && null === x.alternate && b(e, n);
                    g = f(x, g, w);
                    null === r ? h = x : r.sibling = x;
                    r = x;
                    n = k;
                }
                if (w === m.length) return c(e, n), h;
                if (null === n) {
                    for (;w < m.length; w++) if (n = z(e, m[w], A)) g = f(n, g, w), null === r ? h = n : r.sibling = n, 
                    r = n;
                    return h;
                }
                for (n = d(e, n); w < m.length; w++) if (k = I(n, e, w, m[w], A)) {
                    if (a && null !== k.alternate) n["delete"](null === k.key ? w : k.key);
                    g = f(k, g, w);
                    null === r ? h = k : r.sibling = k;
                    r = k;
                }
                a && n.forEach(function(a) {
                    return b(e, a);
                });
                return h;
            }
            function N(e, g, m, A) {
                var h = Xe(m);
                "function" !== typeof h ? E("150") : void 0;
                m = h.call(m);
                null == m ? E("151") : void 0;
                for (var r = h = null, n = g, w = g = 0, k = null, x = m.next(); null !== n && !x.done; w++, 
                x = m.next()) {
                    n.index > w ? (k = n, n = null) : k = n.sibling;
                    var J = G(e, n, x.value, A);
                    if (null === J) {
                        n || (n = k);
                        break;
                    }
                    a && n && null === J.alternate && b(e, n);
                    g = f(J, g, w);
                    null === r ? h = J : r.sibling = J;
                    r = J;
                    n = k;
                }
                if (x.done) return c(e, n), h;
                if (null === n) {
                    for (;!x.done; w++, x = m.next()) x = z(e, x.value, A), null !== x && (g = f(x, g, w), 
                    null === r ? h = x : r.sibling = x, r = x);
                    return h;
                }
                for (n = d(e, n); !x.done; w++, x = m.next()) if (x = I(n, e, w, x.value, A), null !== x) {
                    if (a && null !== x.alternate) n["delete"](null === x.key ? w : x.key);
                    g = f(x, g, w);
                    null === r ? h = x : r.sibling = x;
                    r = x;
                }
                a && n.forEach(function(a) {
                    return b(e, a);
                });
                return h;
            }
            return function(a, d, f, h) {
                "object" === typeof f && null !== f && f.type === Ve && null === f.key && (f = f.props.children);
                var m = "object" === typeof f && null !== f;
                if (m) switch (f.$$typeof) {
                  case Re:
                    a: {
                        var r = f.key;
                        for (m = d; null !== m; ) {
                            if (m.key === r) if (10 === m.tag ? f.type === Ve : m.type === f.type) {
                                c(a, m.sibling);
                                d = e(m, f.type === Ve ? f.props.children : f.props, h);
                                d.ref = Ze(m, f);
                                d["return"] = a;
                                a = d;
                                break a;
                            } else {
                                c(a, m);
                                break;
                            } else b(a, m);
                            m = m.sibling;
                        }
                        f.type === Ve ? (d = ue(f.props.children, a.internalContextTag, h, f.key), d["return"] = a, 
                        a = d) : (h = te(f, a.internalContextTag, h), h.ref = Ze(d, f), h["return"] = a, 
                        a = h);
                    }
                    return g(a);

                  case Se:
                    a: {
                        for (m = f.key; null !== d; ) {
                            if (d.key === m) if (7 === d.tag) {
                                c(a, d.sibling);
                                d = e(d, f, h);
                                d["return"] = a;
                                a = d;
                                break a;
                            } else {
                                c(a, d);
                                break;
                            } else b(a, d);
                            d = d.sibling;
                        }
                        d = we(f, a.internalContextTag, h);
                        d["return"] = a;
                        a = d;
                    }
                    return g(a);

                  case Te:
                    a: {
                        if (null !== d) if (9 === d.tag) {
                            c(a, d.sibling);
                            d = e(d, null, h);
                            d.type = f.value;
                            d["return"] = a;
                            a = d;
                            break a;
                        } else c(a, d);
                        d = xe(f, a.internalContextTag, h);
                        d.type = f.value;
                        d["return"] = a;
                        a = d;
                    }
                    return g(a);

                  case Ue:
                    a: {
                        for (m = f.key; null !== d; ) {
                            if (d.key === m) if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                                c(a, d.sibling);
                                d = e(d, f.children || [], h);
                                d["return"] = a;
                                a = d;
                                break a;
                            } else {
                                c(a, d);
                                break;
                            } else b(a, d);
                            d = d.sibling;
                        }
                        d = ye(f, a.internalContextTag, h);
                        d["return"] = a;
                        a = d;
                    }
                    return g(a);
                }
                if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), 
                d = e(d, f, h)) : (c(a, d), d = ve(f, a.internalContextTag, h)), d["return"] = a, 
                a = d, g(a);
                if (Ye(f)) return L(a, d, f, h);
                if (Xe(f)) return N(a, d, f, h);
                m && $e(a, f);
                if ("undefined" === typeof f) switch (a.tag) {
                  case 2:
                  case 1:
                    h = a.type, E("152", h.displayName || h.name || "Component");
                }
                return c(a, d);
            };
        }
        var bf = af(!0), cf = af(!1);
        function df(a, b, c, d, e) {
            function f(a, b, c) {
                var d = b.expirationTime;
                b.child = null === a ? cf(b, null, c, d) : bf(b, a.child, c, d);
            }
            function g(a, b) {
                var c = b.ref;
                null === c || a && a.ref === c || (b.effectTag |= 128);
            }
            function h(a, b, c, d) {
                g(a, b);
                if (!c) return d && re(b, !1), q(a, b);
                c = b.stateNode;
                id.current = b;
                var e = c.render();
                b.effectTag |= 1;
                f(a, b, e);
                b.memoizedState = c.state;
                b.memoizedProps = c.props;
                d && re(b, !0);
                return b.child;
            }
            function k(a) {
                var b = a.stateNode;
                b.pendingContext ? oe(a, b.pendingContext, b.pendingContext !== b.context) : b.context && oe(a, b.context, !1);
                I(a, b.containerInfo);
            }
            function q(a, b) {
                null !== a && b.child !== a.child ? E("153") : void 0;
                if (null !== b.child) {
                    a = b.child;
                    var c = se(a, a.pendingProps, a.expirationTime);
                    b.child = c;
                    for (c["return"] = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = se(a, a.pendingProps, a.expirationTime), 
                    c["return"] = b;
                    c.sibling = null;
                }
                return b.child;
            }
            function v(a, b) {
                switch (b.tag) {
                  case 3:
                    k(b);
                    break;

                  case 2:
                    qe(b);
                    break;

                  case 4:
                    I(b, b.stateNode.containerInfo);
                }
                return null;
            }
            var y = a.shouldSetTextContent, u = a.useSyncScheduling, z = a.shouldDeprioritizeSubtree, G = b.pushHostContext, I = b.pushHostContainer, L = c.enterHydrationState, N = c.resetHydrationState, J = c.tryToClaimNextHydratableInstance;
            a = Le(d, e, function(a, b) {
                a.memoizedProps = b;
            }, function(a, b) {
                a.memoizedState = b;
            });
            var w = a.adoptClassInstance, m = a.constructClassInstance, A = a.mountClassInstance, Ob = a.updateClassInstance;
            return {
                beginWork: function(a, b, c) {
                    if (0 === b.expirationTime || b.expirationTime > c) return v(a, b);
                    switch (b.tag) {
                      case 0:
                        null !== a ? E("155") : void 0;
                        var d = b.type, e = b.pendingProps, r = ke(b);
                        r = me(b, r);
                        d = d(e, r);
                        b.effectTag |= 1;
                        "object" === typeof d && null !== d && "function" === typeof d.render ? (b.tag = 2, 
                        e = qe(b), w(b, d), A(b, c), b = h(a, b, !0, e)) : (b.tag = 1, f(a, b, d), b.memoizedProps = e, 
                        b = b.child);
                        return b;

                      case 1:
                        a: {
                            e = b.type;
                            c = b.pendingProps;
                            d = b.memoizedProps;
                            if (X.current) null === c && (c = d); else if (null === c || d === c) {
                                b = q(a, b);
                                break a;
                            }
                            d = ke(b);
                            d = me(b, d);
                            e = e(c, d);
                            b.effectTag |= 1;
                            f(a, b, e);
                            b.memoizedProps = c;
                            b = b.child;
                        }
                        return b;

                      case 2:
                        return e = qe(b), d = void 0, null === a ? b.stateNode ? E("153") : (m(b, b.pendingProps), 
                        A(b, c), d = !0) : d = Ob(a, b, c), h(a, b, d, e);

                      case 3:
                        return k(b), e = b.updateQueue, null !== e ? (d = b.memoizedState, e = Je(a, b, e, null, null, c), 
                        d === e ? (N(), b = q(a, b)) : (d = e.element, r = b.stateNode, (null === a || null === a.child) && r.hydrate && L(b) ? (b.effectTag |= 2, 
                        b.child = cf(b, null, d, c)) : (N(), f(a, b, d)), b.memoizedState = e, b = b.child)) : (N(), 
                        b = q(a, b)), b;

                      case 5:
                        G(b);
                        null === a && J(b);
                        e = b.type;
                        var n = b.memoizedProps;
                        d = b.pendingProps;
                        null === d && (d = n, null === d ? E("154") : void 0);
                        r = null !== a ? a.memoizedProps : null;
                        X.current || null !== d && n !== d ? (n = d.children, y(e, d) ? n = null : r && y(e, r) && (b.effectTag |= 16), 
                        g(a, b), 2147483647 !== c && !u && z(e, d) ? (b.expirationTime = 2147483647, b = null) : (f(a, b, n), 
                        b.memoizedProps = d, b = b.child)) : b = q(a, b);
                        return b;

                      case 6:
                        return null === a && J(b), a = b.pendingProps, null === a && (a = b.memoizedProps), 
                        b.memoizedProps = a, null;

                      case 8:
                        b.tag = 7;

                      case 7:
                        e = b.pendingProps;
                        if (X.current) null === e && (e = a && a.memoizedProps, null === e ? E("154") : void 0); else if (null === e || b.memoizedProps === e) e = b.memoizedProps;
                        d = e.children;
                        b.stateNode = null === a ? cf(b, b.stateNode, d, c) : bf(b, b.stateNode, d, c);
                        b.memoizedProps = e;
                        return b.stateNode;

                      case 9:
                        return null;

                      case 4:
                        a: {
                            I(b, b.stateNode.containerInfo);
                            e = b.pendingProps;
                            if (X.current) null === e && (e = a && a.memoizedProps, null == e ? E("154") : void 0); else if (null === e || b.memoizedProps === e) {
                                b = q(a, b);
                                break a;
                            }
                            null === a ? b.child = bf(b, null, e, c) : f(a, b, e);
                            b.memoizedProps = e;
                            b = b.child;
                        }
                        return b;

                      case 10:
                        a: {
                            c = b.pendingProps;
                            if (X.current) null === c && (c = b.memoizedProps); else if (null === c || b.memoizedProps === c) {
                                b = q(a, b);
                                break a;
                            }
                            f(a, b, c);
                            b.memoizedProps = c;
                            b = b.child;
                        }
                        return b;

                      default:
                        E("156");
                    }
                },
                beginFailedWork: function(a, b, c) {
                    switch (b.tag) {
                      case 2:
                        qe(b);
                        break;

                      case 3:
                        k(b);
                        break;

                      default:
                        E("157");
                    }
                    b.effectTag |= 64;
                    null === a ? b.child = null : b.child !== a.child && (b.child = a.child);
                    if (0 === b.expirationTime || b.expirationTime > c) return v(a, b);
                    b.firstEffect = null;
                    b.lastEffect = null;
                    b.child = null === a ? cf(b, null, null, c) : bf(b, a.child, null, c);
                    2 === b.tag && (a = b.stateNode, b.memoizedProps = a.props, b.memoizedState = a.state);
                    return b.child;
                }
            };
        }
        function ef(a, b, c) {
            function d(a) {
                a.effectTag |= 4;
            }
            var e = a.createInstance, f = a.createTextInstance, g = a.appendInitialChild, h = a.finalizeInitialChildren, k = a.prepareUpdate, q = a.persistence, v = b.getRootHostContainer, y = b.popHostContext, u = b.getHostContext, z = b.popHostContainer, G = c.prepareToHydrateHostInstance, I = c.prepareToHydrateHostTextInstance, L = c.popHydrationState, N = void 0, J = void 0, w = void 0;
            a.mutation ? (N = function() {}, J = function(a, b, c) {
                (b.updateQueue = c) && d(b);
            }, w = function(a, b, c, e) {
                c !== e && d(b);
            }) : q ? E("235") : E("236");
            return {
                completeWork: function(a, b, c) {
                    var m = b.pendingProps;
                    if (null === m) m = b.memoizedProps; else if (2147483647 !== b.expirationTime || 2147483647 === c) b.pendingProps = null;
                    switch (b.tag) {
                      case 1:
                        return null;

                      case 2:
                        return ne(b), null;

                      case 3:
                        z(b);
                        V(X, b);
                        V(ie, b);
                        m = b.stateNode;
                        m.pendingContext && (m.context = m.pendingContext, m.pendingContext = null);
                        if (null === a || null === a.child) L(b), b.effectTag &= -3;
                        N(b);
                        return null;

                      case 5:
                        y(b);
                        c = v();
                        var A = b.type;
                        if (null !== a && null != b.stateNode) {
                            var p = a.memoizedProps, q = b.stateNode, x = u();
                            q = k(q, A, p, m, c, x);
                            J(a, b, q, A, p, m, c);
                            a.ref !== b.ref && (b.effectTag |= 128);
                        } else {
                            if (!m) return null === b.stateNode ? E("166") : void 0, null;
                            a = u();
                            if (L(b)) G(b, c, a) && d(b); else {
                                a = e(A, m, c, a, b);
                                a: for (p = b.child; null !== p; ) {
                                    if (5 === p.tag || 6 === p.tag) g(a, p.stateNode); else if (4 !== p.tag && null !== p.child) {
                                        p.child["return"] = p;
                                        p = p.child;
                                        continue;
                                    }
                                    if (p === b) break;
                                    for (;null === p.sibling; ) {
                                        if (null === p["return"] || p["return"] === b) break a;
                                        p = p["return"];
                                    }
                                    p.sibling["return"] = p["return"];
                                    p = p.sibling;
                                }
                                h(a, A, m, c) && d(b);
                                b.stateNode = a;
                            }
                            null !== b.ref && (b.effectTag |= 128);
                        }
                        return null;

                      case 6:
                        if (a && null != b.stateNode) w(a, b, a.memoizedProps, m); else {
                            if ("string" !== typeof m) return null === b.stateNode ? E("166") : void 0, null;
                            a = v();
                            c = u();
                            L(b) ? I(b) && d(b) : b.stateNode = f(m, a, c, b);
                        }
                        return null;

                      case 7:
                        (m = b.memoizedProps) ? void 0 : E("165");
                        b.tag = 8;
                        A = [];
                        a: for ((p = b.stateNode) && (p["return"] = b); null !== p; ) {
                            if (5 === p.tag || 6 === p.tag || 4 === p.tag) E("247"); else if (9 === p.tag) A.push(p.type); else if (null !== p.child) {
                                p.child["return"] = p;
                                p = p.child;
                                continue;
                            }
                            for (;null === p.sibling; ) {
                                if (null === p["return"] || p["return"] === b) break a;
                                p = p["return"];
                            }
                            p.sibling["return"] = p["return"];
                            p = p.sibling;
                        }
                        p = m.handler;
                        m = p(m.props, A);
                        b.child = bf(b, null !== a ? a.child : null, m, c);
                        return b.child;

                      case 8:
                        return b.tag = 7, null;

                      case 9:
                        return null;

                      case 10:
                        return null;

                      case 4:
                        return z(b), N(b), null;

                      case 0:
                        E("167");

                      default:
                        E("156");
                    }
                }
            };
        }
        function ff(a, b) {
            function c(a) {
                var c = a.ref;
                if (null !== c) try {
                    c(null);
                } catch (A) {
                    b(a, A);
                }
            }
            function d(a) {
                "function" === typeof Ee && Ee(a);
                switch (a.tag) {
                  case 2:
                    c(a);
                    var d = a.stateNode;
                    if ("function" === typeof d.componentWillUnmount) try {
                        d.props = a.memoizedProps, d.state = a.memoizedState, d.componentWillUnmount();
                    } catch (A) {
                        b(a, A);
                    }
                    break;

                  case 5:
                    c(a);
                    break;

                  case 7:
                    e(a.stateNode);
                    break;

                  case 4:
                    k && g(a);
                }
            }
            function e(a) {
                for (var b = a; ;) if (d(b), null === b.child || k && 4 === b.tag) {
                    if (b === a) break;
                    for (;null === b.sibling; ) {
                        if (null === b["return"] || b["return"] === a) return;
                        b = b["return"];
                    }
                    b.sibling["return"] = b["return"];
                    b = b.sibling;
                } else b.child["return"] = b, b = b.child;
            }
            function f(a) {
                return 5 === a.tag || 3 === a.tag || 4 === a.tag;
            }
            function g(a) {
                for (var b = a, c = !1, f = void 0, g = void 0; ;) {
                    if (!c) {
                        c = b["return"];
                        a: for (;;) {
                            null === c ? E("160") : void 0;
                            switch (c.tag) {
                              case 5:
                                f = c.stateNode;
                                g = !1;
                                break a;

                              case 3:
                                f = c.stateNode.containerInfo;
                                g = !0;
                                break a;

                              case 4:
                                f = c.stateNode.containerInfo;
                                g = !0;
                                break a;
                            }
                            c = c["return"];
                        }
                        c = !0;
                    }
                    if (5 === b.tag || 6 === b.tag) e(b), g ? J(f, b.stateNode) : N(f, b.stateNode); else if (4 === b.tag ? f = b.stateNode.containerInfo : d(b), 
                    null !== b.child) {
                        b.child["return"] = b;
                        b = b.child;
                        continue;
                    }
                    if (b === a) break;
                    for (;null === b.sibling; ) {
                        if (null === b["return"] || b["return"] === a) return;
                        b = b["return"];
                        4 === b.tag && (c = !1);
                    }
                    b.sibling["return"] = b["return"];
                    b = b.sibling;
                }
            }
            var h = a.getPublicInstance, k = a.mutation;
            a = a.persistence;
            k || (a ? E("235") : E("236"));
            var q = k.commitMount, v = k.commitUpdate, y = k.resetTextContent, u = k.commitTextUpdate, z = k.appendChild, G = k.appendChildToContainer, I = k.insertBefore, L = k.insertInContainerBefore, N = k.removeChild, J = k.removeChildFromContainer;
            return {
                commitResetTextContent: function(a) {
                    y(a.stateNode);
                },
                commitPlacement: function(a) {
                    a: {
                        for (var b = a["return"]; null !== b; ) {
                            if (f(b)) {
                                var c = b;
                                break a;
                            }
                            b = b["return"];
                        }
                        E("160");
                        c = void 0;
                    }
                    var d = b = void 0;
                    switch (c.tag) {
                      case 5:
                        b = c.stateNode;
                        d = !1;
                        break;

                      case 3:
                        b = c.stateNode.containerInfo;
                        d = !0;
                        break;

                      case 4:
                        b = c.stateNode.containerInfo;
                        d = !0;
                        break;

                      default:
                        E("161");
                    }
                    c.effectTag & 16 && (y(b), c.effectTag &= -17);
                    a: b: for (c = a; ;) {
                        for (;null === c.sibling; ) {
                            if (null === c["return"] || f(c["return"])) {
                                c = null;
                                break a;
                            }
                            c = c["return"];
                        }
                        c.sibling["return"] = c["return"];
                        for (c = c.sibling; 5 !== c.tag && 6 !== c.tag; ) {
                            if (c.effectTag & 2) continue b;
                            if (null === c.child || 4 === c.tag) continue b; else c.child["return"] = c, c = c.child;
                        }
                        if (!(c.effectTag & 2)) {
                            c = c.stateNode;
                            break a;
                        }
                    }
                    for (var e = a; ;) {
                        if (5 === e.tag || 6 === e.tag) c ? d ? L(b, e.stateNode, c) : I(b, e.stateNode, c) : d ? G(b, e.stateNode) : z(b, e.stateNode); else if (4 !== e.tag && null !== e.child) {
                            e.child["return"] = e;
                            e = e.child;
                            continue;
                        }
                        if (e === a) break;
                        for (;null === e.sibling; ) {
                            if (null === e["return"] || e["return"] === a) return;
                            e = e["return"];
                        }
                        e.sibling["return"] = e["return"];
                        e = e.sibling;
                    }
                },
                commitDeletion: function(a) {
                    g(a);
                    a["return"] = null;
                    a.child = null;
                    a.alternate && (a.alternate.child = null, a.alternate["return"] = null);
                },
                commitWork: function(a, b) {
                    switch (b.tag) {
                      case 2:
                        break;

                      case 5:
                        var c = b.stateNode;
                        if (null != c) {
                            var d = b.memoizedProps;
                            a = null !== a ? a.memoizedProps : d;
                            var e = b.type, f = b.updateQueue;
                            b.updateQueue = null;
                            null !== f && v(c, f, e, a, d, b);
                        }
                        break;

                      case 6:
                        null === b.stateNode ? E("162") : void 0;
                        c = b.memoizedProps;
                        u(b.stateNode, null !== a ? a.memoizedProps : c, c);
                        break;

                      case 3:
                        break;

                      default:
                        E("163");
                    }
                },
                commitLifeCycles: function(a, b) {
                    switch (b.tag) {
                      case 2:
                        var c = b.stateNode;
                        if (b.effectTag & 4) if (null === a) c.props = b.memoizedProps, c.state = b.memoizedState, 
                        c.componentDidMount(); else {
                            var d = a.memoizedProps;
                            a = a.memoizedState;
                            c.props = b.memoizedProps;
                            c.state = b.memoizedState;
                            c.componentDidUpdate(d, a);
                        }
                        b = b.updateQueue;
                        null !== b && Ke(b, c);
                        break;

                      case 3:
                        c = b.updateQueue;
                        null !== c && Ke(c, null !== b.child ? b.child.stateNode : null);
                        break;

                      case 5:
                        c = b.stateNode;
                        null === a && b.effectTag & 4 && q(c, b.type, b.memoizedProps, b);
                        break;

                      case 6:
                        break;

                      case 4:
                        break;

                      default:
                        E("163");
                    }
                },
                commitAttachRef: function(a) {
                    var b = a.ref;
                    if (null !== b) {
                        var c = a.stateNode;
                        switch (a.tag) {
                          case 5:
                            b(h(c));
                            break;

                          default:
                            b(c);
                        }
                    }
                },
                commitDetachRef: function(a) {
                    a = a.ref;
                    null !== a && a(null);
                }
            };
        }
        var gf = {};
        function hf(a) {
            function b(a) {
                a === gf ? E("174") : void 0;
                return a;
            }
            var c = a.getChildHostContext, d = a.getRootHostContext, e = {
                current: gf
            }, f = {
                current: gf
            }, g = {
                current: gf
            };
            return {
                getHostContext: function() {
                    return b(e.current);
                },
                getRootHostContainer: function() {
                    return b(g.current);
                },
                popHostContainer: function(a) {
                    V(e, a);
                    V(f, a);
                    V(g, a);
                },
                popHostContext: function(a) {
                    f.current === a && (V(e, a), V(f, a));
                },
                pushHostContainer: function(a, b) {
                    W(g, b, a);
                    b = d(b);
                    W(f, a, a);
                    W(e, b, a);
                },
                pushHostContext: function(a) {
                    var d = b(g.current), h = b(e.current);
                    d = c(h, a.type, d);
                    h !== d && (W(f, a, a), W(e, d, a));
                },
                resetHostContainer: function() {
                    e.current = gf;
                    g.current = gf;
                }
            };
        }
        function jf(a) {
            function b(a, b) {
                var c = new Y(5, null, 0);
                c.type = "DELETED";
                c.stateNode = b;
                c["return"] = a;
                c.effectTag = 8;
                null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
            }
            function c(a, b) {
                switch (a.tag) {
                  case 5:
                    return b = f(b, a.type, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

                  case 6:
                    return b = g(b, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

                  default:
                    return !1;
                }
            }
            function d(a) {
                for (a = a["return"]; null !== a && 5 !== a.tag && 3 !== a.tag; ) a = a["return"];
                y = a;
            }
            var e = a.shouldSetTextContent;
            a = a.hydration;
            if (!a) return {
                enterHydrationState: function() {
                    return !1;
                },
                resetHydrationState: function() {},
                tryToClaimNextHydratableInstance: function() {},
                prepareToHydrateHostInstance: function() {
                    E("175");
                },
                prepareToHydrateHostTextInstance: function() {
                    E("176");
                },
                popHydrationState: function() {
                    return !1;
                }
            };
            var f = a.canHydrateInstance, g = a.canHydrateTextInstance, h = a.getNextHydratableSibling, k = a.getFirstHydratableChild, q = a.hydrateInstance, v = a.hydrateTextInstance, y = null, u = null, z = !1;
            return {
                enterHydrationState: function(a) {
                    u = k(a.stateNode.containerInfo);
                    y = a;
                    return z = !0;
                },
                resetHydrationState: function() {
                    u = y = null;
                    z = !1;
                },
                tryToClaimNextHydratableInstance: function(a) {
                    if (z) {
                        var d = u;
                        if (d) {
                            if (!c(a, d)) {
                                d = h(d);
                                if (!d || !c(a, d)) {
                                    a.effectTag |= 2;
                                    z = !1;
                                    y = a;
                                    return;
                                }
                                b(y, u);
                            }
                            y = a;
                            u = k(d);
                        } else a.effectTag |= 2, z = !1, y = a;
                    }
                },
                prepareToHydrateHostInstance: function(a, b, c) {
                    b = q(a.stateNode, a.type, a.memoizedProps, b, c, a);
                    a.updateQueue = b;
                    return null !== b ? !0 : !1;
                },
                prepareToHydrateHostTextInstance: function(a) {
                    return v(a.stateNode, a.memoizedProps, a);
                },
                popHydrationState: function(a) {
                    if (a !== y) return !1;
                    if (!z) return d(a), z = !0, !1;
                    var c = a.type;
                    if (5 !== a.tag || "head" !== c && "body" !== c && !e(c, a.memoizedProps)) for (c = u; c; ) b(a, c), 
                    c = h(c);
                    d(a);
                    u = y ? h(a.stateNode) : null;
                    return !0;
                }
            };
        }
        function kf(a) {
            function b(a) {
                Qb = ja = !0;
                var b = a.stateNode;
                b.current === a ? E("177") : void 0;
                b.isReadyForCommit = !1;
                id.current = null;
                if (1 < a.effectTag) if (null !== a.lastEffect) {
                    a.lastEffect.nextEffect = a;
                    var c = a.firstEffect;
                } else c = a; else c = a.firstEffect;
                yg();
                for (t = c; null !== t; ) {
                    var d = !1, e = void 0;
                    try {
                        for (;null !== t; ) {
                            var f = t.effectTag;
                            f & 16 && zg(t);
                            if (f & 128) {
                                var g = t.alternate;
                                null !== g && Ag(g);
                            }
                            switch (f & -242) {
                              case 2:
                                Ne(t);
                                t.effectTag &= -3;
                                break;

                              case 6:
                                Ne(t);
                                t.effectTag &= -3;
                                Oe(t.alternate, t);
                                break;

                              case 4:
                                Oe(t.alternate, t);
                                break;

                              case 8:
                                Sc = !0, Bg(t), Sc = !1;
                            }
                            t = t.nextEffect;
                        }
                    } catch (Tc) {
                        d = !0, e = Tc;
                    }
                    d && (null === t ? E("178") : void 0, h(t, e), null !== t && (t = t.nextEffect));
                }
                Cg();
                b.current = a;
                for (t = c; null !== t; ) {
                    c = !1;
                    d = void 0;
                    try {
                        for (;null !== t; ) {
                            var k = t.effectTag;
                            k & 36 && Dg(t.alternate, t);
                            k & 128 && Eg(t);
                            if (k & 64) switch (e = t, f = void 0, null !== R && (f = R.get(e), R["delete"](e), 
                            null == f && null !== e.alternate && (e = e.alternate, f = R.get(e), R["delete"](e))), 
                            null == f ? E("184") : void 0, e.tag) {
                              case 2:
                                e.stateNode.componentDidCatch(f.error, {
                                    componentStack: f.componentStack
                                });
                                break;

                              case 3:
                                null === ca && (ca = f.error);
                                break;

                              default:
                                E("157");
                            }
                            var Qc = t.nextEffect;
                            t.nextEffect = null;
                            t = Qc;
                        }
                    } catch (Tc) {
                        c = !0, d = Tc;
                    }
                    c && (null === t ? E("178") : void 0, h(t, d), null !== t && (t = t.nextEffect));
                }
                ja = Qb = !1;
                "function" === typeof De && De(a.stateNode);
                ha && (ha.forEach(G), ha = null);
                null !== ca && (a = ca, ca = null, Ob(a));
                b = b.current.expirationTime;
                0 === b && (qa = R = null);
                return b;
            }
            function c(a) {
                for (;;) {
                    var b = Fg(a.alternate, a, H), c = a["return"], d = a.sibling;
                    var e = a;
                    if (2147483647 === H || 2147483647 !== e.expirationTime) {
                        if (2 !== e.tag && 3 !== e.tag) var f = 0; else f = e.updateQueue, f = null === f ? 0 : f.expirationTime;
                        for (var g = e.child; null !== g; ) 0 !== g.expirationTime && (0 === f || f > g.expirationTime) && (f = g.expirationTime), 
                        g = g.sibling;
                        e.expirationTime = f;
                    }
                    if (null !== b) return b;
                    null !== c && (null === c.firstEffect && (c.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), 
                    c.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, 
                    c.lastEffect = a));
                    if (null !== d) return d;
                    if (null !== c) a = c; else {
                        a.stateNode.isReadyForCommit = !0;
                        break;
                    }
                }
                return null;
            }
            function d(a) {
                var b = rg(a.alternate, a, H);
                null === b && (b = c(a));
                id.current = null;
                return b;
            }
            function e(a) {
                var b = Gg(a.alternate, a, H);
                null === b && (b = c(a));
                id.current = null;
                return b;
            }
            function f(a) {
                if (null !== R) {
                    if (!(0 === H || H > a)) if (H <= Uc) for (;null !== F; ) F = k(F) ? e(F) : d(F); else for (;null !== F && !A(); ) F = k(F) ? e(F) : d(F);
                } else if (!(0 === H || H > a)) if (H <= Uc) for (;null !== F; ) F = d(F); else for (;null !== F && !A(); ) F = d(F);
            }
            function g(a, b) {
                ja ? E("243") : void 0;
                ja = !0;
                a.isReadyForCommit = !1;
                if (a !== ra || b !== H || null === F) {
                    for (;-1 < he; ) ge[he] = null, he--;
                    je = D;
                    ie.current = D;
                    X.current = !1;
                    x();
                    ra = a;
                    H = b;
                    F = se(ra.current, null, b);
                }
                var c = !1, d = null;
                try {
                    f(b);
                } catch (Rc) {
                    c = !0, d = Rc;
                }
                for (;c; ) {
                    if (eb) {
                        ca = d;
                        break;
                    }
                    var g = F;
                    if (null === g) eb = !0; else {
                        var k = h(g, d);
                        null === k ? E("183") : void 0;
                        if (!eb) {
                            try {
                                c = k;
                                d = b;
                                for (k = c; null !== g; ) {
                                    switch (g.tag) {
                                      case 2:
                                        ne(g);
                                        break;

                                      case 5:
                                        qg(g);
                                        break;

                                      case 3:
                                        p(g);
                                        break;

                                      case 4:
                                        p(g);
                                    }
                                    if (g === k || g.alternate === k) break;
                                    g = g["return"];
                                }
                                F = e(c);
                                f(d);
                            } catch (Rc) {
                                c = !0;
                                d = Rc;
                                continue;
                            }
                            break;
                        }
                    }
                }
                b = ca;
                eb = ja = !1;
                ca = null;
                null !== b && Ob(b);
                return a.isReadyForCommit ? a.current.alternate : null;
            }
            function h(a, b) {
                var c = id.current = null, d = !1, e = !1, f = null;
                if (3 === a.tag) c = a, q(a) && (eb = !0); else for (var g = a["return"]; null !== g && null === c; ) {
                    2 === g.tag ? "function" === typeof g.stateNode.componentDidCatch && (d = !0, f = jd(g), 
                    c = g, e = !0) : 3 === g.tag && (c = g);
                    if (q(g)) {
                        if (Sc || null !== ha && (ha.has(g) || null !== g.alternate && ha.has(g.alternate))) return null;
                        c = null;
                        e = !1;
                    }
                    g = g["return"];
                }
                if (null !== c) {
                    null === qa && (qa = new Set());
                    qa.add(c);
                    var h = "";
                    g = a;
                    do {
                        a: switch (g.tag) {
                          case 0:
                          case 1:
                          case 2:
                          case 5:
                            var k = g._debugOwner, Qc = g._debugSource;
                            var m = jd(g);
                            var n = null;
                            k && (n = jd(k));
                            k = Qc;
                            m = "\n    in " + (m || "Unknown") + (k ? " (at " + k.fileName.replace(/^.*[\\\/]/, "") + ":" + k.lineNumber + ")" : n ? " (created by " + n + ")" : "");
                            break a;

                          default:
                            m = "";
                        }
                        h += m;
                        g = g["return"];
                    } while (g);
                    g = h;
                    a = jd(a);
                    null === R && (R = new Map());
                    b = {
                        componentName: a,
                        componentStack: g,
                        error: b,
                        errorBoundary: d ? c.stateNode : null,
                        errorBoundaryFound: d,
                        errorBoundaryName: f,
                        willRetry: e
                    };
                    R.set(c, b);
                    try {
                        var p = b.error;
                        p && p.suppressReactErrorLogging || console.error(p);
                    } catch (Vc) {
                        Vc && Vc.suppressReactErrorLogging || console.error(Vc);
                    }
                    Qb ? (null === ha && (ha = new Set()), ha.add(c)) : G(c);
                    return c;
                }
                null === ca && (ca = b);
                return null;
            }
            function k(a) {
                return null !== R && (R.has(a) || null !== a.alternate && R.has(a.alternate));
            }
            function q(a) {
                return null !== qa && (qa.has(a) || null !== a.alternate && qa.has(a.alternate));
            }
            function v() {
                return 20 * (((I() + 100) / 20 | 0) + 1);
            }
            function y(a) {
                return 0 !== ka ? ka : ja ? Qb ? 1 : H : !Hg || a.internalContextTag & 1 ? v() : 1;
            }
            function u(a, b) {
                return z(a, b, !1);
            }
            function z(a, b) {
                for (;null !== a; ) {
                    if (0 === a.expirationTime || a.expirationTime > b) a.expirationTime = b;
                    null !== a.alternate && (0 === a.alternate.expirationTime || a.alternate.expirationTime > b) && (a.alternate.expirationTime = b);
                    if (null === a["return"]) if (3 === a.tag) {
                        var c = a.stateNode;
                        !ja && c === ra && b < H && (F = ra = null, H = 0);
                        var d = c, e = b;
                        Rb > Ig && E("185");
                        if (null === d.nextScheduledRoot) d.remainingExpirationTime = e, null === O ? (sa = O = d, 
                        d.nextScheduledRoot = d) : (O = O.nextScheduledRoot = d, O.nextScheduledRoot = sa); else {
                            var f = d.remainingExpirationTime;
                            if (0 === f || e < f) d.remainingExpirationTime = e;
                        }
                        Fa || (la ? Sb && (ma = d, na = 1, m(ma, na)) : 1 === e ? w(1, null) : L(e));
                        !ja && c === ra && b < H && (F = ra = null, H = 0);
                    } else break;
                    a = a["return"];
                }
            }
            function G(a) {
                z(a, 1, !0);
            }
            function I() {
                return Uc = ((Wc() - Pe) / 10 | 0) + 2;
            }
            function L(a) {
                if (0 !== Tb) {
                    if (a > Tb) return;
                    Jg(Xc);
                }
                var b = Wc() - Pe;
                Tb = a;
                Xc = Kg(J, {
                    timeout: 10 * (a - 2) - b
                });
            }
            function N() {
                var a = 0, b = null;
                if (null !== O) for (var c = O, d = sa; null !== d; ) {
                    var e = d.remainingExpirationTime;
                    if (0 === e) {
                        null === c || null === O ? E("244") : void 0;
                        if (d === d.nextScheduledRoot) {
                            sa = O = d.nextScheduledRoot = null;
                            break;
                        } else if (d === sa) sa = e = d.nextScheduledRoot, O.nextScheduledRoot = e, d.nextScheduledRoot = null; else if (d === O) {
                            O = c;
                            O.nextScheduledRoot = sa;
                            d.nextScheduledRoot = null;
                            break;
                        } else c.nextScheduledRoot = d.nextScheduledRoot, d.nextScheduledRoot = null;
                        d = c.nextScheduledRoot;
                    } else {
                        if (0 === a || e < a) a = e, b = d;
                        if (d === O) break;
                        c = d;
                        d = d.nextScheduledRoot;
                    }
                }
                c = ma;
                null !== c && c === b ? Rb++ : Rb = 0;
                ma = b;
                na = a;
            }
            function J(a) {
                w(0, a);
            }
            function w(a, b) {
                fb = b;
                for (N(); null !== ma && 0 !== na && (0 === a || na <= a) && !Yc; ) m(ma, na), N();
                null !== fb && (Tb = 0, Xc = -1);
                0 !== na && L(na);
                fb = null;
                Yc = !1;
                Rb = 0;
                if (Ub) throw a = Zc, Zc = null, Ub = !1, a;
            }
            function m(a, c) {
                Fa ? E("245") : void 0;
                Fa = !0;
                if (c <= I()) {
                    var d = a.finishedWork;
                    null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, 
                    d = g(a, c), null !== d && (a.remainingExpirationTime = b(d)));
                } else d = a.finishedWork, null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, 
                d = g(a, c), null !== d && (A() ? a.finishedWork = d : a.remainingExpirationTime = b(d)));
                Fa = !1;
            }
            function A() {
                return null === fb || fb.timeRemaining() > Lg ? !1 : Yc = !0;
            }
            function Ob(a) {
                null === ma ? E("246") : void 0;
                ma.remainingExpirationTime = 0;
                Ub || (Ub = !0, Zc = a);
            }
            var r = hf(a), n = jf(a), p = r.popHostContainer, qg = r.popHostContext, x = r.resetHostContainer, Me = df(a, r, n, u, y), rg = Me.beginWork, Gg = Me.beginFailedWork, Fg = ef(a, r, n).completeWork;
            r = ff(a, h);
            var zg = r.commitResetTextContent, Ne = r.commitPlacement, Bg = r.commitDeletion, Oe = r.commitWork, Dg = r.commitLifeCycles, Eg = r.commitAttachRef, Ag = r.commitDetachRef, Wc = a.now, Kg = a.scheduleDeferredCallback, Jg = a.cancelDeferredCallback, Hg = a.useSyncScheduling, yg = a.prepareForCommit, Cg = a.resetAfterCommit, Pe = Wc(), Uc = 2, ka = 0, ja = !1, F = null, ra = null, H = 0, t = null, R = null, qa = null, ha = null, ca = null, eb = !1, Qb = !1, Sc = !1, sa = null, O = null, Tb = 0, Xc = -1, Fa = !1, ma = null, na = 0, Yc = !1, Ub = !1, Zc = null, fb = null, la = !1, Sb = !1, Ig = 1e3, Rb = 0, Lg = 1;
            return {
                computeAsyncExpiration: v,
                computeExpirationForFiber: y,
                scheduleWork: u,
                batchedUpdates: function(a, b) {
                    var c = la;
                    la = !0;
                    try {
                        return a(b);
                    } finally {
                        (la = c) || Fa || w(1, null);
                    }
                },
                unbatchedUpdates: function(a) {
                    if (la && !Sb) {
                        Sb = !0;
                        try {
                            return a();
                        } finally {
                            Sb = !1;
                        }
                    }
                    return a();
                },
                flushSync: function(a) {
                    var b = la;
                    la = !0;
                    try {
                        a: {
                            var c = ka;
                            ka = 1;
                            try {
                                var d = a();
                                break a;
                            } finally {
                                ka = c;
                            }
                            d = void 0;
                        }
                        return d;
                    } finally {
                        la = b, Fa ? E("187") : void 0, w(1, null);
                    }
                },
                deferredUpdates: function(a) {
                    var b = ka;
                    ka = v();
                    try {
                        return a();
                    } finally {
                        ka = b;
                    }
                }
            };
        }
        function lf(a) {
            function b(a) {
                a = od(a);
                return null === a ? null : a.stateNode;
            }
            var c = a.getPublicInstance;
            a = kf(a);
            var d = a.computeAsyncExpiration, e = a.computeExpirationForFiber, f = a.scheduleWork;
            return {
                createContainer: function(a, b) {
                    var c = new Y(3, null, 0);
                    a = {
                        current: c,
                        containerInfo: a,
                        pendingChildren: null,
                        remainingExpirationTime: 0,
                        isReadyForCommit: !1,
                        finishedWork: null,
                        context: null,
                        pendingContext: null,
                        hydrate: b,
                        nextScheduledRoot: null
                    };
                    return c.stateNode = a;
                },
                updateContainer: function(a, b, c, q) {
                    var g = b.current;
                    if (c) {
                        c = c._reactInternalFiber;
                        var h;
                        b: {
                            2 === kd(c) && 2 === c.tag ? void 0 : E("170");
                            for (h = c; 3 !== h.tag; ) {
                                if (le(h)) {
                                    h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                                    break b;
                                }
                                (h = h["return"]) ? void 0 : E("171");
                            }
                            h = h.stateNode.context;
                        }
                        c = le(c) ? pe(c, h) : h;
                    } else c = D;
                    null === b.context ? b.context = c : b.pendingContext = c;
                    b = q;
                    b = void 0 === b ? null : b;
                    q = null != a && null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent ? d() : e(g);
                    He(g, {
                        expirationTime: q,
                        partialState: {
                            element: a
                        },
                        callback: b,
                        isReplace: !1,
                        isForced: !1,
                        nextCallback: null,
                        next: null
                    });
                    f(g, q);
                },
                batchedUpdates: a.batchedUpdates,
                unbatchedUpdates: a.unbatchedUpdates,
                deferredUpdates: a.deferredUpdates,
                flushSync: a.flushSync,
                getPublicRootInstance: function(a) {
                    a = a.current;
                    if (!a.child) return null;
                    switch (a.child.tag) {
                      case 5:
                        return c(a.child.stateNode);

                      default:
                        return a.child.stateNode;
                    }
                },
                findHostInstance: b,
                findHostInstanceWithNoPortals: function(a) {
                    a = pd(a);
                    return null === a ? null : a.stateNode;
                },
                injectIntoDevTools: function(a) {
                    var c = a.findFiberByHostInstance;
                    return Ce(B({}, a, {
                        findHostInstanceByFiber: function(a) {
                            return b(a);
                        },
                        findFiberByHostInstance: function(a) {
                            return c ? c(a) : null;
                        }
                    }));
                }
            };
        }
        var mf = Object.freeze({
            default: lf
        }), nf = mf && lf || mf, of = nf["default"] ? nf["default"] : nf;
        function pf(a, b, c) {
            var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
            return {
                $$typeof: Ue,
                key: null == d ? null : "" + d,
                children: a,
                containerInfo: b,
                implementation: c
            };
        }
        var qf = "object" === typeof performance && "function" === typeof performance.now, rf = void 0;
        rf = qf ? function() {
            return performance.now();
        } : function() {
            return Date.now();
        };
        var sf = void 0, tf = void 0;
        if (l.canUseDOM) if ("function" !== typeof requestIdleCallback || "function" !== typeof cancelIdleCallback) {
            var uf = null, vf = !1, wf = -1, xf = !1, yf = 0, zf = 33, Af = 33, Bf;
            Bf = qf ? {
                didTimeout: !1,
                timeRemaining: function() {
                    var a = yf - performance.now();
                    return 0 < a ? a : 0;
                }
            } : {
                didTimeout: !1,
                timeRemaining: function() {
                    var a = yf - Date.now();
                    return 0 < a ? a : 0;
                }
            };
            var Cf = "__reactIdleCallback$" + Math.random().toString(36).slice(2);
            window.addEventListener("message", function(a) {
                if (a.source === window && a.data === Cf) {
                    vf = !1;
                    a = rf();
                    if (0 >= yf - a) if (-1 !== wf && wf <= a) Bf.didTimeout = !0; else {
                        xf || (xf = !0, requestAnimationFrame(Df));
                        return;
                    } else Bf.didTimeout = !1;
                    wf = -1;
                    a = uf;
                    uf = null;
                    null !== a && a(Bf);
                }
            }, !1);
            var Df = function(a) {
                xf = !1;
                var b = a - yf + Af;
                b < Af && zf < Af ? (8 > b && (b = 8), Af = b < zf ? zf : b) : zf = b;
                yf = a + Af;
                vf || (vf = !0, window.postMessage(Cf, "*"));
            };
            sf = function(a, b) {
                uf = a;
                null != b && "number" === typeof b.timeout && (wf = rf() + b.timeout);
                xf || (xf = !0, requestAnimationFrame(Df));
                return 0;
            };
            tf = function() {
                uf = null;
                vf = !1;
                wf = -1;
            };
        } else sf = window.requestIdleCallback, tf = window.cancelIdleCallback; else sf = function(a) {
            return setTimeout(function() {
                a({
                    timeRemaining: function() {
                        return Infinity;
                    }
                });
            });
        }, tf = function(a) {
            clearTimeout(a);
        };
        var Ef = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Ff = {}, Gf = {};
        function Hf(a) {
            if (Gf.hasOwnProperty(a)) return !0;
            if (Ff.hasOwnProperty(a)) return !1;
            if (Ef.test(a)) return Gf[a] = !0;
            Ff[a] = !0;
            return !1;
        }
        function If(a, b, c) {
            var d = wa(b);
            if (d && va(b, c)) {
                var e = d.mutationMethod;
                e ? e(a, c) : null == c || d.hasBooleanValue && !c || d.hasNumericValue && isNaN(c) || d.hasPositiveNumericValue && 1 > c || d.hasOverloadedBooleanValue && !1 === c ? Jf(a, b) : d.mustUseProperty ? a[d.propertyName] = c : (b = d.attributeName, 
                (e = d.attributeNamespace) ? a.setAttributeNS(e, b, "" + c) : d.hasBooleanValue || d.hasOverloadedBooleanValue && !0 === c ? a.setAttribute(b, "") : a.setAttribute(b, "" + c));
            } else Kf(a, b, va(b, c) ? c : null);
        }
        function Kf(a, b, c) {
            Hf(b) && (null == c ? a.removeAttribute(b) : a.setAttribute(b, "" + c));
        }
        function Jf(a, b) {
            var c = wa(b);
            c ? (b = c.mutationMethod) ? b(a, void 0) : c.mustUseProperty ? a[c.propertyName] = c.hasBooleanValue ? !1 : "" : a.removeAttribute(c.attributeName) : a.removeAttribute(b);
        }
        function Lf(a, b) {
            var c = b.value, d = b.checked;
            return B({
                type: void 0,
                step: void 0,
                min: void 0,
                max: void 0
            }, b, {
                defaultChecked: void 0,
                defaultValue: void 0,
                value: null != c ? c : a._wrapperState.initialValue,
                checked: null != d ? d : a._wrapperState.initialChecked
            });
        }
        function Mf(a, b) {
            var c = b.defaultValue;
            a._wrapperState = {
                initialChecked: null != b.checked ? b.checked : b.defaultChecked,
                initialValue: null != b.value ? b.value : c,
                controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
            };
        }
        function Nf(a, b) {
            b = b.checked;
            null != b && If(a, "checked", b);
        }
        function Of(a, b) {
            Nf(a, b);
            var c = b.value;
            if (null != c) if (0 === c && "" === a.value) a.value = "0"; else if ("number" === b.type) {
                if (b = parseFloat(a.value) || 0, c != b || c == b && a.value != c) a.value = "" + c;
            } else a.value !== "" + c && (a.value = "" + c); else null == b.value && null != b.defaultValue && a.defaultValue !== "" + b.defaultValue && (a.defaultValue = "" + b.defaultValue), 
            null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
        }
        function Pf(a, b) {
            switch (b.type) {
              case "submit":
              case "reset":
                break;

              case "color":
              case "date":
              case "datetime":
              case "datetime-local":
              case "month":
              case "time":
              case "week":
                a.value = "";
                a.value = a.defaultValue;
                break;

              default:
                a.value = a.value;
            }
            b = a.name;
            "" !== b && (a.name = "");
            a.defaultChecked = !a.defaultChecked;
            a.defaultChecked = !a.defaultChecked;
            "" !== b && (a.name = b);
        }
        function Qf(a) {
            var b = "";
            aa.Children.forEach(a, function(a) {
                null == a || "string" !== typeof a && "number" !== typeof a || (b += a);
            });
            return b;
        }
        function Rf(a, b) {
            a = B({
                children: void 0
            }, b);
            if (b = Qf(b.children)) a.children = b;
            return a;
        }
        function Sf(a, b, c, d) {
            a = a.options;
            if (b) {
                b = {};
                for (var e = 0; e < c.length; e++) b["$" + c[e]] = !0;
                for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), 
                e && d && (a[c].defaultSelected = !0);
            } else {
                c = "" + c;
                b = null;
                for (e = 0; e < a.length; e++) {
                    if (a[e].value === c) {
                        a[e].selected = !0;
                        d && (a[e].defaultSelected = !0);
                        return;
                    }
                    null !== b || a[e].disabled || (b = a[e]);
                }
                null !== b && (b.selected = !0);
            }
        }
        function Tf(a, b) {
            var c = b.value;
            a._wrapperState = {
                initialValue: null != c ? c : b.defaultValue,
                wasMultiple: !!b.multiple
            };
        }
        function Uf(a, b) {
            null != b.dangerouslySetInnerHTML ? E("91") : void 0;
            return B({}, b, {
                value: void 0,
                defaultValue: void 0,
                children: "" + a._wrapperState.initialValue
            });
        }
        function Vf(a, b) {
            var c = b.value;
            null == c && (c = b.defaultValue, b = b.children, null != b && (null != c ? E("92") : void 0, 
            Array.isArray(b) && (1 >= b.length ? void 0 : E("93"), b = b[0]), c = "" + b), null == c && (c = ""));
            a._wrapperState = {
                initialValue: "" + c
            };
        }
        function Wf(a, b) {
            var c = b.value;
            null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && (a.defaultValue = c));
            null != b.defaultValue && (a.defaultValue = b.defaultValue);
        }
        function Xf(a) {
            var b = a.textContent;
            b === a._wrapperState.initialValue && (a.value = b);
        }
        var Yf = {
            html: "http://www.w3.org/1999/xhtml",
            mathml: "http://www.w3.org/1998/Math/MathML",
            svg: "http://www.w3.org/2000/svg"
        };
        function Zf(a) {
            switch (a) {
              case "svg":
                return "http://www.w3.org/2000/svg";

              case "math":
                return "http://www.w3.org/1998/Math/MathML";

              default:
                return "http://www.w3.org/1999/xhtml";
            }
        }
        function $f(a, b) {
            return null == a || "http://www.w3.org/1999/xhtml" === a ? Zf(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
        }
        var ag = void 0, bg = function(a) {
            return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
                MSApp.execUnsafeLocalFunction(function() {
                    return a(b, c, d, e);
                });
            } : a;
        }(function(a, b) {
            if (a.namespaceURI !== Yf.svg || "innerHTML" in a) a.innerHTML = b; else {
                ag = ag || document.createElement("div");
                ag.innerHTML = "<svg>" + b + "</svg>";
                for (b = ag.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
                for (;b.firstChild; ) a.appendChild(b.firstChild);
            }
        });
        function cg(a, b) {
            if (b) {
                var c = a.firstChild;
                if (c && c === a.lastChild && 3 === c.nodeType) {
                    c.nodeValue = b;
                    return;
                }
            }
            a.textContent = b;
        }
        var dg = {
            animationIterationCount: !0,
            borderImageOutset: !0,
            borderImageSlice: !0,
            borderImageWidth: !0,
            boxFlex: !0,
            boxFlexGroup: !0,
            boxOrdinalGroup: !0,
            columnCount: !0,
            columns: !0,
            flex: !0,
            flexGrow: !0,
            flexPositive: !0,
            flexShrink: !0,
            flexNegative: !0,
            flexOrder: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowSpan: !0,
            gridRowStart: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnSpan: !0,
            gridColumnStart: !0,
            fontWeight: !0,
            lineClamp: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            tabSize: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeDasharray: !0,
            strokeDashoffset: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0,
            strokeWidth: !0
        }, eg = [ "Webkit", "ms", "Moz", "O" ];
        Object.keys(dg).forEach(function(a) {
            eg.forEach(function(b) {
                b = b + a.charAt(0).toUpperCase() + a.substring(1);
                dg[b] = dg[a];
            });
        });
        function fg(a, b) {
            a = a.style;
            for (var c in b) if (b.hasOwnProperty(c)) {
                var d = 0 === c.indexOf("--");
                var e = c;
                var f = b[c];
                e = null == f || "boolean" === typeof f || "" === f ? "" : d || "number" !== typeof f || 0 === f || dg.hasOwnProperty(e) && dg[e] ? ("" + f).trim() : f + "px";
                "float" === c && (c = "cssFloat");
                d ? a.setProperty(c, e) : a[c] = e;
            }
        }
        var gg = B({
            menuitem: !0
        }, {
            area: !0,
            base: !0,
            br: !0,
            col: !0,
            embed: !0,
            hr: !0,
            img: !0,
            input: !0,
            keygen: !0,
            link: !0,
            meta: !0,
            param: !0,
            source: !0,
            track: !0,
            wbr: !0
        });
        function hg(a, b, c) {
            b && (gg[a] && (null != b.children || null != b.dangerouslySetInnerHTML ? E("137", a, c()) : void 0), 
            null != b.dangerouslySetInnerHTML && (null != b.children ? E("60") : void 0, "object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML ? void 0 : E("61")), 
            null != b.style && "object" !== typeof b.style ? E("62", c()) : void 0);
        }
        function ig(a, b) {
            if (-1 === a.indexOf("-")) return "string" === typeof b.is;
            switch (a) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return !1;

              default:
                return !0;
            }
        }
        var jg = Yf.html, kg = C.thatReturns("");
        function lg(a, b) {
            a = 9 === a.nodeType || 11 === a.nodeType ? a : a.ownerDocument;
            var c = Hd(a);
            b = Sa[b];
            for (var d = 0; d < b.length; d++) {
                var e = b[d];
                c.hasOwnProperty(e) && c[e] || ("topScroll" === e ? wd("topScroll", "scroll", a) : "topFocus" === e || "topBlur" === e ? (wd("topFocus", "focus", a), 
                wd("topBlur", "blur", a), c.topBlur = !0, c.topFocus = !0) : "topCancel" === e ? (yc("cancel", !0) && wd("topCancel", "cancel", a), 
                c.topCancel = !0) : "topClose" === e ? (yc("close", !0) && wd("topClose", "close", a), 
                c.topClose = !0) : Dd.hasOwnProperty(e) && U(e, Dd[e], a), c[e] = !0);
            }
        }
        var mg = {
            topAbort: "abort",
            topCanPlay: "canplay",
            topCanPlayThrough: "canplaythrough",
            topDurationChange: "durationchange",
            topEmptied: "emptied",
            topEncrypted: "encrypted",
            topEnded: "ended",
            topError: "error",
            topLoadedData: "loadeddata",
            topLoadedMetadata: "loadedmetadata",
            topLoadStart: "loadstart",
            topPause: "pause",
            topPlay: "play",
            topPlaying: "playing",
            topProgress: "progress",
            topRateChange: "ratechange",
            topSeeked: "seeked",
            topSeeking: "seeking",
            topStalled: "stalled",
            topSuspend: "suspend",
            topTimeUpdate: "timeupdate",
            topVolumeChange: "volumechange",
            topWaiting: "waiting"
        };
        function ng(a, b, c, d) {
            c = 9 === c.nodeType ? c : c.ownerDocument;
            d === jg && (d = Zf(a));
            d === jg ? "script" === a ? (a = c.createElement("div"), a.innerHTML = "<script><\/script>", 
            a = a.removeChild(a.firstChild)) : a = "string" === typeof b.is ? c.createElement(a, {
                is: b.is
            }) : c.createElement(a) : a = c.createElementNS(d, a);
            return a;
        }
        function og(a, b) {
            return (9 === b.nodeType ? b : b.ownerDocument).createTextNode(a);
        }
        function pg(a, b, c, d) {
            var e = ig(b, c);
            switch (b) {
              case "iframe":
              case "object":
                U("topLoad", "load", a);
                var f = c;
                break;

              case "video":
              case "audio":
                for (f in mg) mg.hasOwnProperty(f) && U(f, mg[f], a);
                f = c;
                break;

              case "source":
                U("topError", "error", a);
                f = c;
                break;

              case "img":
              case "image":
                U("topError", "error", a);
                U("topLoad", "load", a);
                f = c;
                break;

              case "form":
                U("topReset", "reset", a);
                U("topSubmit", "submit", a);
                f = c;
                break;

              case "details":
                U("topToggle", "toggle", a);
                f = c;
                break;

              case "input":
                Mf(a, c);
                f = Lf(a, c);
                U("topInvalid", "invalid", a);
                lg(d, "onChange");
                break;

              case "option":
                f = Rf(a, c);
                break;

              case "select":
                Tf(a, c);
                f = B({}, c, {
                    value: void 0
                });
                U("topInvalid", "invalid", a);
                lg(d, "onChange");
                break;

              case "textarea":
                Vf(a, c);
                f = Uf(a, c);
                U("topInvalid", "invalid", a);
                lg(d, "onChange");
                break;

              default:
                f = c;
            }
            hg(b, f, kg);
            var g = f, h;
            for (h in g) if (g.hasOwnProperty(h)) {
                var k = g[h];
                "style" === h ? fg(a, k, kg) : "dangerouslySetInnerHTML" === h ? (k = k ? k.__html : void 0, 
                null != k && bg(a, k)) : "children" === h ? "string" === typeof k ? ("textarea" !== b || "" !== k) && cg(a, k) : "number" === typeof k && cg(a, "" + k) : "suppressContentEditableWarning" !== h && "suppressHydrationWarning" !== h && "autoFocus" !== h && (Ra.hasOwnProperty(h) ? null != k && lg(d, h) : e ? Kf(a, h, k) : null != k && If(a, h, k));
            }
            switch (b) {
              case "input":
                Bc(a);
                Pf(a, c);
                break;

              case "textarea":
                Bc(a);
                Xf(a, c);
                break;

              case "option":
                null != c.value && a.setAttribute("value", c.value);
                break;

              case "select":
                a.multiple = !!c.multiple;
                b = c.value;
                null != b ? Sf(a, !!c.multiple, b, !1) : null != c.defaultValue && Sf(a, !!c.multiple, c.defaultValue, !0);
                break;

              default:
                "function" === typeof f.onClick && (a.onclick = C);
            }
        }
        function sg(a, b, c, d, e) {
            var f = null;
            switch (b) {
              case "input":
                c = Lf(a, c);
                d = Lf(a, d);
                f = [];
                break;

              case "option":
                c = Rf(a, c);
                d = Rf(a, d);
                f = [];
                break;

              case "select":
                c = B({}, c, {
                    value: void 0
                });
                d = B({}, d, {
                    value: void 0
                });
                f = [];
                break;

              case "textarea":
                c = Uf(a, c);
                d = Uf(a, d);
                f = [];
                break;

              default:
                "function" !== typeof c.onClick && "function" === typeof d.onClick && (a.onclick = C);
            }
            hg(b, d, kg);
            var g, h;
            a = null;
            for (g in c) if (!d.hasOwnProperty(g) && c.hasOwnProperty(g) && null != c[g]) if ("style" === g) for (h in b = c[g], 
            b) b.hasOwnProperty(h) && (a || (a = {}), a[h] = ""); else "dangerouslySetInnerHTML" !== g && "children" !== g && "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && "autoFocus" !== g && (Ra.hasOwnProperty(g) ? f || (f = []) : (f = f || []).push(g, null));
            for (g in d) {
                var k = d[g];
                b = null != c ? c[g] : void 0;
                if (d.hasOwnProperty(g) && k !== b && (null != k || null != b)) if ("style" === g) if (b) {
                    for (h in b) !b.hasOwnProperty(h) || k && k.hasOwnProperty(h) || (a || (a = {}), 
                    a[h] = "");
                    for (h in k) k.hasOwnProperty(h) && b[h] !== k[h] && (a || (a = {}), a[h] = k[h]);
                } else a || (f || (f = []), f.push(g, a)), a = k; else "dangerouslySetInnerHTML" === g ? (k = k ? k.__html : void 0, 
                b = b ? b.__html : void 0, null != k && b !== k && (f = f || []).push(g, "" + k)) : "children" === g ? b === k || "string" !== typeof k && "number" !== typeof k || (f = f || []).push(g, "" + k) : "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && (Ra.hasOwnProperty(g) ? (null != k && lg(e, g), 
                f || b === k || (f = [])) : (f = f || []).push(g, k));
            }
            a && (f = f || []).push("style", a);
            return f;
        }
        function tg(a, b, c, d, e) {
            "input" === c && "radio" === e.type && null != e.name && Nf(a, e);
            ig(c, d);
            d = ig(c, e);
            for (var f = 0; f < b.length; f += 2) {
                var g = b[f], h = b[f + 1];
                "style" === g ? fg(a, h, kg) : "dangerouslySetInnerHTML" === g ? bg(a, h) : "children" === g ? cg(a, h) : d ? null != h ? Kf(a, g, h) : a.removeAttribute(g) : null != h ? If(a, g, h) : Jf(a, g);
            }
            switch (c) {
              case "input":
                Of(a, e);
                break;

              case "textarea":
                Wf(a, e);
                break;

              case "select":
                a._wrapperState.initialValue = void 0, b = a._wrapperState.wasMultiple, a._wrapperState.wasMultiple = !!e.multiple, 
                c = e.value, null != c ? Sf(a, !!e.multiple, c, !1) : b !== !!e.multiple && (null != e.defaultValue ? Sf(a, !!e.multiple, e.defaultValue, !0) : Sf(a, !!e.multiple, e.multiple ? [] : "", !1));
            }
        }
        function ug(a, b, c, d, e) {
            switch (b) {
              case "iframe":
              case "object":
                U("topLoad", "load", a);
                break;

              case "video":
              case "audio":
                for (var f in mg) mg.hasOwnProperty(f) && U(f, mg[f], a);
                break;

              case "source":
                U("topError", "error", a);
                break;

              case "img":
              case "image":
                U("topError", "error", a);
                U("topLoad", "load", a);
                break;

              case "form":
                U("topReset", "reset", a);
                U("topSubmit", "submit", a);
                break;

              case "details":
                U("topToggle", "toggle", a);
                break;

              case "input":
                Mf(a, c);
                U("topInvalid", "invalid", a);
                lg(e, "onChange");
                break;

              case "select":
                Tf(a, c);
                U("topInvalid", "invalid", a);
                lg(e, "onChange");
                break;

              case "textarea":
                Vf(a, c), U("topInvalid", "invalid", a), lg(e, "onChange");
            }
            hg(b, c, kg);
            d = null;
            for (var g in c) c.hasOwnProperty(g) && (f = c[g], "children" === g ? "string" === typeof f ? a.textContent !== f && (d = [ "children", f ]) : "number" === typeof f && a.textContent !== "" + f && (d = [ "children", "" + f ]) : Ra.hasOwnProperty(g) && null != f && lg(e, g));
            switch (b) {
              case "input":
                Bc(a);
                Pf(a, c);
                break;

              case "textarea":
                Bc(a);
                Xf(a, c);
                break;

              case "select":
              case "option":
                break;

              default:
                "function" === typeof c.onClick && (a.onclick = C);
            }
            return d;
        }
        function vg(a, b) {
            return a.nodeValue !== b;
        }
        var wg = Object.freeze({
            createElement: ng,
            createTextNode: og,
            setInitialProperties: pg,
            diffProperties: sg,
            updateProperties: tg,
            diffHydratedProperties: ug,
            diffHydratedText: vg,
            warnForUnmatchedText: function() {},
            warnForDeletedHydratableElement: function() {},
            warnForDeletedHydratableText: function() {},
            warnForInsertedHydratedElement: function() {},
            warnForInsertedHydratedText: function() {},
            restoreControlledState: function(a, b, c) {
                switch (b) {
                  case "input":
                    Of(a, c);
                    b = c.name;
                    if ("radio" === c.type && null != b) {
                        for (c = a; c.parentNode; ) c = c.parentNode;
                        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
                        for (b = 0; b < c.length; b++) {
                            var d = c[b];
                            if (d !== a && d.form === a.form) {
                                var e = rb(d);
                                e ? void 0 : E("90");
                                Cc(d);
                                Of(d, e);
                            }
                        }
                    }
                    break;

                  case "textarea":
                    Wf(a, c);
                    break;

                  case "select":
                    b = c.value, null != b && Sf(a, !!c.multiple, b, !1);
                }
            }
        });
        nc.injectFiberControlledHostComponent(wg);
        var xg = null, Mg = null;
        function Ng(a) {
            return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
        }
        function Og(a) {
            a = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null;
            return !(!a || 1 !== a.nodeType || !a.hasAttribute("data-reactroot"));
        }
        var Z = of({
            getRootHostContext: function(a) {
                var b = a.nodeType;
                switch (b) {
                  case 9:
                  case 11:
                    a = (a = a.documentElement) ? a.namespaceURI : $f(null, "");
                    break;

                  default:
                    b = 8 === b ? a.parentNode : a, a = b.namespaceURI || null, b = b.tagName, a = $f(a, b);
                }
                return a;
            },
            getChildHostContext: function(a, b) {
                return $f(a, b);
            },
            getPublicInstance: function(a) {
                return a;
            },
            prepareForCommit: function() {
                xg = td;
                var a = da();
                if (Kd(a)) {
                    if ("selectionStart" in a) var b = {
                        start: a.selectionStart,
                        end: a.selectionEnd
                    }; else a: {
                        var c = window.getSelection && window.getSelection();
                        if (c && 0 !== c.rangeCount) {
                            b = c.anchorNode;
                            var d = c.anchorOffset, e = c.focusNode;
                            c = c.focusOffset;
                            try {
                                b.nodeType, e.nodeType;
                            } catch (z) {
                                b = null;
                                break a;
                            }
                            var f = 0, g = -1, h = -1, k = 0, q = 0, v = a, y = null;
                            b: for (;;) {
                                for (var u; ;) {
                                    v !== b || 0 !== d && 3 !== v.nodeType || (g = f + d);
                                    v !== e || 0 !== c && 3 !== v.nodeType || (h = f + c);
                                    3 === v.nodeType && (f += v.nodeValue.length);
                                    if (null === (u = v.firstChild)) break;
                                    y = v;
                                    v = u;
                                }
                                for (;;) {
                                    if (v === a) break b;
                                    y === b && ++k === d && (g = f);
                                    y === e && ++q === c && (h = f);
                                    if (null !== (u = v.nextSibling)) break;
                                    v = y;
                                    y = v.parentNode;
                                }
                                v = u;
                            }
                            b = -1 === g || -1 === h ? null : {
                                start: g,
                                end: h
                            };
                        } else b = null;
                    }
                    b = b || {
                        start: 0,
                        end: 0
                    };
                } else b = null;
                Mg = {
                    focusedElem: a,
                    selectionRange: b
                };
                ud(!1);
            },
            resetAfterCommit: function() {
                var a = Mg, b = da(), c = a.focusedElem, d = a.selectionRange;
                if (b !== c && fa(document.documentElement, c)) {
                    if (Kd(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, 
                    c.selectionEnd = Math.min(a, c.value.length); else if (window.getSelection) {
                        b = window.getSelection();
                        var e = c[Eb()].length;
                        a = Math.min(d.start, e);
                        d = void 0 === d.end ? a : Math.min(d.end, e);
                        !b.extend && a > d && (e = d, d = a, a = e);
                        e = Jd(c, a);
                        var f = Jd(c, d);
                        if (e && f && (1 !== b.rangeCount || b.anchorNode !== e.node || b.anchorOffset !== e.offset || b.focusNode !== f.node || b.focusOffset !== f.offset)) {
                            var g = document.createRange();
                            g.setStart(e.node, e.offset);
                            b.removeAllRanges();
                            a > d ? (b.addRange(g), b.extend(f.node, f.offset)) : (g.setEnd(f.node, f.offset), 
                            b.addRange(g));
                        }
                    }
                    b = [];
                    for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({
                        element: a,
                        left: a.scrollLeft,
                        top: a.scrollTop
                    });
                    ia(c);
                    for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
                }
                Mg = null;
                ud(xg);
                xg = null;
            },
            createInstance: function(a, b, c, d, e) {
                a = ng(a, b, c, d);
                a[Q] = e;
                a[ob] = b;
                return a;
            },
            appendInitialChild: function(a, b) {
                a.appendChild(b);
            },
            finalizeInitialChildren: function(a, b, c, d) {
                pg(a, b, c, d);
                a: {
                    switch (b) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        a = !!c.autoFocus;
                        break a;
                    }
                    a = !1;
                }
                return a;
            },
            prepareUpdate: function(a, b, c, d, e) {
                return sg(a, b, c, d, e);
            },
            shouldSetTextContent: function(a, b) {
                return "textarea" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && "string" === typeof b.dangerouslySetInnerHTML.__html;
            },
            shouldDeprioritizeSubtree: function(a, b) {
                return !!b.hidden;
            },
            createTextInstance: function(a, b, c, d) {
                a = og(a, b);
                a[Q] = d;
                return a;
            },
            now: rf,
            mutation: {
                commitMount: function(a) {
                    a.focus();
                },
                commitUpdate: function(a, b, c, d, e) {
                    a[ob] = e;
                    tg(a, b, c, d, e);
                },
                resetTextContent: function(a) {
                    a.textContent = "";
                },
                commitTextUpdate: function(a, b, c) {
                    a.nodeValue = c;
                },
                appendChild: function(a, b) {
                    a.appendChild(b);
                },
                appendChildToContainer: function(a, b) {
                    8 === a.nodeType ? a.parentNode.insertBefore(b, a) : a.appendChild(b);
                },
                insertBefore: function(a, b, c) {
                    a.insertBefore(b, c);
                },
                insertInContainerBefore: function(a, b, c) {
                    8 === a.nodeType ? a.parentNode.insertBefore(b, c) : a.insertBefore(b, c);
                },
                removeChild: function(a, b) {
                    a.removeChild(b);
                },
                removeChildFromContainer: function(a, b) {
                    8 === a.nodeType ? a.parentNode.removeChild(b) : a.removeChild(b);
                }
            },
            hydration: {
                canHydrateInstance: function(a, b) {
                    return 1 !== a.nodeType || b.toLowerCase() !== a.nodeName.toLowerCase() ? null : a;
                },
                canHydrateTextInstance: function(a, b) {
                    return "" === b || 3 !== a.nodeType ? null : a;
                },
                getNextHydratableSibling: function(a) {
                    for (a = a.nextSibling; a && 1 !== a.nodeType && 3 !== a.nodeType; ) a = a.nextSibling;
                    return a;
                },
                getFirstHydratableChild: function(a) {
                    for (a = a.firstChild; a && 1 !== a.nodeType && 3 !== a.nodeType; ) a = a.nextSibling;
                    return a;
                },
                hydrateInstance: function(a, b, c, d, e, f) {
                    a[Q] = f;
                    a[ob] = c;
                    return ug(a, b, c, e, d);
                },
                hydrateTextInstance: function(a, b, c) {
                    a[Q] = c;
                    return vg(a, b);
                },
                didNotMatchHydratedContainerTextInstance: function() {},
                didNotMatchHydratedTextInstance: function() {},
                didNotHydrateContainerInstance: function() {},
                didNotHydrateInstance: function() {},
                didNotFindHydratableContainerInstance: function() {},
                didNotFindHydratableContainerTextInstance: function() {},
                didNotFindHydratableInstance: function() {},
                didNotFindHydratableTextInstance: function() {}
            },
            scheduleDeferredCallback: sf,
            cancelDeferredCallback: tf,
            useSyncScheduling: !0
        });
        rc = Z.batchedUpdates;
        function Pg(a, b, c, d, e) {
            Ng(c) ? void 0 : E("200");
            var f = c._reactRootContainer;
            if (f) Z.updateContainer(b, f, a, e); else {
                d = d || Og(c);
                if (!d) for (f = void 0; f = c.lastChild; ) c.removeChild(f);
                var g = Z.createContainer(c, d);
                f = c._reactRootContainer = g;
                Z.unbatchedUpdates(function() {
                    Z.updateContainer(b, g, a, e);
                });
            }
            return Z.getPublicRootInstance(f);
        }
        function Qg(a, b) {
            var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
            Ng(b) ? void 0 : E("200");
            return pf(a, b, null, c);
        }
        function Rg(a, b) {
            this._reactRootContainer = Z.createContainer(a, b);
        }
        Rg.prototype.render = function(a, b) {
            Z.updateContainer(a, this._reactRootContainer, null, b);
        };
        Rg.prototype.unmount = function(a) {
            Z.updateContainer(null, this._reactRootContainer, null, a);
        };
        var Sg = {
            createPortal: Qg,
            findDOMNode: function(a) {
                if (null == a) return null;
                if (1 === a.nodeType) return a;
                var b = a._reactInternalFiber;
                if (b) return Z.findHostInstance(b);
                "function" === typeof a.render ? E("188") : E("213", Object.keys(a));
            },
            hydrate: function(a, b, c) {
                return Pg(null, a, b, !0, c);
            },
            render: function(a, b, c) {
                return Pg(null, a, b, !1, c);
            },
            unstable_renderSubtreeIntoContainer: function(a, b, c, d) {
                null == a || void 0 === a._reactInternalFiber ? E("38") : void 0;
                return Pg(a, b, c, !1, d);
            },
            unmountComponentAtNode: function(a) {
                Ng(a) ? void 0 : E("40");
                return a._reactRootContainer ? (Z.unbatchedUpdates(function() {
                    Pg(null, null, a, !1, function() {
                        a._reactRootContainer = null;
                    });
                }), !0) : !1;
            },
            unstable_createPortal: Qg,
            unstable_batchedUpdates: tc,
            unstable_deferredUpdates: Z.deferredUpdates,
            flushSync: Z.flushSync,
            __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                EventPluginHub: mb,
                EventPluginRegistry: Va,
                EventPropagators: Cb,
                ReactControlledComponent: qc,
                ReactDOMComponentTree: sb,
                ReactDOMEventListener: xd
            }
        };
        Z.injectIntoDevTools({
            findFiberByHostInstance: pb,
            bundleType: 0,
            version: "16.2.0",
            rendererPackageName: "react-dom"
        });
        var Tg = Object.freeze({
            default: Sg
        }), Ug = Tg && Sg || Tg;
        module.exports = Ug["default"] ? Ug["default"] : Ug;
    }, {
        "fbjs/lib/EventListener": 1,
        "fbjs/lib/ExecutionEnvironment": 2,
        "fbjs/lib/containsNode": 5,
        "fbjs/lib/emptyFunction": 6,
        "fbjs/lib/emptyObject": 7,
        "fbjs/lib/focusNode": 8,
        "fbjs/lib/getActiveElement": 9,
        "fbjs/lib/shallowEqual": 15,
        "object-assign": 18,
        react: "react"
    } ],
    24: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            if (process.env.NODE_ENV !== "production") {
                (function() {
                    "use strict";
                    var _assign = require("object-assign");
                    var emptyObject = require("fbjs/lib/emptyObject");
                    var invariant = require("fbjs/lib/invariant");
                    var warning = require("fbjs/lib/warning");
                    var emptyFunction = require("fbjs/lib/emptyFunction");
                    var checkPropTypes = require("prop-types/checkPropTypes");
                    var ReactVersion = "16.2.0";
                    var hasSymbol = typeof Symbol === "function" && Symbol["for"];
                    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol["for"]("react.element") : 60103;
                    var REACT_CALL_TYPE = hasSymbol ? Symbol["for"]("react.call") : 60104;
                    var REACT_RETURN_TYPE = hasSymbol ? Symbol["for"]("react.return") : 60105;
                    var REACT_PORTAL_TYPE = hasSymbol ? Symbol["for"]("react.portal") : 60106;
                    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol["for"]("react.fragment") : 60107;
                    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
                    var FAUX_ITERATOR_SYMBOL = "@@iterator";
                    function getIteratorFn(maybeIterable) {
                        if (maybeIterable === null || typeof maybeIterable === "undefined") {
                            return null;
                        }
                        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
                        if (typeof maybeIterator === "function") {
                            return maybeIterator;
                        }
                        return null;
                    }
                    var lowPriorityWarning = function() {};
                    {
                        var printWarning = function(format) {
                            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                args[_key - 1] = arguments[_key];
                            }
                            var argIndex = 0;
                            var message = "Warning: " + format.replace(/%s/g, function() {
                                return args[argIndex++];
                            });
                            if (typeof console !== "undefined") {
                                console.warn(message);
                            }
                            try {
                                throw new Error(message);
                            } catch (x) {}
                        };
                        lowPriorityWarning = function(condition, format) {
                            if (format === undefined) {
                                throw new Error("`warning(condition, format, ...args)` requires a warning " + "message argument");
                            }
                            if (!condition) {
                                for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                                    args[_key2 - 2] = arguments[_key2];
                                }
                                printWarning.apply(undefined, [ format ].concat(args));
                            }
                        };
                    }
                    var lowPriorityWarning$1 = lowPriorityWarning;
                    var didWarnStateUpdateForUnmountedComponent = {};
                    function warnNoop(publicInstance, callerName) {
                        {
                            var constructor = publicInstance.constructor;
                            var componentName = constructor && (constructor.displayName || constructor.name) || "ReactClass";
                            var warningKey = componentName + "." + callerName;
                            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                                return;
                            }
                            warning(false, "%s(...): Can only update a mounted or mounting component. " + "This usually means you called %s() on an unmounted component. " + "This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
                            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
                        }
                    }
                    var ReactNoopUpdateQueue = {
                        isMounted: function(publicInstance) {
                            return false;
                        },
                        enqueueForceUpdate: function(publicInstance, callback, callerName) {
                            warnNoop(publicInstance, "forceUpdate");
                        },
                        enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
                            warnNoop(publicInstance, "replaceState");
                        },
                        enqueueSetState: function(publicInstance, partialState, callback, callerName) {
                            warnNoop(publicInstance, "setState");
                        }
                    };
                    function Component(props, context, updater) {
                        this.props = props;
                        this.context = context;
                        this.refs = emptyObject;
                        this.updater = updater || ReactNoopUpdateQueue;
                    }
                    Component.prototype.isReactComponent = {};
                    Component.prototype.setState = function(partialState, callback) {
                        !(typeof partialState === "object" || typeof partialState === "function" || partialState == null) ? invariant(false, "setState(...): takes an object of state variables to update or a function which returns an object of state variables.") : void 0;
                        this.updater.enqueueSetState(this, partialState, callback, "setState");
                    };
                    Component.prototype.forceUpdate = function(callback) {
                        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
                    };
                    {
                        var deprecatedAPIs = {
                            isMounted: [ "isMounted", "Instead, make sure to clean up subscriptions and pending requests in " + "componentWillUnmount to prevent memory leaks." ],
                            replaceState: [ "replaceState", "Refactor your code to use setState instead (see " + "https://github.com/facebook/react/issues/3236)." ]
                        };
                        var defineDeprecationWarning = function(methodName, info) {
                            Object.defineProperty(Component.prototype, methodName, {
                                get: function() {
                                    lowPriorityWarning$1(false, "%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                                    return undefined;
                                }
                            });
                        };
                        for (var fnName in deprecatedAPIs) {
                            if (deprecatedAPIs.hasOwnProperty(fnName)) {
                                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                            }
                        }
                    }
                    function PureComponent(props, context, updater) {
                        this.props = props;
                        this.context = context;
                        this.refs = emptyObject;
                        this.updater = updater || ReactNoopUpdateQueue;
                    }
                    function ComponentDummy() {}
                    ComponentDummy.prototype = Component.prototype;
                    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
                    pureComponentPrototype.constructor = PureComponent;
                    _assign(pureComponentPrototype, Component.prototype);
                    pureComponentPrototype.isPureReactComponent = true;
                    function AsyncComponent(props, context, updater) {
                        this.props = props;
                        this.context = context;
                        this.refs = emptyObject;
                        this.updater = updater || ReactNoopUpdateQueue;
                    }
                    var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
                    asyncComponentPrototype.constructor = AsyncComponent;
                    _assign(asyncComponentPrototype, Component.prototype);
                    asyncComponentPrototype.unstable_isAsyncReactComponent = true;
                    asyncComponentPrototype.render = function() {
                        return this.props.children;
                    };
                    var ReactCurrentOwner = {
                        current: null
                    };
                    var hasOwnProperty = Object.prototype.hasOwnProperty;
                    var RESERVED_PROPS = {
                        key: true,
                        ref: true,
                        __self: true,
                        __source: true
                    };
                    var specialPropKeyWarningShown;
                    var specialPropRefWarningShown;
                    function hasValidRef(config) {
                        {
                            if (hasOwnProperty.call(config, "ref")) {
                                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                                if (getter && getter.isReactWarning) {
                                    return false;
                                }
                            }
                        }
                        return config.ref !== undefined;
                    }
                    function hasValidKey(config) {
                        {
                            if (hasOwnProperty.call(config, "key")) {
                                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                                if (getter && getter.isReactWarning) {
                                    return false;
                                }
                            }
                        }
                        return config.key !== undefined;
                    }
                    function defineKeyPropWarningGetter(props, displayName) {
                        var warnAboutAccessingKey = function() {
                            if (!specialPropKeyWarningShown) {
                                specialPropKeyWarningShown = true;
                                warning(false, "%s: `key` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://fb.me/react-special-props)", displayName);
                            }
                        };
                        warnAboutAccessingKey.isReactWarning = true;
                        Object.defineProperty(props, "key", {
                            get: warnAboutAccessingKey,
                            configurable: true
                        });
                    }
                    function defineRefPropWarningGetter(props, displayName) {
                        var warnAboutAccessingRef = function() {
                            if (!specialPropRefWarningShown) {
                                specialPropRefWarningShown = true;
                                warning(false, "%s: `ref` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://fb.me/react-special-props)", displayName);
                            }
                        };
                        warnAboutAccessingRef.isReactWarning = true;
                        Object.defineProperty(props, "ref", {
                            get: warnAboutAccessingRef,
                            configurable: true
                        });
                    }
                    var ReactElement = function(type, key, ref, self, source, owner, props) {
                        var element = {
                            $$typeof: REACT_ELEMENT_TYPE,
                            type: type,
                            key: key,
                            ref: ref,
                            props: props,
                            _owner: owner
                        };
                        {
                            element._store = {};
                            Object.defineProperty(element._store, "validated", {
                                configurable: false,
                                enumerable: false,
                                writable: true,
                                value: false
                            });
                            Object.defineProperty(element, "_self", {
                                configurable: false,
                                enumerable: false,
                                writable: false,
                                value: self
                            });
                            Object.defineProperty(element, "_source", {
                                configurable: false,
                                enumerable: false,
                                writable: false,
                                value: source
                            });
                            if (Object.freeze) {
                                Object.freeze(element.props);
                                Object.freeze(element);
                            }
                        }
                        return element;
                    };
                    function createElement(type, config, children) {
                        var propName;
                        var props = {};
                        var key = null;
                        var ref = null;
                        var self = null;
                        var source = null;
                        if (config != null) {
                            if (hasValidRef(config)) {
                                ref = config.ref;
                            }
                            if (hasValidKey(config)) {
                                key = "" + config.key;
                            }
                            self = config.__self === undefined ? null : config.__self;
                            source = config.__source === undefined ? null : config.__source;
                            for (propName in config) {
                                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                                    props[propName] = config[propName];
                                }
                            }
                        }
                        var childrenLength = arguments.length - 2;
                        if (childrenLength === 1) {
                            props.children = children;
                        } else if (childrenLength > 1) {
                            var childArray = Array(childrenLength);
                            for (var i = 0; i < childrenLength; i++) {
                                childArray[i] = arguments[i + 2];
                            }
                            {
                                if (Object.freeze) {
                                    Object.freeze(childArray);
                                }
                            }
                            props.children = childArray;
                        }
                        if (type && type.defaultProps) {
                            var defaultProps = type.defaultProps;
                            for (propName in defaultProps) {
                                if (props[propName] === undefined) {
                                    props[propName] = defaultProps[propName];
                                }
                            }
                        }
                        {
                            if (key || ref) {
                                if (typeof props.$$typeof === "undefined" || props.$$typeof !== REACT_ELEMENT_TYPE) {
                                    var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                                    if (key) {
                                        defineKeyPropWarningGetter(props, displayName);
                                    }
                                    if (ref) {
                                        defineRefPropWarningGetter(props, displayName);
                                    }
                                }
                            }
                        }
                        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
                    }
                    function cloneAndReplaceKey(oldElement, newKey) {
                        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
                        return newElement;
                    }
                    function cloneElement(element, config, children) {
                        var propName;
                        var props = _assign({}, element.props);
                        var key = element.key;
                        var ref = element.ref;
                        var self = element._self;
                        var source = element._source;
                        var owner = element._owner;
                        if (config != null) {
                            if (hasValidRef(config)) {
                                ref = config.ref;
                                owner = ReactCurrentOwner.current;
                            }
                            if (hasValidKey(config)) {
                                key = "" + config.key;
                            }
                            var defaultProps;
                            if (element.type && element.type.defaultProps) {
                                defaultProps = element.type.defaultProps;
                            }
                            for (propName in config) {
                                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                                    if (config[propName] === undefined && defaultProps !== undefined) {
                                        props[propName] = defaultProps[propName];
                                    } else {
                                        props[propName] = config[propName];
                                    }
                                }
                            }
                        }
                        var childrenLength = arguments.length - 2;
                        if (childrenLength === 1) {
                            props.children = children;
                        } else if (childrenLength > 1) {
                            var childArray = Array(childrenLength);
                            for (var i = 0; i < childrenLength; i++) {
                                childArray[i] = arguments[i + 2];
                            }
                            props.children = childArray;
                        }
                        return ReactElement(element.type, key, ref, self, source, owner, props);
                    }
                    function isValidElement(object) {
                        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
                    }
                    var ReactDebugCurrentFrame = {};
                    {
                        ReactDebugCurrentFrame.getCurrentStack = null;
                        ReactDebugCurrentFrame.getStackAddendum = function() {
                            var impl = ReactDebugCurrentFrame.getCurrentStack;
                            if (impl) {
                                return impl();
                            }
                            return null;
                        };
                    }
                    var SEPARATOR = ".";
                    var SUBSEPARATOR = ":";
                    function escape(key) {
                        var escapeRegex = /[=:]/g;
                        var escaperLookup = {
                            "=": "=0",
                            ":": "=2"
                        };
                        var escapedString = ("" + key).replace(escapeRegex, function(match) {
                            return escaperLookup[match];
                        });
                        return "$" + escapedString;
                    }
                    var didWarnAboutMaps = false;
                    var userProvidedKeyEscapeRegex = /\/+/g;
                    function escapeUserProvidedKey(text) {
                        return ("" + text).replace(userProvidedKeyEscapeRegex, "$&/");
                    }
                    var POOL_SIZE = 10;
                    var traverseContextPool = [];
                    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
                        if (traverseContextPool.length) {
                            var traverseContext = traverseContextPool.pop();
                            traverseContext.result = mapResult;
                            traverseContext.keyPrefix = keyPrefix;
                            traverseContext.func = mapFunction;
                            traverseContext.context = mapContext;
                            traverseContext.count = 0;
                            return traverseContext;
                        } else {
                            return {
                                result: mapResult,
                                keyPrefix: keyPrefix,
                                func: mapFunction,
                                context: mapContext,
                                count: 0
                            };
                        }
                    }
                    function releaseTraverseContext(traverseContext) {
                        traverseContext.result = null;
                        traverseContext.keyPrefix = null;
                        traverseContext.func = null;
                        traverseContext.context = null;
                        traverseContext.count = 0;
                        if (traverseContextPool.length < POOL_SIZE) {
                            traverseContextPool.push(traverseContext);
                        }
                    }
                    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
                        var type = typeof children;
                        if (type === "undefined" || type === "boolean") {
                            children = null;
                        }
                        var invokeCallback = false;
                        if (children === null) {
                            invokeCallback = true;
                        } else {
                            switch (type) {
                              case "string":
                              case "number":
                                invokeCallback = true;
                                break;

                              case "object":
                                switch (children.$$typeof) {
                                  case REACT_ELEMENT_TYPE:
                                  case REACT_CALL_TYPE:
                                  case REACT_RETURN_TYPE:
                                  case REACT_PORTAL_TYPE:
                                    invokeCallback = true;
                                }
                            }
                        }
                        if (invokeCallback) {
                            callback(traverseContext, children, nameSoFar === "" ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
                            return 1;
                        }
                        var child;
                        var nextName;
                        var subtreeCount = 0;
                        var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
                        if (Array.isArray(children)) {
                            for (var i = 0; i < children.length; i++) {
                                child = children[i];
                                nextName = nextNamePrefix + getComponentKey(child, i);
                                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                            }
                        } else {
                            var iteratorFn = getIteratorFn(children);
                            if (typeof iteratorFn === "function") {
                                {
                                    if (iteratorFn === children.entries) {
                                        warning(didWarnAboutMaps, "Using Maps as children is unsupported and will likely yield " + "unexpected results. Convert it to a sequence/iterable of keyed " + "ReactElements instead.%s", ReactDebugCurrentFrame.getStackAddendum());
                                        didWarnAboutMaps = true;
                                    }
                                }
                                var iterator = iteratorFn.call(children);
                                var step;
                                var ii = 0;
                                while (!(step = iterator.next()).done) {
                                    child = step.value;
                                    nextName = nextNamePrefix + getComponentKey(child, ii++);
                                    subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                                }
                            } else if (type === "object") {
                                var addendum = "";
                                {
                                    addendum = " If you meant to render a collection of children, use an array " + "instead." + ReactDebugCurrentFrame.getStackAddendum();
                                }
                                var childrenString = "" + children;
                                invariant(false, "Objects are not valid as a React child (found: %s).%s", childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString, addendum);
                            }
                        }
                        return subtreeCount;
                    }
                    function traverseAllChildren(children, callback, traverseContext) {
                        if (children == null) {
                            return 0;
                        }
                        return traverseAllChildrenImpl(children, "", callback, traverseContext);
                    }
                    function getComponentKey(component, index) {
                        if (typeof component === "object" && component !== null && component.key != null) {
                            return escape(component.key);
                        }
                        return index.toString(36);
                    }
                    function forEachSingleChild(bookKeeping, child, name) {
                        var func = bookKeeping.func, context = bookKeeping.context;
                        func.call(context, child, bookKeeping.count++);
                    }
                    function forEachChildren(children, forEachFunc, forEachContext) {
                        if (children == null) {
                            return children;
                        }
                        var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
                        traverseAllChildren(children, forEachSingleChild, traverseContext);
                        releaseTraverseContext(traverseContext);
                    }
                    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
                        var result = bookKeeping.result, keyPrefix = bookKeeping.keyPrefix, func = bookKeeping.func, context = bookKeeping.context;
                        var mappedChild = func.call(context, child, bookKeeping.count++);
                        if (Array.isArray(mappedChild)) {
                            mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
                        } else if (mappedChild != null) {
                            if (isValidElement(mappedChild)) {
                                mappedChild = cloneAndReplaceKey(mappedChild, keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + "/" : "") + childKey);
                            }
                            result.push(mappedChild);
                        }
                    }
                    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
                        var escapedPrefix = "";
                        if (prefix != null) {
                            escapedPrefix = escapeUserProvidedKey(prefix) + "/";
                        }
                        var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
                        traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
                        releaseTraverseContext(traverseContext);
                    }
                    function mapChildren(children, func, context) {
                        if (children == null) {
                            return children;
                        }
                        var result = [];
                        mapIntoWithKeyPrefixInternal(children, result, null, func, context);
                        return result;
                    }
                    function countChildren(children, context) {
                        return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
                    }
                    function toArray(children) {
                        var result = [];
                        mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
                        return result;
                    }
                    function onlyChild(children) {
                        !isValidElement(children) ? invariant(false, "React.Children.only expected to receive a single React element child.") : void 0;
                        return children;
                    }
                    var describeComponentFrame = function(name, source, ownerName) {
                        return "\n    in " + (name || "Unknown") + (source ? " (at " + source.fileName.replace(/^.*[\\\/]/, "") + ":" + source.lineNumber + ")" : ownerName ? " (created by " + ownerName + ")" : "");
                    };
                    function getComponentName(fiber) {
                        var type = fiber.type;
                        if (typeof type === "string") {
                            return type;
                        }
                        if (typeof type === "function") {
                            return type.displayName || type.name;
                        }
                        return null;
                    }
                    {
                        var currentlyValidatingElement = null;
                        var propTypesMisspellWarningShown = false;
                        var getDisplayName = function(element) {
                            if (element == null) {
                                return "#empty";
                            } else if (typeof element === "string" || typeof element === "number") {
                                return "#text";
                            } else if (typeof element.type === "string") {
                                return element.type;
                            } else if (element.type === REACT_FRAGMENT_TYPE) {
                                return "React.Fragment";
                            } else {
                                return element.type.displayName || element.type.name || "Unknown";
                            }
                        };
                        var getStackAddendum = function() {
                            var stack = "";
                            if (currentlyValidatingElement) {
                                var name = getDisplayName(currentlyValidatingElement);
                                var owner = currentlyValidatingElement._owner;
                                stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
                            }
                            stack += ReactDebugCurrentFrame.getStackAddendum() || "";
                            return stack;
                        };
                        var VALID_FRAGMENT_PROPS = new Map([ [ "children", true ], [ "key", true ] ]);
                    }
                    function getDeclarationErrorAddendum() {
                        if (ReactCurrentOwner.current) {
                            var name = getComponentName(ReactCurrentOwner.current);
                            if (name) {
                                return "\n\nCheck the render method of `" + name + "`.";
                            }
                        }
                        return "";
                    }
                    function getSourceInfoErrorAddendum(elementProps) {
                        if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
                            var source = elementProps.__source;
                            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
                            var lineNumber = source.lineNumber;
                            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
                        }
                        return "";
                    }
                    var ownerHasKeyUseWarning = {};
                    function getCurrentComponentErrorInfo(parentType) {
                        var info = getDeclarationErrorAddendum();
                        if (!info) {
                            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
                            if (parentName) {
                                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                            }
                        }
                        return info;
                    }
                    function validateExplicitKey(element, parentType) {
                        if (!element._store || element._store.validated || element.key != null) {
                            return;
                        }
                        element._store.validated = true;
                        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
                        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                            return;
                        }
                        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
                        var childOwner = "";
                        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                            childOwner = " It was passed a child from " + getComponentName(element._owner) + ".";
                        }
                        currentlyValidatingElement = element;
                        {
                            warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + "%s%s See https://fb.me/react-warning-keys for more information.%s", currentComponentErrorInfo, childOwner, getStackAddendum());
                        }
                        currentlyValidatingElement = null;
                    }
                    function validateChildKeys(node, parentType) {
                        if (typeof node !== "object") {
                            return;
                        }
                        if (Array.isArray(node)) {
                            for (var i = 0; i < node.length; i++) {
                                var child = node[i];
                                if (isValidElement(child)) {
                                    validateExplicitKey(child, parentType);
                                }
                            }
                        } else if (isValidElement(node)) {
                            if (node._store) {
                                node._store.validated = true;
                            }
                        } else if (node) {
                            var iteratorFn = getIteratorFn(node);
                            if (typeof iteratorFn === "function") {
                                if (iteratorFn !== node.entries) {
                                    var iterator = iteratorFn.call(node);
                                    var step;
                                    while (!(step = iterator.next()).done) {
                                        if (isValidElement(step.value)) {
                                            validateExplicitKey(step.value, parentType);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    function validatePropTypes(element) {
                        var componentClass = element.type;
                        if (typeof componentClass !== "function") {
                            return;
                        }
                        var name = componentClass.displayName || componentClass.name;
                        var propTypes = componentClass.propTypes;
                        if (propTypes) {
                            currentlyValidatingElement = element;
                            checkPropTypes(propTypes, element.props, "prop", name, getStackAddendum);
                            currentlyValidatingElement = null;
                        } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
                            propTypesMisspellWarningShown = true;
                            warning(false, "Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", name || "Unknown");
                        }
                        if (typeof componentClass.getDefaultProps === "function") {
                            warning(componentClass.getDefaultProps.isReactClassApproved, "getDefaultProps is only used on classic React.createClass " + "definitions. Use a static property named `defaultProps` instead.");
                        }
                    }
                    function validateFragmentProps(fragment) {
                        currentlyValidatingElement = fragment;
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;
                        try {
                            for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var key = _step.value;
                                if (!VALID_FRAGMENT_PROPS.has(key)) {
                                    warning(false, "Invalid prop `%s` supplied to `React.Fragment`. " + "React.Fragment can only have `key` and `children` props.%s", key, getStackAddendum());
                                    break;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        if (fragment.ref !== null) {
                            warning(false, "Invalid attribute `ref` supplied to `React.Fragment`.%s", getStackAddendum());
                        }
                        currentlyValidatingElement = null;
                    }
                    function createElementWithValidation(type, props, children) {
                        var validType = typeof type === "string" || typeof type === "function" || typeof type === "symbol" || typeof type === "number";
                        if (!validType) {
                            var info = "";
                            if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                                info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and named imports.";
                            }
                            var sourceInfo = getSourceInfoErrorAddendum(props);
                            if (sourceInfo) {
                                info += sourceInfo;
                            } else {
                                info += getDeclarationErrorAddendum();
                            }
                            info += getStackAddendum() || "";
                            warning(false, "React.createElement: type is invalid -- expected a string (for " + "built-in components) or a class/function (for composite " + "components) but got: %s.%s", type == null ? type : typeof type, info);
                        }
                        var element = createElement.apply(this, arguments);
                        if (element == null) {
                            return element;
                        }
                        if (validType) {
                            for (var i = 2; i < arguments.length; i++) {
                                validateChildKeys(arguments[i], type);
                            }
                        }
                        if (typeof type === "symbol" && type === REACT_FRAGMENT_TYPE) {
                            validateFragmentProps(element);
                        } else {
                            validatePropTypes(element);
                        }
                        return element;
                    }
                    function createFactoryWithValidation(type) {
                        var validatedFactory = createElementWithValidation.bind(null, type);
                        validatedFactory.type = type;
                        {
                            Object.defineProperty(validatedFactory, "type", {
                                enumerable: false,
                                get: function() {
                                    lowPriorityWarning$1(false, "Factory.type is deprecated. Access the class directly " + "before passing it to createFactory.");
                                    Object.defineProperty(this, "type", {
                                        value: type
                                    });
                                    return type;
                                }
                            });
                        }
                        return validatedFactory;
                    }
                    function cloneElementWithValidation(element, props, children) {
                        var newElement = cloneElement.apply(this, arguments);
                        for (var i = 2; i < arguments.length; i++) {
                            validateChildKeys(arguments[i], newElement.type);
                        }
                        validatePropTypes(newElement);
                        return newElement;
                    }
                    var React = {
                        Children: {
                            map: mapChildren,
                            forEach: forEachChildren,
                            count: countChildren,
                            toArray: toArray,
                            only: onlyChild
                        },
                        Component: Component,
                        PureComponent: PureComponent,
                        unstable_AsyncComponent: AsyncComponent,
                        Fragment: REACT_FRAGMENT_TYPE,
                        createElement: createElementWithValidation,
                        cloneElement: cloneElementWithValidation,
                        createFactory: createFactoryWithValidation,
                        isValidElement: isValidElement,
                        version: ReactVersion,
                        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                            ReactCurrentOwner: ReactCurrentOwner,
                            assign: _assign
                        }
                    };
                    {
                        _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
                            ReactDebugCurrentFrame: ReactDebugCurrentFrame,
                            ReactComponentTreeHook: {}
                        });
                    }
                    var React$2 = Object.freeze({
                        default: React
                    });
                    var React$3 = React$2 && React || React$2;
                    var react = React$3["default"] ? React$3["default"] : React$3;
                    module.exports = react;
                })();
            }
        }).call(this, require("_process"));
    }, {
        _process: 19,
        "fbjs/lib/emptyFunction": 6,
        "fbjs/lib/emptyObject": 7,
        "fbjs/lib/invariant": 12,
        "fbjs/lib/warning": 16,
        "object-assign": 18,
        "prop-types/checkPropTypes": 20
    } ],
    25: [ function(require, module, exports) {
        "use strict";
        var m = require("object-assign"), n = require("fbjs/lib/emptyObject"), p = require("fbjs/lib/emptyFunction"), q = "function" === typeof Symbol && Symbol["for"], r = q ? Symbol["for"]("react.element") : 60103, t = q ? Symbol["for"]("react.call") : 60104, u = q ? Symbol["for"]("react.return") : 60105, v = q ? Symbol["for"]("react.portal") : 60106, w = q ? Symbol["for"]("react.fragment") : 60107, x = "function" === typeof Symbol && Symbol.iterator;
        function y(a) {
            for (var b = arguments.length - 1, e = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant=" + a, c = 0; c < b; c++) e += "&args[]=" + encodeURIComponent(arguments[c + 1]);
            b = Error(e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");
            b.name = "Invariant Violation";
            b.framesToPop = 1;
            throw b;
        }
        var z = {
            isMounted: function() {
                return !1;
            },
            enqueueForceUpdate: function() {},
            enqueueReplaceState: function() {},
            enqueueSetState: function() {}
        };
        function A(a, b, e) {
            this.props = a;
            this.context = b;
            this.refs = n;
            this.updater = e || z;
        }
        A.prototype.isReactComponent = {};
        A.prototype.setState = function(a, b) {
            "object" !== typeof a && "function" !== typeof a && null != a ? y("85") : void 0;
            this.updater.enqueueSetState(this, a, b, "setState");
        };
        A.prototype.forceUpdate = function(a) {
            this.updater.enqueueForceUpdate(this, a, "forceUpdate");
        };
        function B(a, b, e) {
            this.props = a;
            this.context = b;
            this.refs = n;
            this.updater = e || z;
        }
        function C() {}
        C.prototype = A.prototype;
        var D = B.prototype = new C();
        D.constructor = B;
        m(D, A.prototype);
        D.isPureReactComponent = !0;
        function E(a, b, e) {
            this.props = a;
            this.context = b;
            this.refs = n;
            this.updater = e || z;
        }
        var F = E.prototype = new C();
        F.constructor = E;
        m(F, A.prototype);
        F.unstable_isAsyncReactComponent = !0;
        F.render = function() {
            return this.props.children;
        };
        var G = {
            current: null
        }, H = Object.prototype.hasOwnProperty, I = {
            key: !0,
            ref: !0,
            __self: !0,
            __source: !0
        };
        function J(a, b, e) {
            var c, d = {}, g = null, k = null;
            if (null != b) for (c in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (g = "" + b.key), 
            b) H.call(b, c) && !I.hasOwnProperty(c) && (d[c] = b[c]);
            var f = arguments.length - 2;
            if (1 === f) d.children = e; else if (1 < f) {
                for (var h = Array(f), l = 0; l < f; l++) h[l] = arguments[l + 2];
                d.children = h;
            }
            if (a && a.defaultProps) for (c in f = a.defaultProps, f) void 0 === d[c] && (d[c] = f[c]);
            return {
                $$typeof: r,
                type: a,
                key: g,
                ref: k,
                props: d,
                _owner: G.current
            };
        }
        function K(a) {
            return "object" === typeof a && null !== a && a.$$typeof === r;
        }
        function escape(a) {
            var b = {
                "=": "=0",
                ":": "=2"
            };
            return "$" + ("" + a).replace(/[=:]/g, function(a) {
                return b[a];
            });
        }
        var L = /\/+/g, M = [];
        function N(a, b, e, c) {
            if (M.length) {
                var d = M.pop();
                d.result = a;
                d.keyPrefix = b;
                d.func = e;
                d.context = c;
                d.count = 0;
                return d;
            }
            return {
                result: a,
                keyPrefix: b,
                func: e,
                context: c,
                count: 0
            };
        }
        function O(a) {
            a.result = null;
            a.keyPrefix = null;
            a.func = null;
            a.context = null;
            a.count = 0;
            10 > M.length && M.push(a);
        }
        function P(a, b, e, c) {
            var d = typeof a;
            if ("undefined" === d || "boolean" === d) a = null;
            var g = !1;
            if (null === a) g = !0; else switch (d) {
              case "string":
              case "number":
                g = !0;
                break;

              case "object":
                switch (a.$$typeof) {
                  case r:
                  case t:
                  case u:
                  case v:
                    g = !0;
                }
            }
            if (g) return e(c, a, "" === b ? "." + Q(a, 0) : b), 1;
            g = 0;
            b = "" === b ? "." : b + ":";
            if (Array.isArray(a)) for (var k = 0; k < a.length; k++) {
                d = a[k];
                var f = b + Q(d, k);
                g += P(d, f, e, c);
            } else if (null === a || "undefined" === typeof a ? f = null : (f = x && a[x] || a["@@iterator"], 
            f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), 
            k = 0; !(d = a.next()).done; ) d = d.value, f = b + Q(d, k++), g += P(d, f, e, c); else "object" === d && (e = "" + a, 
            y("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));
            return g;
        }
        function Q(a, b) {
            return "object" === typeof a && null !== a && null != a.key ? escape(a.key) : b.toString(36);
        }
        function R(a, b) {
            a.func.call(a.context, b, a.count++);
        }
        function S(a, b, e) {
            var c = a.result, d = a.keyPrefix;
            a = a.func.call(a.context, b, a.count++);
            Array.isArray(a) ? T(a, c, e, p.thatReturnsArgument) : null != a && (K(a) && (b = d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(L, "$&/") + "/") + e, 
            a = {
                $$typeof: r,
                type: a.type,
                key: b,
                ref: a.ref,
                props: a.props,
                _owner: a._owner
            }), c.push(a));
        }
        function T(a, b, e, c, d) {
            var g = "";
            null != e && (g = ("" + e).replace(L, "$&/") + "/");
            b = N(b, g, c, d);
            null == a || P(a, "", S, b);
            O(b);
        }
        var U = {
            Children: {
                map: function(a, b, e) {
                    if (null == a) return a;
                    var c = [];
                    T(a, c, null, b, e);
                    return c;
                },
                forEach: function(a, b, e) {
                    if (null == a) return a;
                    b = N(null, null, b, e);
                    null == a || P(a, "", R, b);
                    O(b);
                },
                count: function(a) {
                    return null == a ? 0 : P(a, "", p.thatReturnsNull, null);
                },
                toArray: function(a) {
                    var b = [];
                    T(a, b, null, p.thatReturnsArgument);
                    return b;
                },
                only: function(a) {
                    K(a) ? void 0 : y("143");
                    return a;
                }
            },
            Component: A,
            PureComponent: B,
            unstable_AsyncComponent: E,
            Fragment: w,
            createElement: J,
            cloneElement: function(a, b, e) {
                var c = m({}, a.props), d = a.key, g = a.ref, k = a._owner;
                if (null != b) {
                    void 0 !== b.ref && (g = b.ref, k = G.current);
                    void 0 !== b.key && (d = "" + b.key);
                    if (a.type && a.type.defaultProps) var f = a.type.defaultProps;
                    for (h in b) H.call(b, h) && !I.hasOwnProperty(h) && (c[h] = void 0 === b[h] && void 0 !== f ? f[h] : b[h]);
                }
                var h = arguments.length - 2;
                if (1 === h) c.children = e; else if (1 < h) {
                    f = Array(h);
                    for (var l = 0; l < h; l++) f[l] = arguments[l + 2];
                    c.children = f;
                }
                return {
                    $$typeof: r,
                    type: a.type,
                    key: d,
                    ref: g,
                    props: c,
                    _owner: k
                };
            },
            createFactory: function(a) {
                var b = J.bind(null, a);
                b.type = a;
                return b;
            },
            isValidElement: K,
            version: "16.2.0",
            __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                ReactCurrentOwner: G,
                assign: m
            }
        }, V = Object.freeze({
            default: U
        }), W = V && U || V;
        module.exports = W["default"] ? W["default"] : W;
    }, {
        "fbjs/lib/emptyFunction": 6,
        "fbjs/lib/emptyObject": 7,
        "object-assign": 18
    } ],
    flux: [ function(require, module, exports) {
        module.exports.Dispatcher = require("./lib/Dispatcher");
    }, {
        "./lib/Dispatcher": 17
    } ],
    "react-dom": [ function(require, module, exports) {
        (function(process) {
            "use strict";
            function checkDCE() {
                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
                    return;
                }
                if (process.env.NODE_ENV !== "production") {
                    throw new Error("^_^");
                }
                try {
                    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
                } catch (err) {
                    console.error(err);
                }
            }
            if (process.env.NODE_ENV === "production") {
                checkDCE();
                module.exports = require("./cjs/react-dom.production.min.js");
            } else {
                module.exports = require("./cjs/react-dom.development.js");
            }
        }).call(this, require("_process"));
    }, {
        "./cjs/react-dom.development.js": 22,
        "./cjs/react-dom.production.min.js": 23,
        _process: 19
    } ],
    react: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            if (process.env.NODE_ENV === "production") {
                module.exports = require("./cjs/react.production.min.js");
            } else {
                module.exports = require("./cjs/react.development.js");
            }
        }).call(this, require("_process"));
    }, {
        "./cjs/react.development.js": 24,
        "./cjs/react.production.min.js": 25,
        _process: 19
    } ],
    underscore: [ function(require, module, exports) {
        (function(global) {
            (function() {
                var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || this || {};
                var previousUnderscore = root._;
                var ArrayProto = Array.prototype, ObjProto = Object.prototype;
                var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
                var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
                var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create;
                var Ctor = function() {};
                var _ = function(obj) {
                    if (obj instanceof _) return obj;
                    if (!(this instanceof _)) return new _(obj);
                    this._wrapped = obj;
                };
                if (typeof exports != "undefined" && !exports.nodeType) {
                    if (typeof module != "undefined" && !module.nodeType && module.exports) {
                        exports = module.exports = _;
                    }
                    exports._ = _;
                } else {
                    root._ = _;
                }
                _.VERSION = "1.9.1";
                var optimizeCb = function(func, context, argCount) {
                    if (context === void 0) return func;
                    switch (argCount == null ? 3 : argCount) {
                      case 1:
                        return function(value) {
                            return func.call(context, value);
                        };

                      case 3:
                        return function(value, index, collection) {
                            return func.call(context, value, index, collection);
                        };

                      case 4:
                        return function(accumulator, value, index, collection) {
                            return func.call(context, accumulator, value, index, collection);
                        };
                    }
                    return function() {
                        return func.apply(context, arguments);
                    };
                };
                var builtinIteratee;
                var cb = function(value, context, argCount) {
                    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
                    if (value == null) return _.identity;
                    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
                    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
                    return _.property(value);
                };
                _.iteratee = builtinIteratee = function(value, context) {
                    return cb(value, context, Infinity);
                };
                var restArguments = function(func, startIndex) {
                    startIndex = startIndex == null ? func.length - 1 : +startIndex;
                    return function() {
                        var length = Math.max(arguments.length - startIndex, 0), rest = Array(length), index = 0;
                        for (;index < length; index++) {
                            rest[index] = arguments[index + startIndex];
                        }
                        switch (startIndex) {
                          case 0:
                            return func.call(this, rest);

                          case 1:
                            return func.call(this, arguments[0], rest);

                          case 2:
                            return func.call(this, arguments[0], arguments[1], rest);
                        }
                        var args = Array(startIndex + 1);
                        for (index = 0; index < startIndex; index++) {
                            args[index] = arguments[index];
                        }
                        args[startIndex] = rest;
                        return func.apply(this, args);
                    };
                };
                var baseCreate = function(prototype) {
                    if (!_.isObject(prototype)) return {};
                    if (nativeCreate) return nativeCreate(prototype);
                    Ctor.prototype = prototype;
                    var result = new Ctor();
                    Ctor.prototype = null;
                    return result;
                };
                var shallowProperty = function(key) {
                    return function(obj) {
                        return obj == null ? void 0 : obj[key];
                    };
                };
                var has = function(obj, path) {
                    return obj != null && hasOwnProperty.call(obj, path);
                };
                var deepGet = function(obj, path) {
                    var length = path.length;
                    for (var i = 0; i < length; i++) {
                        if (obj == null) return void 0;
                        obj = obj[path[i]];
                    }
                    return length ? obj : void 0;
                };
                var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
                var getLength = shallowProperty("length");
                var isArrayLike = function(collection) {
                    var length = getLength(collection);
                    return typeof length == "number" && length >= 0 && length <= MAX_ARRAY_INDEX;
                };
                _.each = _.forEach = function(obj, iteratee, context) {
                    iteratee = optimizeCb(iteratee, context);
                    var i, length;
                    if (isArrayLike(obj)) {
                        for (i = 0, length = obj.length; i < length; i++) {
                            iteratee(obj[i], i, obj);
                        }
                    } else {
                        var keys = _.keys(obj);
                        for (i = 0, length = keys.length; i < length; i++) {
                            iteratee(obj[keys[i]], keys[i], obj);
                        }
                    }
                    return obj;
                };
                _.map = _.collect = function(obj, iteratee, context) {
                    iteratee = cb(iteratee, context);
                    var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length);
                    for (var index = 0; index < length; index++) {
                        var currentKey = keys ? keys[index] : index;
                        results[index] = iteratee(obj[currentKey], currentKey, obj);
                    }
                    return results;
                };
                var createReduce = function(dir) {
                    var reducer = function(obj, iteratee, memo, initial) {
                        var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = dir > 0 ? 0 : length - 1;
                        if (!initial) {
                            memo = obj[keys ? keys[index] : index];
                            index += dir;
                        }
                        for (;index >= 0 && index < length; index += dir) {
                            var currentKey = keys ? keys[index] : index;
                            memo = iteratee(memo, obj[currentKey], currentKey, obj);
                        }
                        return memo;
                    };
                    return function(obj, iteratee, memo, context) {
                        var initial = arguments.length >= 3;
                        return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
                    };
                };
                _.reduce = _.foldl = _.inject = createReduce(1);
                _.reduceRight = _.foldr = createReduce(-1);
                _.find = _.detect = function(obj, predicate, context) {
                    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
                    var key = keyFinder(obj, predicate, context);
                    if (key !== void 0 && key !== -1) return obj[key];
                };
                _.filter = _.select = function(obj, predicate, context) {
                    var results = [];
                    predicate = cb(predicate, context);
                    _.each(obj, function(value, index, list) {
                        if (predicate(value, index, list)) results.push(value);
                    });
                    return results;
                };
                _.reject = function(obj, predicate, context) {
                    return _.filter(obj, _.negate(cb(predicate)), context);
                };
                _.every = _.all = function(obj, predicate, context) {
                    predicate = cb(predicate, context);
                    var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
                    for (var index = 0; index < length; index++) {
                        var currentKey = keys ? keys[index] : index;
                        if (!predicate(obj[currentKey], currentKey, obj)) return false;
                    }
                    return true;
                };
                _.some = _.any = function(obj, predicate, context) {
                    predicate = cb(predicate, context);
                    var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
                    for (var index = 0; index < length; index++) {
                        var currentKey = keys ? keys[index] : index;
                        if (predicate(obj[currentKey], currentKey, obj)) return true;
                    }
                    return false;
                };
                _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
                    if (!isArrayLike(obj)) obj = _.values(obj);
                    if (typeof fromIndex != "number" || guard) fromIndex = 0;
                    return _.indexOf(obj, item, fromIndex) >= 0;
                };
                _.invoke = restArguments(function(obj, path, args) {
                    var contextPath, func;
                    if (_.isFunction(path)) {
                        func = path;
                    } else if (_.isArray(path)) {
                        contextPath = path.slice(0, -1);
                        path = path[path.length - 1];
                    }
                    return _.map(obj, function(context) {
                        var method = func;
                        if (!method) {
                            if (contextPath && contextPath.length) {
                                context = deepGet(context, contextPath);
                            }
                            if (context == null) return void 0;
                            method = context[path];
                        }
                        return method == null ? method : method.apply(context, args);
                    });
                });
                _.pluck = function(obj, key) {
                    return _.map(obj, _.property(key));
                };
                _.where = function(obj, attrs) {
                    return _.filter(obj, _.matcher(attrs));
                };
                _.findWhere = function(obj, attrs) {
                    return _.find(obj, _.matcher(attrs));
                };
                _.max = function(obj, iteratee, context) {
                    var result = -Infinity, lastComputed = -Infinity, value, computed;
                    if (iteratee == null || typeof iteratee == "number" && typeof obj[0] != "object" && obj != null) {
                        obj = isArrayLike(obj) ? obj : _.values(obj);
                        for (var i = 0, length = obj.length; i < length; i++) {
                            value = obj[i];
                            if (value != null && value > result) {
                                result = value;
                            }
                        }
                    } else {
                        iteratee = cb(iteratee, context);
                        _.each(obj, function(v, index, list) {
                            computed = iteratee(v, index, list);
                            if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                                result = v;
                                lastComputed = computed;
                            }
                        });
                    }
                    return result;
                };
                _.min = function(obj, iteratee, context) {
                    var result = Infinity, lastComputed = Infinity, value, computed;
                    if (iteratee == null || typeof iteratee == "number" && typeof obj[0] != "object" && obj != null) {
                        obj = isArrayLike(obj) ? obj : _.values(obj);
                        for (var i = 0, length = obj.length; i < length; i++) {
                            value = obj[i];
                            if (value != null && value < result) {
                                result = value;
                            }
                        }
                    } else {
                        iteratee = cb(iteratee, context);
                        _.each(obj, function(v, index, list) {
                            computed = iteratee(v, index, list);
                            if (computed < lastComputed || computed === Infinity && result === Infinity) {
                                result = v;
                                lastComputed = computed;
                            }
                        });
                    }
                    return result;
                };
                _.shuffle = function(obj) {
                    return _.sample(obj, Infinity);
                };
                _.sample = function(obj, n, guard) {
                    if (n == null || guard) {
                        if (!isArrayLike(obj)) obj = _.values(obj);
                        return obj[_.random(obj.length - 1)];
                    }
                    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
                    var length = getLength(sample);
                    n = Math.max(Math.min(n, length), 0);
                    var last = length - 1;
                    for (var index = 0; index < n; index++) {
                        var rand = _.random(index, last);
                        var temp = sample[index];
                        sample[index] = sample[rand];
                        sample[rand] = temp;
                    }
                    return sample.slice(0, n);
                };
                _.sortBy = function(obj, iteratee, context) {
                    var index = 0;
                    iteratee = cb(iteratee, context);
                    return _.pluck(_.map(obj, function(value, key, list) {
                        return {
                            value: value,
                            index: index++,
                            criteria: iteratee(value, key, list)
                        };
                    }).sort(function(left, right) {
                        var a = left.criteria;
                        var b = right.criteria;
                        if (a !== b) {
                            if (a > b || a === void 0) return 1;
                            if (a < b || b === void 0) return -1;
                        }
                        return left.index - right.index;
                    }), "value");
                };
                var group = function(behavior, partition) {
                    return function(obj, iteratee, context) {
                        var result = partition ? [ [], [] ] : {};
                        iteratee = cb(iteratee, context);
                        _.each(obj, function(value, index) {
                            var key = iteratee(value, index, obj);
                            behavior(result, value, key);
                        });
                        return result;
                    };
                };
                _.groupBy = group(function(result, value, key) {
                    if (has(result, key)) result[key].push(value); else result[key] = [ value ];
                });
                _.indexBy = group(function(result, value, key) {
                    result[key] = value;
                });
                _.countBy = group(function(result, value, key) {
                    if (has(result, key)) result[key]++; else result[key] = 1;
                });
                var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
                _.toArray = function(obj) {
                    if (!obj) return [];
                    if (_.isArray(obj)) return slice.call(obj);
                    if (_.isString(obj)) {
                        return obj.match(reStrSymbol);
                    }
                    if (isArrayLike(obj)) return _.map(obj, _.identity);
                    return _.values(obj);
                };
                _.size = function(obj) {
                    if (obj == null) return 0;
                    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
                };
                _.partition = group(function(result, value, pass) {
                    result[pass ? 0 : 1].push(value);
                }, true);
                _.first = _.head = _.take = function(array, n, guard) {
                    if (array == null || array.length < 1) return n == null ? void 0 : [];
                    if (n == null || guard) return array[0];
                    return _.initial(array, array.length - n);
                };
                _.initial = function(array, n, guard) {
                    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
                };
                _.last = function(array, n, guard) {
                    if (array == null || array.length < 1) return n == null ? void 0 : [];
                    if (n == null || guard) return array[array.length - 1];
                    return _.rest(array, Math.max(0, array.length - n));
                };
                _.rest = _.tail = _.drop = function(array, n, guard) {
                    return slice.call(array, n == null || guard ? 1 : n);
                };
                _.compact = function(array) {
                    return _.filter(array, Boolean);
                };
                var flatten = function(input, shallow, strict, output) {
                    output = output || [];
                    var idx = output.length;
                    for (var i = 0, length = getLength(input); i < length; i++) {
                        var value = input[i];
                        if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
                            if (shallow) {
                                var j = 0, len = value.length;
                                while (j < len) output[idx++] = value[j++];
                            } else {
                                flatten(value, shallow, strict, output);
                                idx = output.length;
                            }
                        } else if (!strict) {
                            output[idx++] = value;
                        }
                    }
                    return output;
                };
                _.flatten = function(array, shallow) {
                    return flatten(array, shallow, false);
                };
                _.without = restArguments(function(array, otherArrays) {
                    return _.difference(array, otherArrays);
                });
                _.uniq = _.unique = function(array, isSorted, iteratee, context) {
                    if (!_.isBoolean(isSorted)) {
                        context = iteratee;
                        iteratee = isSorted;
                        isSorted = false;
                    }
                    if (iteratee != null) iteratee = cb(iteratee, context);
                    var result = [];
                    var seen = [];
                    for (var i = 0, length = getLength(array); i < length; i++) {
                        var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
                        if (isSorted && !iteratee) {
                            if (!i || seen !== computed) result.push(value);
                            seen = computed;
                        } else if (iteratee) {
                            if (!_.contains(seen, computed)) {
                                seen.push(computed);
                                result.push(value);
                            }
                        } else if (!_.contains(result, value)) {
                            result.push(value);
                        }
                    }
                    return result;
                };
                _.union = restArguments(function(arrays) {
                    return _.uniq(flatten(arrays, true, true));
                });
                _.intersection = function(array) {
                    var result = [];
                    var argsLength = arguments.length;
                    for (var i = 0, length = getLength(array); i < length; i++) {
                        var item = array[i];
                        if (_.contains(result, item)) continue;
                        var j;
                        for (j = 1; j < argsLength; j++) {
                            if (!_.contains(arguments[j], item)) break;
                        }
                        if (j === argsLength) result.push(item);
                    }
                    return result;
                };
                _.difference = restArguments(function(array, rest) {
                    rest = flatten(rest, true, true);
                    return _.filter(array, function(value) {
                        return !_.contains(rest, value);
                    });
                });
                _.unzip = function(array) {
                    var length = array && _.max(array, getLength).length || 0;
                    var result = Array(length);
                    for (var index = 0; index < length; index++) {
                        result[index] = _.pluck(array, index);
                    }
                    return result;
                };
                _.zip = restArguments(_.unzip);
                _.object = function(list, values) {
                    var result = {};
                    for (var i = 0, length = getLength(list); i < length; i++) {
                        if (values) {
                            result[list[i]] = values[i];
                        } else {
                            result[list[i][0]] = list[i][1];
                        }
                    }
                    return result;
                };
                var createPredicateIndexFinder = function(dir) {
                    return function(array, predicate, context) {
                        predicate = cb(predicate, context);
                        var length = getLength(array);
                        var index = dir > 0 ? 0 : length - 1;
                        for (;index >= 0 && index < length; index += dir) {
                            if (predicate(array[index], index, array)) return index;
                        }
                        return -1;
                    };
                };
                _.findIndex = createPredicateIndexFinder(1);
                _.findLastIndex = createPredicateIndexFinder(-1);
                _.sortedIndex = function(array, obj, iteratee, context) {
                    iteratee = cb(iteratee, context, 1);
                    var value = iteratee(obj);
                    var low = 0, high = getLength(array);
                    while (low < high) {
                        var mid = Math.floor((low + high) / 2);
                        if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
                    }
                    return low;
                };
                var createIndexFinder = function(dir, predicateFind, sortedIndex) {
                    return function(array, item, idx) {
                        var i = 0, length = getLength(array);
                        if (typeof idx == "number") {
                            if (dir > 0) {
                                i = idx >= 0 ? idx : Math.max(idx + length, i);
                            } else {
                                length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
                            }
                        } else if (sortedIndex && idx && length) {
                            idx = sortedIndex(array, item);
                            return array[idx] === item ? idx : -1;
                        }
                        if (item !== item) {
                            idx = predicateFind(slice.call(array, i, length), _.isNaN);
                            return idx >= 0 ? idx + i : -1;
                        }
                        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
                            if (array[idx] === item) return idx;
                        }
                        return -1;
                    };
                };
                _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
                _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
                _.range = function(start, stop, step) {
                    if (stop == null) {
                        stop = start || 0;
                        start = 0;
                    }
                    if (!step) {
                        step = stop < start ? -1 : 1;
                    }
                    var length = Math.max(Math.ceil((stop - start) / step), 0);
                    var range = Array(length);
                    for (var idx = 0; idx < length; idx++, start += step) {
                        range[idx] = start;
                    }
                    return range;
                };
                _.chunk = function(array, count) {
                    if (count == null || count < 1) return [];
                    var result = [];
                    var i = 0, length = array.length;
                    while (i < length) {
                        result.push(slice.call(array, i, i += count));
                    }
                    return result;
                };
                var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
                    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
                    var self = baseCreate(sourceFunc.prototype);
                    var result = sourceFunc.apply(self, args);
                    if (_.isObject(result)) return result;
                    return self;
                };
                _.bind = restArguments(function(func, context, args) {
                    if (!_.isFunction(func)) throw new TypeError("Bind must be called on a function");
                    var bound = restArguments(function(callArgs) {
                        return executeBound(func, bound, context, this, args.concat(callArgs));
                    });
                    return bound;
                });
                _.partial = restArguments(function(func, boundArgs) {
                    var placeholder = _.partial.placeholder;
                    var bound = function() {
                        var position = 0, length = boundArgs.length;
                        var args = Array(length);
                        for (var i = 0; i < length; i++) {
                            args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
                        }
                        while (position < arguments.length) args.push(arguments[position++]);
                        return executeBound(func, bound, this, this, args);
                    };
                    return bound;
                });
                _.partial.placeholder = _;
                _.bindAll = restArguments(function(obj, keys) {
                    keys = flatten(keys, false, false);
                    var index = keys.length;
                    if (index < 1) throw new Error("bindAll must be passed function names");
                    while (index--) {
                        var key = keys[index];
                        obj[key] = _.bind(obj[key], obj);
                    }
                });
                _.memoize = function(func, hasher) {
                    var memoize = function(key) {
                        var cache = memoize.cache;
                        var address = "" + (hasher ? hasher.apply(this, arguments) : key);
                        if (!has(cache, address)) cache[address] = func.apply(this, arguments);
                        return cache[address];
                    };
                    memoize.cache = {};
                    return memoize;
                };
                _.delay = restArguments(function(func, wait, args) {
                    return setTimeout(function() {
                        return func.apply(null, args);
                    }, wait);
                });
                _.defer = _.partial(_.delay, _, 1);
                _.throttle = function(func, wait, options) {
                    var timeout, context, args, result;
                    var previous = 0;
                    if (!options) options = {};
                    var later = function() {
                        previous = options.leading === false ? 0 : _.now();
                        timeout = null;
                        result = func.apply(context, args);
                        if (!timeout) context = args = null;
                    };
                    var throttled = function() {
                        var now = _.now();
                        if (!previous && options.leading === false) previous = now;
                        var remaining = wait - (now - previous);
                        context = this;
                        args = arguments;
                        if (remaining <= 0 || remaining > wait) {
                            if (timeout) {
                                clearTimeout(timeout);
                                timeout = null;
                            }
                            previous = now;
                            result = func.apply(context, args);
                            if (!timeout) context = args = null;
                        } else if (!timeout && options.trailing !== false) {
                            timeout = setTimeout(later, remaining);
                        }
                        return result;
                    };
                    throttled.cancel = function() {
                        clearTimeout(timeout);
                        previous = 0;
                        timeout = context = args = null;
                    };
                    return throttled;
                };
                _.debounce = function(func, wait, immediate) {
                    var timeout, result;
                    var later = function(context, args) {
                        timeout = null;
                        if (args) result = func.apply(context, args);
                    };
                    var debounced = restArguments(function(args) {
                        if (timeout) clearTimeout(timeout);
                        if (immediate) {
                            var callNow = !timeout;
                            timeout = setTimeout(later, wait);
                            if (callNow) result = func.apply(this, args);
                        } else {
                            timeout = _.delay(later, wait, this, args);
                        }
                        return result;
                    });
                    debounced.cancel = function() {
                        clearTimeout(timeout);
                        timeout = null;
                    };
                    return debounced;
                };
                _.wrap = function(func, wrapper) {
                    return _.partial(wrapper, func);
                };
                _.negate = function(predicate) {
                    return function() {
                        return !predicate.apply(this, arguments);
                    };
                };
                _.compose = function() {
                    var args = arguments;
                    var start = args.length - 1;
                    return function() {
                        var i = start;
                        var result = args[start].apply(this, arguments);
                        while (i--) result = args[i].call(this, result);
                        return result;
                    };
                };
                _.after = function(times, func) {
                    return function() {
                        if (--times < 1) {
                            return func.apply(this, arguments);
                        }
                    };
                };
                _.before = function(times, func) {
                    var memo;
                    return function() {
                        if (--times > 0) {
                            memo = func.apply(this, arguments);
                        }
                        if (times <= 1) func = null;
                        return memo;
                    };
                };
                _.once = _.partial(_.before, 2);
                _.restArguments = restArguments;
                var hasEnumBug = !{
                    toString: null
                }.propertyIsEnumerable("toString");
                var nonEnumerableProps = [ "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString" ];
                var collectNonEnumProps = function(obj, keys) {
                    var nonEnumIdx = nonEnumerableProps.length;
                    var constructor = obj.constructor;
                    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;
                    var prop = "constructor";
                    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
                    while (nonEnumIdx--) {
                        prop = nonEnumerableProps[nonEnumIdx];
                        if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
                            keys.push(prop);
                        }
                    }
                };
                _.keys = function(obj) {
                    if (!_.isObject(obj)) return [];
                    if (nativeKeys) return nativeKeys(obj);
                    var keys = [];
                    for (var key in obj) if (has(obj, key)) keys.push(key);
                    if (hasEnumBug) collectNonEnumProps(obj, keys);
                    return keys;
                };
                _.allKeys = function(obj) {
                    if (!_.isObject(obj)) return [];
                    var keys = [];
                    for (var key in obj) keys.push(key);
                    if (hasEnumBug) collectNonEnumProps(obj, keys);
                    return keys;
                };
                _.values = function(obj) {
                    var keys = _.keys(obj);
                    var length = keys.length;
                    var values = Array(length);
                    for (var i = 0; i < length; i++) {
                        values[i] = obj[keys[i]];
                    }
                    return values;
                };
                _.mapObject = function(obj, iteratee, context) {
                    iteratee = cb(iteratee, context);
                    var keys = _.keys(obj), length = keys.length, results = {};
                    for (var index = 0; index < length; index++) {
                        var currentKey = keys[index];
                        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
                    }
                    return results;
                };
                _.pairs = function(obj) {
                    var keys = _.keys(obj);
                    var length = keys.length;
                    var pairs = Array(length);
                    for (var i = 0; i < length; i++) {
                        pairs[i] = [ keys[i], obj[keys[i]] ];
                    }
                    return pairs;
                };
                _.invert = function(obj) {
                    var result = {};
                    var keys = _.keys(obj);
                    for (var i = 0, length = keys.length; i < length; i++) {
                        result[obj[keys[i]]] = keys[i];
                    }
                    return result;
                };
                _.functions = _.methods = function(obj) {
                    var names = [];
                    for (var key in obj) {
                        if (_.isFunction(obj[key])) names.push(key);
                    }
                    return names.sort();
                };
                var createAssigner = function(keysFunc, defaults) {
                    return function(obj) {
                        var length = arguments.length;
                        if (defaults) obj = Object(obj);
                        if (length < 2 || obj == null) return obj;
                        for (var index = 1; index < length; index++) {
                            var source = arguments[index], keys = keysFunc(source), l = keys.length;
                            for (var i = 0; i < l; i++) {
                                var key = keys[i];
                                if (!defaults || obj[key] === void 0) obj[key] = source[key];
                            }
                        }
                        return obj;
                    };
                };
                _.extend = createAssigner(_.allKeys);
                _.extendOwn = _.assign = createAssigner(_.keys);
                _.findKey = function(obj, predicate, context) {
                    predicate = cb(predicate, context);
                    var keys = _.keys(obj), key;
                    for (var i = 0, length = keys.length; i < length; i++) {
                        key = keys[i];
                        if (predicate(obj[key], key, obj)) return key;
                    }
                };
                var keyInObj = function(value, key, obj) {
                    return key in obj;
                };
                _.pick = restArguments(function(obj, keys) {
                    var result = {}, iteratee = keys[0];
                    if (obj == null) return result;
                    if (_.isFunction(iteratee)) {
                        if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
                        keys = _.allKeys(obj);
                    } else {
                        iteratee = keyInObj;
                        keys = flatten(keys, false, false);
                        obj = Object(obj);
                    }
                    for (var i = 0, length = keys.length; i < length; i++) {
                        var key = keys[i];
                        var value = obj[key];
                        if (iteratee(value, key, obj)) result[key] = value;
                    }
                    return result;
                });
                _.omit = restArguments(function(obj, keys) {
                    var iteratee = keys[0], context;
                    if (_.isFunction(iteratee)) {
                        iteratee = _.negate(iteratee);
                        if (keys.length > 1) context = keys[1];
                    } else {
                        keys = _.map(flatten(keys, false, false), String);
                        iteratee = function(value, key) {
                            return !_.contains(keys, key);
                        };
                    }
                    return _.pick(obj, iteratee, context);
                });
                _.defaults = createAssigner(_.allKeys, true);
                _.create = function(prototype, props) {
                    var result = baseCreate(prototype);
                    if (props) _.extendOwn(result, props);
                    return result;
                };
                _.clone = function(obj) {
                    if (!_.isObject(obj)) return obj;
                    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
                };
                _.tap = function(obj, interceptor) {
                    interceptor(obj);
                    return obj;
                };
                _.isMatch = function(object, attrs) {
                    var keys = _.keys(attrs), length = keys.length;
                    if (object == null) return !length;
                    var obj = Object(object);
                    for (var i = 0; i < length; i++) {
                        var key = keys[i];
                        if (attrs[key] !== obj[key] || !(key in obj)) return false;
                    }
                    return true;
                };
                var eq, deepEq;
                eq = function(a, b, aStack, bStack) {
                    if (a === b) return a !== 0 || 1 / a === 1 / b;
                    if (a == null || b == null) return false;
                    if (a !== a) return b !== b;
                    var type = typeof a;
                    if (type !== "function" && type !== "object" && typeof b != "object") return false;
                    return deepEq(a, b, aStack, bStack);
                };
                deepEq = function(a, b, aStack, bStack) {
                    if (a instanceof _) a = a._wrapped;
                    if (b instanceof _) b = b._wrapped;
                    var className = toString.call(a);
                    if (className !== toString.call(b)) return false;
                    switch (className) {
                      case "[object RegExp]":
                      case "[object String]":
                        return "" + a === "" + b;

                      case "[object Number]":
                        if (+a !== +a) return +b !== +b;
                        return +a === 0 ? 1 / +a === 1 / b : +a === +b;

                      case "[object Date]":
                      case "[object Boolean]":
                        return +a === +b;

                      case "[object Symbol]":
                        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
                    }
                    var areArrays = className === "[object Array]";
                    if (!areArrays) {
                        if (typeof a != "object" || typeof b != "object") return false;
                        var aCtor = a.constructor, bCtor = b.constructor;
                        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
                            return false;
                        }
                    }
                    aStack = aStack || [];
                    bStack = bStack || [];
                    var length = aStack.length;
                    while (length--) {
                        if (aStack[length] === a) return bStack[length] === b;
                    }
                    aStack.push(a);
                    bStack.push(b);
                    if (areArrays) {
                        length = a.length;
                        if (length !== b.length) return false;
                        while (length--) {
                            if (!eq(a[length], b[length], aStack, bStack)) return false;
                        }
                    } else {
                        var keys = _.keys(a), key;
                        length = keys.length;
                        if (_.keys(b).length !== length) return false;
                        while (length--) {
                            key = keys[length];
                            if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
                        }
                    }
                    aStack.pop();
                    bStack.pop();
                    return true;
                };
                _.isEqual = function(a, b) {
                    return eq(a, b);
                };
                _.isEmpty = function(obj) {
                    if (obj == null) return true;
                    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
                    return _.keys(obj).length === 0;
                };
                _.isElement = function(obj) {
                    return !!(obj && obj.nodeType === 1);
                };
                _.isArray = nativeIsArray || function(obj) {
                    return toString.call(obj) === "[object Array]";
                };
                _.isObject = function(obj) {
                    var type = typeof obj;
                    return type === "function" || type === "object" && !!obj;
                };
                _.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp", "Error", "Symbol", "Map", "WeakMap", "Set", "WeakSet" ], function(name) {
                    _["is" + name] = function(obj) {
                        return toString.call(obj) === "[object " + name + "]";
                    };
                });
                if (!_.isArguments(arguments)) {
                    _.isArguments = function(obj) {
                        return has(obj, "callee");
                    };
                }
                var nodelist = root.document && root.document.childNodes;
                if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
                    _.isFunction = function(obj) {
                        return typeof obj == "function" || false;
                    };
                }
                _.isFinite = function(obj) {
                    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
                };
                _.isNaN = function(obj) {
                    return _.isNumber(obj) && isNaN(obj);
                };
                _.isBoolean = function(obj) {
                    return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
                };
                _.isNull = function(obj) {
                    return obj === null;
                };
                _.isUndefined = function(obj) {
                    return obj === void 0;
                };
                _.has = function(obj, path) {
                    if (!_.isArray(path)) {
                        return has(obj, path);
                    }
                    var length = path.length;
                    for (var i = 0; i < length; i++) {
                        var key = path[i];
                        if (obj == null || !hasOwnProperty.call(obj, key)) {
                            return false;
                        }
                        obj = obj[key];
                    }
                    return !!length;
                };
                _.noConflict = function() {
                    root._ = previousUnderscore;
                    return this;
                };
                _.identity = function(value) {
                    return value;
                };
                _.constant = function(value) {
                    return function() {
                        return value;
                    };
                };
                _.noop = function() {};
                _.property = function(path) {
                    if (!_.isArray(path)) {
                        return shallowProperty(path);
                    }
                    return function(obj) {
                        return deepGet(obj, path);
                    };
                };
                _.propertyOf = function(obj) {
                    if (obj == null) {
                        return function() {};
                    }
                    return function(path) {
                        return !_.isArray(path) ? obj[path] : deepGet(obj, path);
                    };
                };
                _.matcher = _.matches = function(attrs) {
                    attrs = _.extendOwn({}, attrs);
                    return function(obj) {
                        return _.isMatch(obj, attrs);
                    };
                };
                _.times = function(n, iteratee, context) {
                    var accum = Array(Math.max(0, n));
                    iteratee = optimizeCb(iteratee, context, 1);
                    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
                    return accum;
                };
                _.random = function(min, max) {
                    if (max == null) {
                        max = min;
                        min = 0;
                    }
                    return min + Math.floor(Math.random() * (max - min + 1));
                };
                _.now = Date.now || function() {
                    return new Date().getTime();
                };
                var escapeMap = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#x27;",
                    "`": "&#x60;"
                };
                var unescapeMap = _.invert(escapeMap);
                var createEscaper = function(map) {
                    var escaper = function(match) {
                        return map[match];
                    };
                    var source = "(?:" + _.keys(map).join("|") + ")";
                    var testRegexp = RegExp(source);
                    var replaceRegexp = RegExp(source, "g");
                    return function(string) {
                        string = string == null ? "" : "" + string;
                        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
                    };
                };
                _.escape = createEscaper(escapeMap);
                _.unescape = createEscaper(unescapeMap);
                _.result = function(obj, path, fallback) {
                    if (!_.isArray(path)) path = [ path ];
                    var length = path.length;
                    if (!length) {
                        return _.isFunction(fallback) ? fallback.call(obj) : fallback;
                    }
                    for (var i = 0; i < length; i++) {
                        var prop = obj == null ? void 0 : obj[path[i]];
                        if (prop === void 0) {
                            prop = fallback;
                            i = length;
                        }
                        obj = _.isFunction(prop) ? prop.call(obj) : prop;
                    }
                    return obj;
                };
                var idCounter = 0;
                _.uniqueId = function(prefix) {
                    var id = ++idCounter + "";
                    return prefix ? prefix + id : id;
                };
                _.templateSettings = {
                    evaluate: /<%([\s\S]+?)%>/g,
                    interpolate: /<%=([\s\S]+?)%>/g,
                    escape: /<%-([\s\S]+?)%>/g
                };
                var noMatch = /(.)^/;
                var escapes = {
                    "'": "'",
                    "\\": "\\",
                    "\r": "r",
                    "\n": "n",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                };
                var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
                var escapeChar = function(match) {
                    return "\\" + escapes[match];
                };
                _.template = function(text, settings, oldSettings) {
                    if (!settings && oldSettings) settings = oldSettings;
                    settings = _.defaults({}, settings, _.templateSettings);
                    var matcher = RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g");
                    var index = 0;
                    var source = "__p+='";
                    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
                        source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
                        index = offset + match.length;
                        if (escape) {
                            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
                        } else if (interpolate) {
                            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
                        } else if (evaluate) {
                            source += "';\n" + evaluate + "\n__p+='";
                        }
                        return match;
                    });
                    source += "';\n";
                    if (!settings.variable) source = "with(obj||{}){\n" + source + "}\n";
                    source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
                    var render;
                    try {
                        render = new Function(settings.variable || "obj", "_", source);
                    } catch (e) {
                        e.source = source;
                        throw e;
                    }
                    var template = function(data) {
                        return render.call(this, data, _);
                    };
                    var argument = settings.variable || "obj";
                    template.source = "function(" + argument + "){\n" + source + "}";
                    return template;
                };
                _.chain = function(obj) {
                    var instance = _(obj);
                    instance._chain = true;
                    return instance;
                };
                var chainResult = function(instance, obj) {
                    return instance._chain ? _(obj).chain() : obj;
                };
                _.mixin = function(obj) {
                    _.each(_.functions(obj), function(name) {
                        var func = _[name] = obj[name];
                        _.prototype[name] = function() {
                            var args = [ this._wrapped ];
                            push.apply(args, arguments);
                            return chainResult(this, func.apply(_, args));
                        };
                    });
                    return _;
                };
                _.mixin(_);
                _.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
                    var method = ArrayProto[name];
                    _.prototype[name] = function() {
                        var obj = this._wrapped;
                        method.apply(obj, arguments);
                        if ((name === "shift" || name === "splice") && obj.length === 0) delete obj[0];
                        return chainResult(this, obj);
                    };
                });
                _.each([ "concat", "join", "slice" ], function(name) {
                    var method = ArrayProto[name];
                    _.prototype[name] = function() {
                        return chainResult(this, method.apply(this._wrapped, arguments));
                    };
                });
                _.prototype.value = function() {
                    return this._wrapped;
                };
                _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
                _.prototype.toString = function() {
                    return String(this._wrapped);
                };
                if (typeof define == "function" && define.amd) {
                    define("underscore", [], function() {
                        return _;
                    });
                }
            })();
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ]
}, {}, []);

require = function() {
    function r(e, n, t) {
        function o(i, f) {
            if (!n[i]) {
                if (!e[i]) {
                    var c = "function" == typeof require && require;
                    if (!f && c) return c(i, !0);
                    if (u) return u(i, !0);
                    var a = new Error("Cannot find module '" + i + "'");
                    throw a.code = "MODULE_NOT_FOUND", a;
                }
                var p = n[i] = {
                    exports: {}
                };
                e[i][0].call(p.exports, function(r) {
                    var n = e[i][1][r];
                    return o(n || r);
                }, p, p.exports, r, e, n, t);
            }
            return n[i].exports;
        }
        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
        return o;
    }
    return r;
}()({
    1: [ function(require, module, exports) {
        var AppDispatcher = require("../dispatcher/AppDispatcher");
        var TaskConstants = require("../constants/TaskConstants");
        var TaskActions = {
            recieveTaskData: function(data, storeId) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.RECIEVE_TASKDATA,
                    data: data,
                    storeId: storeId
                });
            },
            updateTaskData: function(keyIndex, indexName, val, storeId) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.UPDATE_TASKDATA,
                    key: keyIndex,
                    indexName: indexName,
                    value: val,
                    storeId: storeId
                });
            },
            getUpdatedJson: function(storeId) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.GET_UPDATED_JSON,
                    storeId: storeId
                });
            },
            changeViewMode: function(flag, storeId) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.CHANGE_VIEW_MODE,
                    flag: flag,
                    storeId: storeId
                });
            },
            manualSortData: function(data, storeId) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.MANUAL_SORT_DATA,
                    data: data,
                    storeId: storeId
                });
            },
            slideTaskAndCheckTitle: function(slideId, arrowId) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.CHECK_TASK_EMPTY_SLIDE,
                    slideId: slideId,
                    arrowId: arrowId
                });
            },
            tasksSortBy: function(sortBy, storeId) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.TASKS_SORT_BY,
                    sortBy: sortBy,
                    storeId: storeId
                });
            },
            tasksFilterBy: function(filterBy, storeId) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.TASKS_FILTER_BY,
                    filterBy: filterBy,
                    storeId: storeId
                });
            },
            slideTaskToggle: function(key, storeId, view) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.TASK_SLIDE_TOGGLE,
                    key: key,
                    storeId: storeId,
                    view: view
                });
            }
        };
        module.exports = TaskActions;
    }, {
        "../constants/TaskConstants": 10,
        "../dispatcher/AppDispatcher": 11
    } ],
    2: [ function(require, module, exports) {
        var AppDispatcher = require("../dispatcher/AppDispatcher");
        var TaskConstants = require("../constants/TaskConstants");
        var WritersActions = {
            setWriters: function(writers) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.SET_WRITERS,
                    writers: writers
                });
            },
            setFavWriters: function(favWriters, writers) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.SET_FAV_WRITERS,
                    favWriters: favWriters,
                    writers: writers
                });
            },
            updateWritersStore: function(writers, favWriters, value) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.UPDATE_WRITERS,
                    writers: writers,
                    favWriters: favWriters,
                    value: value
                });
            },
            updateFavWritersStore: function(writers, value) {
                AppDispatcher.handleAction({
                    actionType: TaskConstants.UPDATE_FAV_WRITERS,
                    writers: writers,
                    value: value
                });
            }
        };
        module.exports = WritersActions;
    }, {
        "../constants/TaskConstants": 10,
        "../dispatcher/AppDispatcher": 11
    } ],
    3: [ function(require, module, exports) {
        var React = require("react");
        var createReactClass = require("create-react-class");
        var ReactDOM = require("react-dom");
        var Chosen = createReactClass({
            displayName: "Chosen",
            chosenRenderd: false,
            componentDidUpdate: function() {
                $(ReactDOM.findDOMNode(this.refs.select)).trigger("chosen:updated");
            },
            handleChange: function(a, b, c) {
                this.forceUpdate();
                this.props.onChange && this.props.onChange(a, b, c);
            },
            componentDidMount: function() {
                var props = this.props;
                var select = $(ReactDOM.findDOMNode(this.refs.select));
                $(select).chosen({
                    allow_single_deselect: props.allowSingleDeselect,
                    disable_search: props.disableSearch,
                    disable_search_threshold: props.disableSearchThreshold,
                    enable_split_word_search: props.enableSplitWordSearch,
                    inherit_select_classes: props.inheritSelectClasses,
                    max_selected_options: props.maxSelectedOptions,
                    no_results_text: props.noResultsText,
                    placeholder_text_multiple: props.placeholderTextMultiple,
                    placeholder_text_single: props.placeholderTextSingle,
                    search_contains: props.searchContains,
                    single_backstroke_delete: props.singleBackstrokeDelete,
                    width: props.width,
                    display_disabled_options: props.displayDisabledOptions,
                    display_selected_options: props.displaySelectedOptions,
                    more_option_enabled: props.moreOption
                }).on("chosen:maxselected", this.props.onMaxSelected).change(this.handleChange);
            },
            componentWillUnmount: function() {
                $(ReactDOM.findDOMNode(this.refs.select)).off("chosen:maxselected change");
            },
            render: function() {
                var selectProps = $.extend({}, this.props, {
                    ref: "select"
                });
                delete selectProps.allowSingleDeselect;
                delete selectProps.disableSearch;
                delete selectProps.disableSearchThreshold;
                delete selectProps.enableSplitWordSearch;
                delete selectProps.inheritSelectClasses;
                delete selectProps.maxSelectedOptions;
                delete selectProps.noResultsText;
                delete selectProps.placeholderTextMultiple;
                delete selectProps.placeholderTextSingle;
                delete selectProps.searchContains;
                delete selectProps.singleBackstrokeDelete;
                delete selectProps.displayDisabledOptions;
                delete selectProps.displaySelectedOptions;
                delete selectProps.moreOption;
                delete selectProps.dataPlaceholder;
                return React.createElement("div", null, React.createElement("select", selectProps, this.props.children));
            }
        });
        module.exports = Chosen;
    }, {
        "create-react-class": 18,
        react: "react",
        "react-dom": "react-dom"
    } ],
    4: [ function(require, module, exports) {
        var React = require("react");
        var createReactClass = require("create-react-class");
        var ReactDOM = require("react-dom");
        var TaskStore = require("../stores/TaskStore");
        var TaskLists = require("./TaskLists.react");
        var TaskAPI = require("../utils/TaskAPI");
        var TaskActions = require("../actions/TaskActions");
        var WritersStore = require("../stores/WritersStore");
        var favWritersStore = require("../stores/favWritersStore");
        var Chosen = require("./ReactChosen.react");
        var isMobile = function() {
            try {
                document.createEvent("TouchEvent");
                return true;
            } catch (e) {
                return false;
            }
        };
        function getTasksState(storeId) {
            return TaskStore.getData(storeId);
        }
        function getWriters() {
            var writerss = WritersStore.getData();
            var uniqueWriters = [];
            var alreadyExists = false;
            if (writerss.map) {
                writerss.map(function(val) {
                    alreadyExists = false;
                    uniqueWriters.map(function(arrVal) {
                        if (arrVal.address == val.address) {
                            alreadyExists = true;
                        }
                    });
                    if (!alreadyExists) {
                        uniqueWriters.push(val);
                    }
                });
            }
            return uniqueWriters;
        }
        function getFavWriters() {
            return favWritersStore.getData();
        }
        var Progressbar = createReactClass({
            getInitialState: function() {
                return {
                    taskData: this.props.taskData
                };
            },
            shouldComponentUpdate: function(nextProps, nextState, nextContext) {
                return nextProps.taskData.updateComponent || nextState.taskData.updateComponent ? true : false;
            },
            render: function() {
                var totalTasks = this.state.taskData.taskables.length;
                var count = 0;
                var progress = 0;
                var divider = 0;
                var NLA = 0;
                var items = this.state.taskData.taskables;
                items.map(function(val) {
                    if (val.state == "Accepted") {
                        count++;
                    }
                    if (val.type == "DIVIDER") {
                        divider++;
                    }
                    if (val.state == "NoLongerApplicable" || val.taskState && val.taskState == "NoLongerApplicable") {
                        NLA++;
                    }
                });
                totalTasks = totalTasks - divider - NLA;
                if (count == 0 && totalTasks == 0) {
                    progress = 0;
                } else {
                    progress = count / totalTasks * 100;
                }
                var progressBar = "";
                if (this.props.isDiffMode) {
                    var otherCount = this.state.taskData.otherStats.accepted;
                    var otherTotal = this.state.taskData.otherStats.total;
                    var otherProgress = otherCount / otherTotal * 100;
                    var baseCount = this.state.taskData.baseStats.accepted;
                    var baseTotal = this.state.taskData.baseStats.total;
                    var baseProgress = baseCount / baseTotal * 100;
                    if (otherCount == baseCount && otherTotal == baseTotal) {
                        progressBar = React.createElement("div", {
                            className: "progressbar_block progressbar-grn"
                        }, React.createElement("div", {
                            className: "progressbar ui-progressbar ui-widget ui-widget-content ui-corner-all"
                        }, React.createElement("div", {
                            className: "ui-progressbar-value ui-widget-header ui-corner-left",
                            style: {
                                width: otherProgress + "%"
                            }
                        })), React.createElement("p", {
                            className: "progressbar_status"
                        }, otherCount + " / " + otherTotal));
                    } else {
                        progressBar = React.createElement("div", {
                            className: "row"
                        }, React.createElement("div", {
                            className: "progressbar_block progressbar-grn col-md-8",
                            style: {
                                marginLeft: "-5px",
                                marginRight: "5px"
                            }
                        }, React.createElement("div", {
                            className: "progressbar ui-progressbar ui-widget ui-widget-content ui-corner-all"
                        }, React.createElement("div", {
                            className: "ui-progressbar-value ui-widget-header ui-corner-left",
                            style: {
                                width: otherProgress + "%"
                            }
                        })), React.createElement("p", {
                            className: "progressbar_status"
                        }, this.props.diffVersion1 && this.props.diffVersion2 ? React.createElement("span", {
                            className: "diffVersion"
                        }, "V", this.props.diffVersion1, " ") : null, otherCount + " / " + otherTotal)), React.createElement("div", {
                            className: "progressbar_block progressbar-orange col-md-4"
                        }, React.createElement("div", {
                            className: "progressbar ui-progressbar ui-widget ui-widget-content ui-corner-all"
                        }, React.createElement("div", {
                            className: "ui-progressbar-value ui-widget-header ui-corner-left",
                            style: {
                                width: baseProgress + "%"
                            }
                        })), React.createElement("p", {
                            className: "progressbar_status"
                        }, this.props.diffVersion1 && this.props.diffVersion2 ? React.createElement("span", {
                            className: "diffVersion",
                            title: "('baseline' state was [" + baseCount + " of " + baseTotal + "])"
                        }, "V", this.props.diffVersion2, " ") : null, baseCount + " / " + baseTotal)));
                    }
                } else {
                    progressBar = React.createElement("div", {
                        className: "progressbar_block progressbar-grn"
                    }, React.createElement("div", {
                        className: "progressbar ui-progressbar ui-widget ui-widget-content ui-corner-all"
                    }, React.createElement("div", {
                        className: "ui-progressbar-value ui-widget-header ui-corner-left",
                        style: {
                            width: progress + "%"
                        }
                    })), React.createElement("p", {
                        className: "progressbar_status"
                    }, count + " / " + totalTasks));
                }
                return React.createElement("div", null, progressBar);
            }
        });
        var SortTasks = createReactClass({
            delayHandleEvents: function(obj) {
                var sortBy = obj.targetValue;
                var divId = obj.divId;
                var storeId = obj.storeId;
                TaskActions.tasksSortBy(sortBy, storeId);
                if (sortBy != "manual" && sortBy != "" || this.props.filterBy != "all") {
                    if ($("#accordion-" + divId).is(".ui-sortable")) {
                        $("#accordion-" + divId).sortable("destroy");
                        $("#add-task-panel").parent("div").addClass("hideTaskBtn");
                    }
                } else {
                    if (!$("#accordion-" + divId).is(".ui-sortable")) {
                        $("#add-task-panel").parent("div").removeClass("hideTaskBtn");
                        var firstList = $("#accordion-" + divId);
                        firstList.sortable({
                            connectWith: ".connectedSortable",
                            cancel: "div.impBackgroundFFF",
                            scroll: true,
                            scrollSensitivity: 100,
                            scrollSpeed: 30,
                            start: function(event, ui) {
                                ui.placeholder.height(ui.helper[0].scrollHeight);
                            },
                            stop: function(event, ui) {
                                TaskActions.manualSortData($("#accordion-" + divId).sortable("toArray"), storeId);
                            },
                            cursor: "move",
                            placeholder: "ui-state-highlight"
                        });
                    }
                }
            },
            handleChange: function(event) {
                var obj = {
                    targetValue: event.target.value,
                    divId: this.props.divId,
                    storeId: this.props.storeId
                };
                setTimeout(this.delayHandleEvents.bind(this, obj), 500);
                $("#sorting").show().focus();
            },
            handleClick: function(event) {
                if (this.props.sortBy && this.props.sortBy == event.target.value) {
                    return;
                } else {
                    var obj = {
                        targetValue: event.target.value,
                        divId: this.props.divId,
                        storeId: this.props.storeId
                    };
                    setTimeout(this.delayHandleEvents.bind(this, obj), 500);
                    $("#sorting").show().focus();
                }
            },
            shouldComponentUpdate: function(nextProps, nextState, nextContext) {
                return nextProps.sortBy != this.props.sortBy;
            },
            render: function() {
                if (this.props.isChecklist) {
                    return React.createElement("div", null, React.createElement("span", {
                        style: {
                            marginRight: "10px",
                            float: "left"
                        }
                    }, "Sort By"), React.createElement(Chosen, {
                        name: "custom-sort-by",
                        className: "chosen-select chosen-select-custom",
                        defaultValue: this.props.sortBy,
                        onChange: this.handleChange,
                        onClick: this.handleClick,
                        key: "select-" + this.props.sortBy,
                        disableSearch: true,
                        inheritSelectClasses: true
                    }, React.createElement("option", {
                        value: "manual"
                    }, "Manual"), React.createElement("option", {
                        value: "taskNumber"
                    }, "Task #"), React.createElement("option", {
                        value: "priority"
                    }, "Priority")));
                }
                if (this.props.isDiffMode) {
                    return React.createElement("div", null, React.createElement("span", {
                        style: {
                            marginRight: "10px",
                            float: "left"
                        }
                    }, "Sort By"), React.createElement(Chosen, {
                        name: "custom-sort-by",
                        className: "chosen-select chosen-select-custom",
                        defaultValue: this.props.sortBy,
                        onChange: this.handleChange,
                        onClick: this.handleClick,
                        key: "select-" + this.props.sortBy,
                        disableSearch: true,
                        inheritSelectClasses: true
                    }, React.createElement("option", {
                        value: "state"
                    }, "State"), React.createElement("option", {
                        value: "taskNumber"
                    }, "Task #"), React.createElement("option", {
                        value: "priority"
                    }, "Priority")));
                } else {
                    return React.createElement("div", null, React.createElement("span", {
                        style: {
                            marginRight: "10px",
                            float: "left"
                        }
                    }, "Sort By"), React.createElement(Chosen, {
                        name: "custom-sort-by",
                        className: "chosen-select chosen-select-custom",
                        defaultValue: this.props.sortBy,
                        onChange: this.handleChange,
                        onClick: this.handleClick,
                        key: "select-" + this.props.sortBy,
                        disableSearch: true,
                        inheritSelectClasses: true
                    }, React.createElement("option", {
                        value: "manual"
                    }, "Manual"), React.createElement("option", {
                        value: "state"
                    }, "State"), React.createElement("option", {
                        value: "taskNumber"
                    }, "Task #"), React.createElement("option", {
                        value: "priority"
                    }, "Priority")));
                }
            }
        });
        var ShowOpenTaskToggle = createReactClass({
            stateChange: false,
            handleChange: function(event) {
                var divId = this.props.divId;
                var storeId = this.props.storeId;
                var filterBy = "all";
                if (event.target.checked) {
                    if ($("#accordion-" + divId).is(".ui-sortable")) {
                        $("#accordion-" + divId).sortable("destroy");
                        $("#add-task-panel").parent("div").addClass("hideTaskBtn");
                    }
                    filterBy = "openTasks";
                } else {
                    if (this.props.sortBy == "manual" && (this.props.mode == "edit" || this.props.mode == "template")) {
                        $("#add-task-panel").parent("div").removeClass("hideTaskBtn");
                        var firstList = $("#accordion-" + divId);
                        firstList.sortable({
                            connectWith: ".connectedSortable",
                            cancel: "div.impBackgroundFFF",
                            scroll: true,
                            scrollSensitivity: 100,
                            scrollSpeed: 30,
                            start: function(event, ui) {
                                ui.placeholder.height(ui.helper[0].scrollHeight);
                            },
                            stop: function(event, ui) {
                                TaskActions.manualSortData($("#accordion-" + divId).sortable("toArray"), storeId);
                            },
                            cursor: "move",
                            placeholder: "ui-state-highlight"
                        });
                    }
                    filterBy = "all";
                }
                TaskActions.tasksFilterBy(filterBy, storeId);
                this.stateChange = true;
            },
            componentDidMount: function() {
                var me = this;
                setTimeout(function() {
                    if (me.props.filterBy == "openTasks") {
                        $("#hide-tasks").trigger("click").prop("checked", true);
                    }
                }, 1e3);
            },
            shouldComponentUpdate: function(nextProps, nextState, nextContext) {
                if (this.props.items.length > 1 && ReactDOM.findDOMNode(this.refs.hideTasks).disabled) {
                    return true;
                }
                if (this.stateChange) {
                    return true;
                }
                return false;
            },
            render: function() {
                var disabled = false;
                var hasModifiedTasks = false;
                if (this.props.items.length <= 0) {
                    return null;
                } else {
                    return React.createElement("div", {
                        style: {
                            width: "146px"
                        }
                    }, React.createElement("input", {
                        type: "checkbox",
                        id: "hide-tasks",
                        name: "hide-tasks",
                        onChange: this.handleChange,
                        disabled: disabled,
                        ref: "hideTasks"
                    }), " Show only open tasks");
                }
            }
        });
        var TaskApp = createReactClass({
            getInitialState: function() {
                var writers = getWriters();
                var favWriters = getFavWriters();
                var currentUser = this.props.currentUser;
                var allWriters = [];
                if (Object.keys(writers).length > 0) {
                    var currentUserExists = false;
                    writers.map(function(val, key) {
                        var deletetdIndex = allWriters.map(function(e) {
                            return e.address;
                        }).indexOf(val.address);
                        if (deletetdIndex == -1 && val.address.indexOf("@") == -1) {
                            allWriters.push(val);
                        }
                        if (val.address == currentUser.address) {
                            currentUserExists = true;
                        }
                    });
                }
                if (!currentUserExists) {
                    var deletetdIndex = allWriters.map(function(e) {
                        return e.address;
                    }).indexOf(currentUser.address);
                    if (deletetdIndex == -1) {
                        allWriters.push(currentUser);
                    }
                }
                if (Object.keys(favWriters).length > 0) {
                    favWriters.map(function(val, key) {
                        if (val.address != currentUser.address && val.address.indexOf("@") == -1) {
                            var deletetdIndex = allWriters.map(function(e) {
                                return e.address;
                            }).indexOf(val.address);
                            if (deletetdIndex == -1) {
                                allWriters.push(val);
                            }
                        }
                    });
                }
                return {
                    allWriters: allWriters,
                    currentUser: currentUser,
                    divId: this.props.divId,
                    hideHeader: this.props.hideHeader,
                    expandTask: this.props.expandTask,
                    favWriters: getFavWriters(),
                    isChecklist: this.props.isChecklist,
                    isDiffMode: this.props.isDiffMode,
                    storeId: this.props.storeId,
                    taskData: getTasksState(this.props.storeId),
                    taskNum: this.props.taskNum,
                    writers: getWriters()
                };
            },
            componentDidMount: function() {
                var storeId = this.state.storeId;
                var divId = this.state.divId;
                var me = this;
                $("#" + divId).mouseup(function(e) {
                    var container = $(".more-options-select.store" + storeId);
                    if (container.length > 0) {
                        if (!container.is(e.target) && container.has(e.target).length === 0) {
                            container.hide();
                        }
                    }
                });
                if ($("#" + divId).hasClass(".task-auto-scroll")) {
                    $("#" + divId).removeClass("task-scroll");
                }
                $("#" + divId).addClass("tasklist-outter-box");
                $("#" + divId).addClass("task-scroll");
                if (me.state.taskNum) {
                    var indexNumber = -1;
                    me.state.taskData.taskables.map(function(val, key) {
                        if (val.taskNumber == me.state.taskNum) {
                            indexNumber = val.index ? val.index : key;
                            return;
                        }
                    });
                    var myContainer = $("#" + me.props.divId);
                    var scrollTo = $("#sort_" + indexNumber);
                    if (myContainer && myContainer.length > 0 && scrollTo.offset()) {
                        myContainer.animate({
                            scrollTop: scrollTo.offset().top - myContainer.offset().top + myContainer.scrollTop()
                        }, 600);
                    }
                    var el = $("#sort_" + indexNumber + " textarea.autoAdjust");
                    var val = "";
                    var outterDivHeight = 0;
                    el.map(function(val, key) {
                        val = $(this).val().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br/>").replace(/\s/g, "&nbsp;");
                        $(this).parent().find(".hiddenDivTextarea")[0].innerHTML = val;
                        outterDivHeight = $(this).parent().find(".hiddenDivTextarea").outerHeight() < 40 ? 39 : $(this).parent().find(".hiddenDivTextarea").outerHeight();
                        $(this)[0].style.height = outterDivHeight + "px";
                    });
                }
                TaskStore.addChangeListener(this._onChange);
            },
            componentWillUnmount: function() {
                $("#" + this.state.divId).unbind("mouseup");
                $(document).unbind("mouseup");
                if ($("#accordion-" + this.state.divId).is(".ui-sortable")) {
                    $("#accordion-" + this.state.divId).sortable("destroy");
                }
                TaskStore.removeChangeListener(this._onChange);
            },
            render: function() {
                var taskData = this.state.taskData;
                var mode = taskData.mode == "read" ? "sortByState-disable readable" : "sortByState-disable editable";
                var taskLength = this.state.taskData.taskables.length;
                var writersCount = 0;
                var me = this;
                var currentUser = this.state.currentUser;
                var taskNum = taskData.taskNum ? taskData.taskNum : this.state.taskNum;
                var storeId = this.state.storeId;
                var existCurrentUser = false;
                if (!taskData.isChecklist && taskData.mode == "template") {
                    return React.createElement("div", {
                        className: "container tasklist editable template-task-list-outter"
                    }, React.createElement("div", {
                        className: "row"
                    }, React.createElement("div", {
                        className: "col-md-12 header-outter-div",
                        style: {
                            position: "inherit"
                        }
                    }, React.createElement(TaskAddComp, {
                        items: this.state.taskData.taskables,
                        storeId: storeId,
                        currentUserAdress: currentUser.address
                    })), React.createElement("div", {
                        className: "col-md-12 template-tasks-message"
                    }, "A Task List created in a Template cannot have tasks added. Tasks can be added in any Instance created from this Template. If you want to add Tasks in a Template, use a Checklist instead")));
                }
                if (taskData.additionalActors) {
                    taskData.additionalActors.map(function(val, key) {
                        if (me.state.writers && me.state.writers.map) {
                            me.state.writers.map(function(writer, wkey) {
                                if (writer.address == val) {
                                    writersCount++;
                                }
                                if (writer.address == currentUser.address) {
                                    existCurrentUser = true;
                                }
                            });
                        }
                    });
                    taskData.additionalActors.map(function(val, key) {
                        if (me.state.favWriters) {
                            me.state.favWriters.map(function(writer, wkey) {
                                if (writer.address == val) {
                                    writersCount++;
                                }
                                if (writer.address == currentUser.address) {
                                    existCurrentUser = true;
                                }
                            });
                        }
                    });
                    if (!existCurrentUser) {
                        taskData.additionalActors.map(function(val, key) {
                            if (val == currentUser.address) {
                                writersCount++;
                            }
                        });
                    }
                }
                var noTaskHtml = "";
                if (taskLength <= 0) {
                    noTaskHtml = taskData.mode == "read" ? React.createElement("div", {
                        className: "noTask noTaskRead"
                    }, React.createElement("h3", null, "No tasks")) : React.createElement("div", {
                        className: "noTask"
                    }, React.createElement("h3", null, "No task added"));
                }
                var writersMissing = taskData.additionalActors && taskData.additionalActors.length > writersCount && taskData.taskables.length > 0 ? "Some writers have been removed..." : " ";
                var taskHtml = null;
                switch (taskData.mode) {
                  case "read":
                  case "readSort":
                    if (taskLength > 0 && this.state.hideHeader !== true) {
                        taskHtml = React.createElement("div", {
                            className: "col-md-12 header-outter-div"
                        }, React.createElement("div", {
                            className: "row"
                        }, React.createElement("div", {
                            className: "col-md-12 custom-sort"
                        }, React.createElement(Progressbar, {
                            taskData: taskData,
                            storeId: storeId,
                            isDiffMode: this.state.isDiffMode,
                            diffVersion1: this.props.diffVersion1,
                            diffVersion2: this.props.diffVersion2
                        }))), React.createElement("div", {
                            className: "row"
                        }, React.createElement("div", {
                            className: "col-md-4 custom-sort",
                            style: {
                                width: "30%"
                            }
                        }, !taskData.isChecklist ? React.createElement(SortTasks, {
                            storeId: storeId,
                            divId: this.state.divId,
                            isDiffMode: this.state.isDiffMode,
                            sortBy: this.state.taskData.sortBy ? this.state.taskData.sortBy : this.state.isDiffMode ? "state" : "priority"
                        }) : null), React.createElement("div", {
                            className: "col-md-4",
                            style: {
                                width: "28%",
                                paddingTop: "5px"
                            }
                        }, React.createElement("div", {
                            id: "sorting",
                            style: {
                                display: "none"
                            },
                            className: "sortMessage",
                            key: this.state.taskData.sortBy
                        }, "Sorting...")), React.createElement("div", {
                            className: "col-md-4 custom-sort",
                            style: {
                                width: "41%",
                                float: "right"
                            }
                        }, React.createElement("div", {
                            style: {
                                float: "right"
                            }
                        }, !taskData.isChecklist ? this.state.isDiffMode ? React.createElement(FilterTasks, {
                            filterBy: this.state.taskData.filterBy ? this.state.taskData.filterBy : "changedTasks",
                            mode: this.state.taskData.mode,
                            storeId: storeId,
                            divId: this.state.divId,
                            isDiffMode: this.state.isDiffMode
                        }) : React.createElement(ShowOpenTaskToggle, {
                            filterBy: this.state.taskData.filterBy ? this.state.taskData.filterBy : "all",
                            mode: this.state.taskData.mode,
                            storeId: storeId,
                            divId: this.state.divId,
                            sortBy: this.state.taskData.sortBy ? this.state.taskData.sortBy : "priority",
                            items: this.state.taskData.taskables
                        }) : null))), typeof this.state.taskData.wereTasksReordered != "undefined" && this.state.taskData.wereTasksReordered ? React.createElement("div", {
                            className: "row"
                        }, React.createElement("div", {
                            className: "taskReorder"
                        }, "Tasks were reordered"), " ") : null);
                    } else {}
                    break;
                }
                if (this.state.hideHeader) {
                    var clonedTasks = JSON.parse(JSON.stringify(taskData));
                    var taskSelectedIndex = clonedTasks.taskables[0].index;
                    taskData.toggleTaskIndex = taskSelectedIndex != undefined ? taskSelectedIndex : 0;
                    taskData.slideTask = true;
                }
                if (this.state.expandTask || taskData.expandTask) {
                    var tt = taskData.expandTask ? 1e3 : 0;
                    this.state.expandTask = false;
                    taskData.expandTask = false;
                    var clonedTasks = JSON.parse(JSON.stringify(taskData));
                    var taskSelectedIndex = -1;
                    clonedTasks.taskables.map(function(val, key) {
                        if (val.taskNumber == taskNum) {
                            taskSelectedIndex = val.index ? val.index : key;
                            return;
                        }
                    });
                    setTimeout(function() {
                        if (taskSelectedIndex != -1) TaskActions.slideTaskToggle(taskSelectedIndex, storeId, true);
                    }, tt);
                }
                return React.createElement("div", {
                    style: {
                        width: "inherit",
                        height: "inherit",
                        position: "inherit"
                    }
                }, React.createElement("div", {
                    className: (taskData.mode == "read" || taskData.mode == "readSort" ? "readable" : "editable") + " container tasklist" + (taskData.mode == "template" ? " templateMode" : "")
                }, taskHtml, React.createElement("div", {
                    className: "clearfix"
                }), taskData.mode == "template" && taskLength > 0 ? React.createElement("div", {
                    className: "template-note"
                }, "[Note: In a Template, Tasks cannot be started or have a requester set or have assignees added]") : null, React.createElement("div", {
                    id: "sorting-content",
                    className: mode
                }, noTaskHtml, React.createElement(TaskLists, {
                    taskData: taskData,
                    writers: this.state.writers,
                    favWriters: this.state.favWriters,
                    allWriters: this.state.allWriters,
                    currentUser: this.state.currentUser,
                    divId: this.state.divId,
                    taskNum: taskNum,
                    storeId: storeId,
                    isChecklist: this.state.isChecklist
                }))));
            },
            _onChange: function() {
                this.setState({
                    taskData: getTasksState(this.state.storeId)
                });
            }
        });
        module.exports = TaskApp;
    }, {
        "../actions/TaskActions": 1,
        "../stores/TaskStore": 12,
        "../stores/WritersStore": 13,
        "../stores/favWritersStore": 14,
        "../utils/TaskAPI": 15,
        "./ReactChosen.react": 3,
        "./TaskLists.react": 6,
        "create-react-class": 18,
        react: "react",
        "react-dom": "react-dom"
    } ],
    5: [ function(require, module, exports) {
        var React = require("react");
        var createReactClass = require("create-react-class");
        var TaskActions = require("../actions/TaskActions");
        var TaskStore = require("../stores/TaskStore");
        var TaskCollapseArrow = createReactClass({
            getInitialState: function() {
                return {
                    items: this.props.items,
                    store: this.props.storeId
                };
            },
            handleClick: function(event) {
                event.preventDefault();
                var me = this;
                var e = "#" + this.props.divId + "_collapse_" + this.props.mode + this.props.items.index;
                var arrowId = "#" + this.props.divId + "-arrow-" + this.props.mode + this.props.items.index;
                if (!$(e).hasClass("in")) {
                    TaskActions.slideTaskToggle(this.props.items.index, this.props.storeId, true);
                } else {
                    var jsonData = TaskStore.getData(this.props.storeId);
                    if (jsonData.taskables[this.props.keyVal].isTitleEmpty) {
                        $.alert.open({
                            type: "error",
                            content: "Please enter a task title.",
                            callback: function() {
                                $("#task-title-" + me.props.items.index).focus();
                            }
                        });
                    } else {
                        TaskActions.slideTaskToggle(this.props.items.index, this.props.storeId, false);
                    }
                }
            },
            render: function() {
                var me = this;
                var iconClassName = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "glyphicon glyphicon-chevron-down collapse-i" : "glyphicon glyphicon-chevron-right collapse-i";
                return React.createElement("div", {
                    className: "arrow-icon-outter"
                }, React.createElement("a", {
                    "data-toggle": "collapse",
                    "data-parent": "#accordion",
                    href: "#" + this.props.divId + "_collapse_" + this.props.mode + this.props.items.index,
                    onClick: this.handleClick
                }, React.createElement("i", {
                    name: "toggle-tasks-" + this.props.items.index,
                    className: iconClassName,
                    id: this.props.divId + "-arrow-" + this.props.mode + this.props.items.index
                })));
            }
        });
        module.exports = TaskCollapseArrow;
    }, {
        "../actions/TaskActions": 1,
        "../stores/TaskStore": 12,
        "create-react-class": 18,
        react: "react"
    } ],
    6: [ function(require, module, exports) {
        var React = require("react");
        var createReactClass = require("create-react-class");
        var TaskListsComp = require("./TaskListsComp.react");
        var TaskStore = require("../stores/TaskStore");
        var TaskActions = require("../actions/TaskActions");
        var isMobile = function() {
            try {
                document.createEvent("TouchEvent");
                return true;
            } catch (e) {
                return false;
            }
        };
        var TaskLists = createReactClass({
            getInitialState: function() {
                return {
                    allWriters: this.props.allWriters,
                    currentUser: this.props.currentUser,
                    divId: this.props.divId,
                    favWriters: this.props.favWriters,
                    isChecklist: this.props.isChecklist,
                    storeId: this.props.storeId,
                    taskData: this.props.taskData,
                    taskNum: this.props.taskNum,
                    writers: this.props.writers
                };
            },
            componentDidMount: function() {
                var thiss = this;
                var storeId = this.state.storeId;
                var divId = this.state.divId;
                var arr = [];
                var isOpenInMobile = isMobile();
                var slideDivs = function(me, viewMode) {
                    $(me).parent().parent().parent().parent().find("textarea.autoAdjust").each(function() {
                        if (viewMode) $(this).prop("readonly", true);
                        var this1 = this;
                        setTimeout(function() {
                            adjustHeight(this1);
                        }, 300);
                    });
                };
                if (this.state.writers) {
                    arr = $.merge(arr, this.state.writers);
                }
                if (this.state.favWriters) {
                    arr = $.merge(arr, this.state.favWriters);
                }
                if (this.state.currentUser) {
                    arr = $.merge(arr, this.state.currentUser);
                }
                var uniqueVals = [];
                $.each(arr, function(i, el) {
                    if ($.inArray(el, uniqueVals) === -1) uniqueVals.push(el);
                });
                if (uniqueVals && uniqueVals.length > 0) {
                    uniqueVals.map(function(val, key) {
                        var imgPath = "";
                        if (val.type == "role" && typeof val.profileImageUri == "undefined") {
                            if (isOpenInMobile) imgPath = "./role_human.jpg"; else imgPath = "/main/images/role_human.jpg";
                        } else {
                            if (val.profileImageUri && val.profileImageUri != "") {
                                imgPath = val.profileImageUri;
                            } else {
                                if (isOpenInMobile) imgPath = "./no_image.jpg"; else imgPath = "/main/images/no_image.jpg";
                            }
                        }
                        var hoverHTML = '<img src="' + imgPath + '" class="hc-pic" />' + '<p class="hc-p">' + (val.name != "" ? "<b>" + val.name + "</b><br>" : "") + val.address + "</p>";
                        $("div[data-title-assignee='" + val.address + "'], span[data-title-assignee='" + val.address + "'], div[data-title-requester='" + val.address + "'], span[data-title-requester='" + val.address + "']").hovercard({
                            detailsHTML: hoverHTML,
                            width: "250",
                            openOnLeft: true
                        });
                    });
                }
                $("#" + divId + ' a[data-toggle="collapse"]').on("click", function(e) {
                    e.preventDefault();
                    var me = $(this);
                    slideDivs(me, true);
                });
                $("span[data-title='disabled-button']").unbind("click");
                $("span[data-title='disabled-button']").hovercard({
                    detailsHTML: "The Task List needs to be in update mode in order to perform this action.",
                    width: "250",
                    openOnLeft: true
                });
                $("span[data-title='disabled-button']").bind("click");
                $("#" + divId).on("keyup", "textarea.autoAdjust", function() {
                    var this2 = this;
                    setTimeout(function() {
                        adjustHeight(this2);
                    }, 300);
                });
                function adjustHeight(el) {
                    var val = el.value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br/>").replace(/\s/g, "&nbsp;");
                    $(el).parent().find(".hiddenDivTextarea")[0].innerHTML = val;
                    if (thiss.state.taskData.mode == "edit" || thiss.state.taskData.mode == "template") {
                        var outterDivHeight = $(el).parent().find(".hiddenDivTextarea").outerHeight() < 41 ? 40 : $(el).parent().find(".hiddenDivTextarea").outerHeight();
                    } else {
                        var outterDivHeight = $(el).parent().find(".hiddenDivTextarea").outerHeight() < 40 ? 39 : $(el).parent().find(".hiddenDivTextarea").outerHeight();
                    }
                    el.style.height = outterDivHeight + "px";
                }
            },
            componentDidUpdate: function() {
                $("span[data-title='disabled-button']").unbind("click");
                $("span[data-title='disabled-button']").hovercard({
                    detailsHTML: "The Task List needs to be in update mode in order to perform this action.",
                    width: "250",
                    openOnLeft: true
                });
                $("span[data-title='disabled-button']").bind("click");
                $("textarea.autoAdjust").each(function() {
                    var this1 = this;
                    setTimeout(function() {
                        adjustHeight(this1);
                    }, 300);
                });
                function adjustHeight(el) {
                    var val = el.value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br/>").replace(/\s/g, "&nbsp;");
                    $(el).parent().find(".hiddenDivTextarea")[0].innerHTML = val;
                    var outterDivHeight = $(el).parent().find(".hiddenDivTextarea").outerHeight() < 40 ? 39 : $(el).parent().find(".hiddenDivTextarea").outerHeight();
                    el.style.height = outterDivHeight + "px";
                }
            },
            render: function() {
                var mode = this.state.taskData.mode;
                var data = this.props.taskData.taskables;
                var allWriters = this.state.allWriters;
                var writers = this.state.writers;
                var favWriters = this.state.favWriters;
                var currentUser = this.state.currentUser;
                var divId = this.state.divId;
                var taskNum = this.state.taskNum;
                var storeId = this.state.storeId;
                var sortBy = this.state.taskData.sortBy ? this.state.taskData.sortBy : "priority";
                var isChecklist = this.state.isChecklist;
                var slideTask = this.state.taskData.slideTask == undefined ? this.props.taskData.slideTask : this.state.taskData.slideTask;
                var toggleTaskIndex = this.state.taskData.toggleTaskIndex == undefined ? this.props.taskData.toggleTaskIndex : this.state.taskData.toggleTaskIndex;
                if (sortBy == "state") {
                    var obj = {
                        accepted: [],
                        delivered: [],
                        finished: [],
                        restart: [],
                        started: [],
                        unstarted: [],
                        noLonger: [],
                        newlyAdded: [],
                        open: [],
                        newItems: []
                    };
                    var taskNumber = [];
                    data.map(function(val) {
                        if (val.type != "DIVIDER") {
                            val.state = val.state ? val.state : val.taskState;
                            val.priority = val.priority ? val.priority : "NoPrioritySet";
                            if (val.newItem) {
                                obj["newItems"].push(val);
                            } else {
                                var fields = val.taskNumber.toString().split(/_/);
                                if (fields[1]) {
                                    obj["newlyAdded"].push(val);
                                } else {
                                    if (val.state == "Accepted") {
                                        obj["accepted"].push(val);
                                    } else if (val.state == "Delivered") {
                                        obj["delivered"].push(val);
                                    } else if (val.state == "Finished") {
                                        obj["finished"].push(val);
                                    } else if (val.state == "Rejected") {
                                        obj["restart"].push(val);
                                    } else if (val.state == "Started") {
                                        obj["started"].push(val);
                                    } else if (val.state == "Unstarted") {
                                        obj["unstarted"].push(val);
                                    } else if (val.state == "NoLongerApplicable") {
                                        obj["noLonger"].push(val);
                                    } else {
                                        obj["open"].push(val);
                                    }
                                }
                            }
                        }
                    });
                    data = [];
                    if (typeof obj.accepted != "undefined" && obj.accepted.length > 0) {
                        $.merge(data, obj.accepted);
                    }
                    if (typeof obj.delivered != "undefined" && obj.delivered.length > 0) {
                        $.merge(data, obj.delivered);
                    }
                    if (typeof obj.finished != "undefined" && obj.finished.length > 0) {
                        $.merge(data, obj.finished);
                    }
                    if (typeof obj.restart != "undefined" && obj.restart.length > 0) {
                        $.merge(data, obj.restart);
                    }
                    if (typeof obj.started != "undefined" && obj.started.length > 0) {
                        $.merge(data, obj.started);
                    }
                    if (typeof obj.unstarted != "undefined" && obj.unstarted.length > 0) {
                        $.merge(data, obj.unstarted);
                    }
                    if (typeof obj.noLonger != "undefined" && obj.noLonger.length > 0) {
                        $.merge(data, obj.noLonger);
                    }
                    if (typeof obj.newlyAdded != "undefined" && obj.newlyAdded.length > 0) {
                        taskNumberOrder = [];
                        obj.newlyAdded.map(function(val, key) {
                            var fields = val.taskNumber.toString().split(/_/);
                            taskNumberOrder.push(fields[1]);
                        });
                        taskNumberOrder.sort(function(a, b) {
                            return a - b;
                        });
                        taskNumberOrder.map(function(taskNumber, taskNumberkey) {
                            obj.newlyAdded.map(function(val, key) {
                                if ("New_" + taskNumber == val.taskNumber) {
                                    data.push(val);
                                }
                            });
                        });
                    }
                    $.merge(data, obj.newItems);
                } else if (sortBy == "priority") {
                    var obj = {
                        high: [],
                        medium: [],
                        low: [],
                        noPriority: []
                    };
                    var taskNumber = [];
                    data.map(function(val) {
                        if (val.type != "DIVIDER") {
                            val.priority = val.priority ? val.priority : val.taskPriority;
                            if (val.priority == "High") {
                                obj["high"].push(val);
                            } else if (val.priority == "Medium") {
                                obj["medium"].push(val);
                            } else if (val.priority == "Low") {
                                obj["low"].push(val);
                            } else {
                                obj["noPriority"].push(val);
                            }
                        }
                    });
                    data = [];
                    if (typeof obj.high != "undefined" && obj.high.length > 0) {
                        $.merge(data, obj.high);
                    }
                    if (typeof obj.medium != "undefined" && obj.medium.length > 0) {
                        $.merge(data, obj.medium);
                    }
                    if (typeof obj.low != "undefined" && obj.low.length > 0) {
                        $.merge(data, obj.low);
                    }
                    if (typeof obj.noPriority != "undefined" && obj.noPriority.length > 0) {
                        $.merge(data, obj.noPriority);
                    }
                } else if (sortBy == "taskNumber") {
                    var taskNumberOrder = [];
                    var newlyAdded = [];
                    var newItems = [];
                    var newData = [];
                    data.map(function(val, key) {
                        if (val.type != "DIVIDER") {
                            val.state = val.state ? val.state : val.taskState;
                            val.priority = val.priority ? val.priority : "NoPrioritySet";
                            if (!val.newItem) {
                                var fields = val.taskNumber.toString().split(/_/);
                                if (fields[0] && fields[0] != "New") {
                                    taskNumberOrder.push(val.taskNumber);
                                } else {
                                    newlyAdded.push(val);
                                }
                            } else {
                                newItems.push(val);
                            }
                        }
                    });
                    taskNumberOrder.sort(function(a, b) {
                        return a - b;
                    });
                    taskNumberOrder.map(function(taskNumber, taskNumberkey) {
                        data.map(function(val, key) {
                            if (taskNumber == val.taskNumber) {
                                newData.push(val);
                            }
                        });
                    });
                    data = newData;
                    if (newlyAdded.length > 0) {
                        taskNumberOrder = [];
                        newlyAdded.map(function(val, key) {
                            var fields = val.taskNumber.toString().split(/_/);
                            taskNumberOrder.push(fields[1]);
                        });
                        taskNumberOrder.sort(function(a, b) {
                            return a - b;
                        });
                        taskNumberOrder.map(function(taskNumber, taskNumberkey) {
                            newlyAdded.map(function(val, key) {
                                if ("New_" + taskNumber == val.taskNumber) {
                                    data.push(val);
                                }
                            });
                        });
                    }
                    if (newItems.length > 0) {
                        $.merge(data, newItems);
                    }
                }
                if (this.state.taskData.filterBy) {
                    if (this.state.taskData.filterBy == "changedTasks") {
                        var obj = [];
                        data.map(function(val) {
                            if (val.diffOpType && (val.diffOpType == "MODIFIED" || val.diffOpType == "NEW" || val.diffOpType == "DELETED")) {
                                obj.push(val);
                            }
                        });
                        data = obj;
                    } else if (this.state.taskData.filterBy == "openTasks") {
                        var obj = [];
                        data.map(function(val) {
                            if (typeof val.state != "undefined" && val.state != "Accepted" && val.state != "NoLongerApplicable" || typeof val.taskState != "undefined" && val.taskState != "Accepted" && val.taskState != "NoLongerApplicable") {
                                obj.push(val);
                            } else if (sortBy == "manual" && mode == "read" && val.taskType && val.taskType == "DIVIDER") {
                                obj.push(val);
                            }
                        });
                        data = obj;
                    }
                }
                var tasksLength = 0;
                data.map(function(val, key) {
                    if (val.type == "TASK_REQUEST") {
                        tasksLength++;
                    }
                });
                var taskLength = data.length;
                var addLastTaskCls = false;
                return React.createElement("div", {
                    className: "accordion-state1 connectedSortable panel-group",
                    id: "accordion-" + divId
                }, data.map(function(val, key) {
                    if (taskLength - 1 == key) {
                        $("#sorting").hide();
                        addLastTaskCls = true;
                    }
                    if (val.taskType) {
                        val.type = val.taskType;
                    }
                    if (val.taskState) {
                        val.state = val.taskState;
                    }
                    if (val.taskPriority) {
                        val.priority = val.taskPriority;
                    }
                    if (val.priority == undefined) val.priority = "NoPrioritySet";
                    if (typeof val.index == "undefined") {
                        val.index = key;
                    }
                    if (val.type == "DIVIDER") {
                        return React.createElement(TaskListsComp, {
                            items: val,
                            keyVal: val.index,
                            key: val.index + val.type + "_" + val.taskId,
                            propKey: val.index + val.type + "_" + val.taskId,
                            mode: mode,
                            tasksLength: tasksLength,
                            writers: writers,
                            favWriters: favWriters,
                            currentUser: currentUser,
                            divId: divId,
                            storeId: storeId,
                            addLastTaskCls: addLastTaskCls,
                            slideTask: slideTask,
                            toggleTaskIndex: toggleTaskIndex
                        });
                    } else {
                        return React.createElement(TaskListsComp, {
                            items: val,
                            keyVal: val.index,
                            key: val.index + "_" + val.taskNumber + "_" + val.taskId,
                            propKey: val.index + "_" + val.taskNumber + "_" + val.taskId,
                            mode: mode,
                            tasksLength: tasksLength,
                            allWriters: allWriters,
                            writers: writers,
                            favWriters: favWriters,
                            currentUser: currentUser,
                            divId: divId,
                            taskNum: taskNum,
                            storeId: storeId,
                            isChecklist: isChecklist,
                            addLastTaskCls: addLastTaskCls,
                            slideTask: slideTask,
                            toggleTaskIndex: toggleTaskIndex
                        });
                    }
                }));
            }
        });
        module.exports = TaskLists;
    }, {
        "../actions/TaskActions": 1,
        "../stores/TaskStore": 12,
        "./TaskListsComp.react": 7,
        "create-react-class": 18,
        react: "react"
    } ],
    7: [ function(require, module, exports) {
        var React = require("react");
        var createReactClass = require("create-react-class");
        var ReactDOM = require("react-dom");
        var Popover = require("react-awesome-popover");
        var ClipboardJS = require("clipboard/dist/clipboard.min");
        var TaskListsCompHeader = require("./TaskListsCompHeader.react");
        var TaskStateReadViewHtml = require("./TaskStateReadViewHtml.react");
        var Chosen = require("./ReactChosen.react");
        var TaskActions = require("../actions/TaskActions");
        var WritersActions = require("../actions/WritersActions");
        var TaskCollapseArrow = require("./TaskCollapseArrow.react");
        var TaskStore = require("../stores/TaskStore");
        var isMobile = function() {
            try {
                document.createEvent("TouchEvent");
                return true;
            } catch (e) {
                return false;
            }
        };
        var TaskTitle = createReactClass({
            titleUpdated: false,
            getInitialState: function() {
                return {
                    items: this.props.items,
                    keyVal: this.props.keyVal,
                    mode: this.props.mode,
                    storeId: this.props.storeId,
                    title: this.props.items.title
                };
            },
            render: function() {
                var state = this.state;
                var isDiffSection = false;
                var titleBaseValue = "";
                if (state.items.diffOpType && state.items.diffOpType == "MODIFIED") {
                    if (state.items.baseValue) {
                        if (state.items.baseValue.title) {
                            isDiffSection = true;
                            titleBaseValue = state.items.baseValue.title;
                            modifyStateClass = "titleBarDiff";
                        }
                    }
                }
                var diffHtml = null;
                if (isDiffSection) {
                    diffHtml = React.createElement("span", {
                        className: modifyStateClass,
                        title: titleBaseValue
                    });
                }
                return React.createElement("div", {
                    className: "mb-10 titleBar-outter"
                }, React.createElement("div", {
                    className: "hiddenDivTextarea title",
                    style: {
                        padding: "10px 0px"
                    }
                }, state.title), React.createElement("textarea", {
                    name: "task-title-" + this.props.items.index,
                    defaultValue: state.title,
                    className: state.items.newItem ? "autoAdjust readText titleBar hideIcon" : "autoAdjust readText titleBar",
                    readOnly: true
                }), diffHtml);
            }
        });
        var TaskRequester = createReactClass({
            getInitialState: function() {
                var suggestions = [], allWriters = this.props.allWriters, currentUserExists = false, currentUser = this.props.currentUser, requester = this.props.items.requester;
                if (Object.keys(allWriters).length > 0) {
                    allWriters.map(function(val, key) {
                        if (requester != val.address) {
                            if (val.name && val.name != "") {
                                suggestions.push({
                                    value: val.address,
                                    label: val.name
                                });
                            } else {
                                suggestions.push({
                                    value: val.address,
                                    label: val.address
                                });
                            }
                        }
                    });
                }
                return {
                    keyVal: this.props.keyVal,
                    storeId: this.props.storeId,
                    mode: this.props.mode,
                    items: this.props.items,
                    requester: requester,
                    writers: this.props.writers,
                    allWriters: allWriters,
                    favWriters: this.props.favWriters,
                    suggestions: suggestions
                };
            },
            componentDidMount: function() {
                var me = this, isOpenInMobile = isMobile();
                this.state.allWriters.map(function(val, key) {
                    var imgPath = "";
                    if (val.type == "role" && typeof val.profileImageUri == "undefined") {
                        if (isOpenInMobile) imgPath = "./role_human.jpg"; else imgPath = "/main/images/role_human.jpg";
                    } else {
                        if (val.profileImageUri && val.profileImageUri != "") {
                            imgPath = val.profileImageUri;
                        } else {
                            if (isOpenInMobile) imgPath = "./no_image.jpg"; else imgPath = "/main/images/no_image.jpg";
                        }
                    }
                    if (val.address == me.state.requester && val.initial) {
                        var hoverHTML = '<img src="' + imgPath + '" class="hc-pic" />' + '<p class="hc-p">' + (val.name != undefined ? "<b>" + val.name + "</b><br>" : "") + val.address + "</p>";
                        $("div[data-title-colps-requester='" + val.address + "'], span[data-title-colps-requester='" + val.address + "']").unbind("click");
                        $("div[data-title-colps-requester='" + val.address + "'], span[data-title-colps-requester='" + val.address + "']").hovercard({
                            detailsHTML: hoverHTML,
                            width: "250",
                            openOnLeft: true
                        });
                        $("div[data-title-colp-requester='" + val.address + "'], span[data-title-colp-requester='" + val.address + "']").bind("click");
                    }
                });
            },
            render: function() {
                var me = this;
                var requester = this.state.requester, suggestions = this.state.suggestions, length = this.state.writers.length;
                if (me.props.mode == "read" || me.props.mode == "readSort") {
                    var name = "";
                    var key = 0;
                    if (typeof requester != "undefined" && requester != "") {
                        me.state.allWriters.map(function(writer, key) {
                            if (writer) {
                                if (writer.address == requester) {
                                    name = writer.name != "" ? writer.name : writer.initial && writer.initial != "" ? writer.initial : writer.address;
                                    key = key;
                                }
                            }
                        });
                    }
                    return React.createElement("div", {
                        id: "requester-container-" + me.state.keyVal,
                        name: "requester-container-" + me.state.keyVal
                    }, name == "" ? null : React.createElement("span", {
                        className: "requesters",
                        "data-title-colps-requester": requester,
                        "data-title": requester,
                        key: "reqs" + key
                    }, React.createElement("span", null, name)));
                } else if (this.props.mode == "template") {
                    return React.createElement("div", {
                        className: "ReactTags__tags template"
                    }, "Cannot be assigned");
                }
            }
        });
        var TaskAssignees = createReactClass({
            updateComponent: false,
            getInitialState: function() {
                var me = this, currentUserExists = false, suggestions = [], allWriters = this.props.allWriters;
                var currentUser = this.props.currentUser;
                var assignees = this.props.assignees;
                if (Object.keys(allWriters).length > 0) {
                    var currentUserExists = false;
                    allWriters.map(function(val, key) {
                        if (assignees.indexOf(val.address) == -1) {
                            if (val.name && val.name != "") {
                                suggestions.push({
                                    value: val.address,
                                    label: val.name
                                });
                            } else {
                                suggestions.push({
                                    value: val.address,
                                    label: val.address
                                });
                            }
                        }
                    });
                }
                return {
                    mode: this.props.mode,
                    assignees: this.props.assignees,
                    writers: this.props.writers,
                    favWriters: this.props.favWriters,
                    allWriters: allWriters,
                    storeId: this.props.storeId,
                    keyVal: this.props.keyVal,
                    suggestions: suggestions
                };
            },
            componentDidMount: function() {
                var me = this, isOpenInMobile = isMobile();
                this.state.allWriters.map(function(val, key) {
                    var imgPath = "";
                    if (val.type == "role" && typeof val.profileImageUri == "undefined") {
                        if (isOpenInMobile) imgPath = "./role_human.jpg"; else imgPath = "/main/images/role_human.jpg";
                    } else {
                        if (val.profileImageUri && val.profileImageUri != "") {
                            imgPath = val.profileImageUri;
                        } else {
                            if (isOpenInMobile) imgPath = "./no_image.jpg"; else imgPath = "/main/images/no_image.jpg";
                        }
                    }
                    me.state.assignees.map(function(assigneeVal, assigneeKey) {
                        if (val.address == assigneeVal && val.initial) {
                            var hoverHTML = '<img src="' + imgPath + '" class="hc-pic" />' + '<p class="hc-p">' + (val.name != undefined ? "<b>" + val.name + "</b><br>" : "") + val.address + "</p>";
                            $("div[data-title-colps-assignee='" + val.address + "'], span[data-title-colps-assignee='" + val.address + "']").unbind("click");
                            $("div[data-title-colps-assignee='" + val.address + "'], span[data-title-colps-assignee='" + val.address + "']").hovercard({
                                detailsHTML: hoverHTML,
                                width: "250",
                                openOnLeft: true
                            });
                            $("div[data-title-colps-assignee='" + val.address + "'], span[data-title-colps-assignee='" + val.address + "']").bind("click");
                        }
                    });
                });
            },
            render: function() {
                var me = this;
                var length = this.state.writers.length;
                var writers = this.state.writers;
                var assignees = this.state.assignees;
                var suggestions = this.state.suggestions;
                var initialCls = "";
                if (me.props.mode == "read" || me.props.mode == "readSort") {
                    return React.createElement("div", {
                        name: "assignee-container-" + me.state.keyVal
                    }, assignees.map(function(val, key) {
                        var name = "";
                        var type = "";
                        singleAssigneeValue = "";
                        me.state.allWriters.map(function(writer, writerKey) {
                            if (writer.address == val) {
                                singleAssigneeValue = writer.name == "" ? writer.address : writer.name;
                                name = writer.initial == "" ? writer.address : writer.initial;
                                type = writer.type ? writer.type : "human";
                            }
                        });
                        name = assignees.length == 1 ? type == "role" && singleAssigneeValue == "" ? name : singleAssigneeValue : name;
                        return name == "" ? null : React.createElement("span", {
                            className: "requesters",
                            key: "asign" + key,
                            "data-title": val,
                            "data-title-colps-assignee": val
                        }, React.createElement("span", null, name));
                    }));
                } else if (this.props.mode == "template") {
                    return React.createElement("div", {
                        className: "ReactTags__tags template"
                    }, "Cannot be assigned");
                }
            }
        });
        var TaskState = createReactClass({
            getInitialState: function() {
                return {
                    items: this.props.items,
                    keyVal: this.props.keyVal,
                    mode: this.props.mode,
                    storeId: this.props.storeId,
                    taskState: this.props.items.state
                };
            },
            componentDidMount: function() {
                this.setState({
                    taskState: this.props.items.state
                });
            },
            render: function() {
                var taskState = this.state.taskState;
                var taskStateProp = this.props.items.state;
                var state = this.state;
                var html = "";
                switch (taskState) {
                  case "Accepted":
                    html = React.createElement("span", {
                        className: "taskState accepted"
                    }, taskState);
                    break;

                  case "Unstarted":
                    html = React.createElement("span", {
                        className: "taskState start btn btn-info"
                    }, taskState);
                    break;

                  case "Started":
                    html = React.createElement("span", {
                        className: "taskState start btn btn-info"
                    }, taskState);
                    break;

                  case "Finished":
                    html = React.createElement("span", {
                        className: "taskState delivered btn btn-info"
                    }, taskState);
                    break;

                  case "Delivered":
                    html = React.createElement("span", {
                        className: "taskState rejected btn btn-danger"
                    }, taskState);
                    break;

                  case "Rejected":
                    html = React.createElement("span", {
                        className: "taskState rejected btn btn-info"
                    }, taskState);
                    break;

                  case "NoLongerApplicable":
                    html = React.createElement("span", {
                        className: "taskState start btn btn-default"
                    }, "No Longer Applicable");
                    break;

                  default:
                    break;
                }
                return React.createElement("div", {
                    name: "state-container-" + state.items.index
                }, html);
            }
        });
        var TaskPriority = createReactClass({
            getInitialState: function() {
                return {
                    items: this.props.items,
                    keyVal: this.props.keyVal,
                    mode: this.props.mode,
                    storeId: this.props.storeId,
                    taskPriority: this.props.items.priority
                };
            },
            componentDidMount: function() {
                this.setState({
                    taskPriority: this.props.items.priority
                });
            },
            render: function() {
                var taskPriority = this.state.taskPriority;
                var taskPriorityProp = this.props.items.priority;
                var state = this.state;
                var html = "";
                switch (taskPriority) {
                  case "High":
                    html = React.createElement("div", {
                        "data-value": "High",
                        title: "High Priority",
                        className: "btn-info-high btn-info-selected"
                    });
                    break;

                  case "Medium":
                    html = React.createElement("div", {
                        "data-value": "Medium",
                        title: "Medium Priority",
                        className: "btn-info-medium btn-info-selected"
                    });
                    break;

                  case "Low":
                    html = React.createElement("div", {
                        "data-value": "Low",
                        title: "Low Priority",
                        className: "btn-info-low btn-info-selected"
                    });
                    break;

                  default:
                  case "NoPrioritySet":
                    html = React.createElement("div", {
                        "data-value": "NoPrioritySet",
                        title: "No Priority Set",
                        className: "btn-info-low-no btn-info-selected"
                    });
                    break;
                }
                return React.createElement("div", {
                    className: "pull-right",
                    name: "priority-container-" + state.items.index
                }, html);
            }
        });
        var TaskDescription = createReactClass({
            getInitialState: function() {
                return {
                    description: this.props.description,
                    items: this.props.items,
                    keyVal: this.props.keyVal,
                    mode: this.props.mode,
                    storeId: this.props.storeId,
                    taskNum: this.props.taskNum
                };
            },
            componentDidMount: function() {
                if (this.state.taskNum && this.state.items.taskNumber == this.state.taskNum) {
                    var parentId = ReactDOM.findDOMNode(this.refs.description).parentNode.id;
                    var hiddenDivHeight = $("#" + parentId + " .hiddenDivTextarea").outerHeight() < 40 ? 40 : $("#" + parentId + " .hiddenDivTextarea").outerHeight() + 110;
                    $("#" + parentId + " textarea").height(hiddenDivHeight);
                }
            },
            render: function() {
                var state = this.state;
                var description = state.description;
                var isDiffSection = false;
                var descBaseValue = "";
                if (state.items.diffOpType && state.items.diffOpType == "MODIFIED") {
                    if (state.items.baseValue) {
                        if (state.items.additionalInfo) {
                            if (state.items.additionalInfo.descriptionChanged) {
                                isDiffSection = true;
                                descBaseValue = state.items.baseValue.description;
                                modifyStateClass = "descDiff";
                                if (state.items.baseValue.description == "" && state.items.description != "") {
                                    modifyStateClass = "descDiffAdd";
                                } else if (state.items.baseValue.description != "" && state.items.description == "") {
                                    modifyStateClass = "descDiffDel";
                                }
                            }
                        }
                    }
                }
                var diffHtml = null;
                if (isDiffSection) {
                    diffHtml = React.createElement("span", {
                        className: modifyStateClass,
                        title: descBaseValue
                    });
                    var isOpenInMobile = isMobile();
                    var hoverTitle = descBaseValue == "" ? "No Value" : descBaseValue;
                    if (isOpenInMobile) {
                        diffHtml = React.createElement(Popover, {
                            className: "custom-popover-content",
                            placement: "bottom",
                            arrow: false
                        }, React.createElement("a", {
                            href: "##",
                            className: "mobile-modified-data-icon"
                        }, diffHtml), hoverTitle);
                    }
                }
                return React.createElement("div", {
                    className: "description",
                    id: "description" + this.state.items.taskNumber
                }, React.createElement("div", {
                    className: "hiddenDivTextarea desc",
                    style: {
                        padding: "10px 0px"
                    }
                }, description), React.createElement("textarea", {
                    name: "task-description-" + state.items.index,
                    className: "readText autoAdjust",
                    ref: "description",
                    defaultValue: description,
                    readOnly: true
                }), diffHtml);
            }
        });
        var TaskTypeRequest = createReactClass({
            getInitialState: function() {
                var writersObj = {};
                if (this.props.writers) {
                    this.props.writers.map(function(val, key) {
                        writersObj[val.fullAdress] = val;
                    });
                }
                return {
                    writersObj: writersObj,
                    allWriters: this.props.allWriters
                };
            },
            componentDidMount: function() {
                this.bindClipBoard(".copy-task-ex-link-menu");
                this.bindClipBoard(".copy-task-ex-mobile-link-menu");
            },
            bindClipBoard: function(el) {
                var clipboard = new ClipboardJS(el);
                clipboard.on("success", function(e) {
                    $(e.trigger).parent("div").find("span.copied-span").show();
                    setTimeout(function() {
                        $(e.trigger).parent("div").find("span.copied-span").hide();
                    }, 2e3);
                    e.clearSelection();
                });
                clipboard.on("error", function(e) {
                    console.error("Action:", e.action);
                    console.error("Trigger:", e.trigger);
                });
            },
            render: function() {
                var me = this;
                var style = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "block" : "none";
                var className = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "panel-collapse collapse in" : "panel-collapse collapse";
                var fields = this.props.items.taskNumber.toString().split(/_/);
                var newItem = false;
                var storeId = this.props.storeId;
                var isEnabled = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? true : false;
                if (fields[0] == "New") {
                    var newItem = true;
                }
                var requesterDiff, assigneesDiff, stateDiff, priorityDiff = false;
                var outterCls = this.props.items.diffOpType && this.props.items.diffOpType == "MODIFIED" ? "diffSection" : "";
                var isDiffSection = false;
                var assigneeBaseValue = "", requesterBaseValue = "", stateBaseValue = "", priorityBaseValue = "";
                var additionalInfo = this.props.items.additionalInfo ? this.props.items.additionalInfo : "undefined";
                if (this.props.items.diffOpType && this.props.items.diffOpType == "MODIFIED") {
                    if (this.props.items.baseValue) {
                        if (additionalInfo) {
                            if (additionalInfo.requesterChange) {
                                if (additionalInfo.requesterChange.added && additionalInfo.requesterChange.added != "" && additionalInfo.requesterChange.removed && additionalInfo.requesterChange.removed != "") {
                                    modifyReqStateClass = "table-style-diff";
                                    requesterDiff = true;
                                } else if (additionalInfo.requesterChange.added && additionalInfo.requesterChange.added != "") {
                                    modifyReqStateClass = "table-style-diff-add";
                                    requesterDiff = true;
                                } else if (additionalInfo.requesterChange.removed && additionalInfo.requesterChange.removed != "") {
                                    modifyReqStateClass = "table-style-diff-del";
                                    requesterDiff = true;
                                }
                                var writerAddress = this.props.items.baseValue.requester;
                                requesterBaseValue = writerAddress != "" ? me.state.writersObj[writerAddress]["name"] != "" ? me.state.writersObj[writerAddress]["name"] + " (" + me.state.writersObj[writerAddress]["address"] + ")" : me.state.writersObj[writerAddress]["address"] : "";
                            }
                            if (additionalInfo.assigneeChange) {
                                var assigneesAdded = "";
                                var assigneesRemoved = "";
                                if (additionalInfo.assigneeChange.added.length > 0) {
                                    additionalInfo.assigneeChange.added.map(function(val, key) {
                                        assigneesAdded += val + (additionalInfo.assigneeChange.added.length - 1 == key ? " " : ", ");
                                    });
                                    assigneesDiff = true;
                                }
                                if (additionalInfo.assigneeChange.removed.length > 0) {
                                    additionalInfo.assigneeChange.removed.map(function(val, key) {
                                        assigneesRemoved += val + (additionalInfo.assigneeChange.removed.length - 1 == key ? " " : ", ");
                                    });
                                    assigneesDiff = true;
                                }
                                if (additionalInfo.assigneeChange.added.length > 0 && additionalInfo.assigneeChange.removed.length > 0) {
                                    modifyAssigStateClass = "table-style-diff";
                                    assigneesDiff = true;
                                } else if (additionalInfo.assigneeChange.added.length > 0) {
                                    modifyAssigStateClass = "table-style-diff-add";
                                    assigneesDiff = true;
                                } else if (additionalInfo.assigneeChange.removed.length > 0) {
                                    modifyAssigStateClass = "table-style-diff-del";
                                    assigneesDiff = true;
                                }
                            }
                        }
                        if (this.props.items.baseValue.assignees) {
                            this.props.items.baseValue.assignees.map(function(val, key) {
                                if (val) {
                                    if (typeof me.state.writersObj[val] != "undefined" && (me.state.writersObj[val]["address"] == val || me.state.writersObj[val]["fullAdress"] == val)) {
                                        assigneeBaseValue += me.state.writersObj[val]["name"] != "" ? me.state.writersObj[val]["name"] + " (" + me.state.writersObj[val]["address"] + ")" : me.state.writersObj[val]["address"];
                                    } else {
                                        assigneeBaseValue += val;
                                    }
                                    assigneeBaseValue += "\n";
                                }
                            });
                        }
                        if (this.props.items.baseValue.state) {
                            modifyTaskStateClass = "table-style-diff";
                            stateDiff = true;
                            stateBaseValue = this.props.items.baseValue.state;
                        }
                        if (this.props.items.baseValue.priority) {
                            modifyTaskPriorityClass = "table-style-diff";
                            priorityDiff = true;
                            priorityBaseValue = this.props.items.baseValue.priority;
                        }
                    }
                }
                var requesterDiffHtml, assigneesDiffHtml, stateDiffHtml, priorityDiffHtml = null;
                var isOpenInMobile = isMobile();
                if (requesterDiff) {
                    requesterDiffHtml = React.createElement("span", {
                        className: modifyReqStateClass,
                        title: requesterBaseValue
                    });
                }
                if (assigneesDiff) {
                    assigneesDiffHtml = React.createElement("span", {
                        className: modifyAssigStateClass,
                        title: assigneeBaseValue
                    });
                }
                if (stateDiff) {
                    stateDiffHtml = React.createElement("span", {
                        className: modifyTaskStateClass,
                        title: stateBaseValue
                    });
                }
                if (priorityDiff) {
                    priorityDiffHtml = React.createElement("span", {
                        className: modifyTaskPriorityClass,
                        title: priorityBaseValue
                    });
                }
                if (isEnabled) {
                    var jsonData = TaskStore.getData(this.props.storeId), tnum = this.props.items.taskNumber, ttitle = this.props.items.title.replace(/"/g, "'").replace(/[\[\]']+/g, "");
                    var url = jsonData.baseUrl + "ttn/" + jsonData.tmailNum + "#task=" + jsonData.secNum + ":" + tnum, link = "[ TASK " + tnum + ' titled "' + ttitle + '" in "' + jsonData.sectionTitle + '" in THREAD "' + jsonData.tmailSubject + '", ' + url + " ]";
                    if (jsonData.mailboxType == "forward") {
                        url = jsonData.baseUrl + "ttn/" + jsonData.tmailNum + "#forwarded-task=" + jsonData.fwdtmailNum + ":" + jsonData.secNum + ":" + tnum;
                        var isInComment = jsonData.cnum ? " in FORWARDED COMMENT " + jsonData.cnum : " ";
                        link = "[ FORWARDED TASK " + tnum + ' titled "' + ttitle + '" in "' + jsonData.sectionTitle + '"' + isInComment + " in " + jsonData.tmailNum + ' in THREAD "' + jsonData.tmailSubject + '", ' + url + " ]";
                    }
                    return React.createElement("div", {
                        className: (this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "impBackgroundFFF " : " ") + outterCls,
                        key: this.props.propKey
                    }, React.createElement(TaskListsCompHeader, {
                        items: this.props.items,
                        mode: this.props.mode,
                        keyVal: this.props.keyVal,
                        allWriters: this.props.allWriters,
                        writers: this.props.writers,
                        currentUser: this.props.currentUser,
                        divId: this.props.divId,
                        taskNum: this.props.taskNum,
                        storeId: storeId,
                        favWriters: this.props.favWriters,
                        isChecklist: this.props.isChecklist,
                        slideTask: this.props.slideTask,
                        toggleTaskIndex: this.props.toggleTaskIndex
                    }), React.createElement("div", {
                        id: this.props.divId + "_collapse_" + this.props.mode + this.props.items.index,
                        className: className,
                        style: {
                            display: style
                        }
                    }, React.createElement("div", {
                        className: "panel-body"
                    }, React.createElement(TaskTitle, {
                        items: this.props.items,
                        mode: this.props.mode,
                        keyVal: this.props.keyVal,
                        storeId: storeId
                    }), React.createElement("div", {
                        className: "mb-6 taskNumber" + this.props.mode == "read" || this.props.mode == "readSort" ? "hiddenDelBtn" : "" + (isMobile() && !newItem && jsonData.mailboxType != "draft" ? "copy-task-ex-mobile-link-menu" : ""),
                        style: {
                            float: "left",
                            clear: "both",
                            position: "relative",
                            cursor: isMobile() && !newItem && jsonData.mailboxType != "draft" ? "pointer" : "auto"
                        },
                        "data-clipboard-text": link
                    }, React.createElement("span", {
                        className: "content-id label-cls"
                    }, "Task Number"), React.createElement("span", {
                        name: "task-number-" + this.props.items.index,
                        className: newItem ? "taskId content-id newTask taskNumber" : "taskId content-id taskNumber"
                    }, "#", newItem ? "New" : this.props.items.taskNumber), !newItem && jsonData.mailboxType != "draft" ? React.createElement("div", {
                        style: {
                            float: "left",
                            position: "relative",
                            width: "20px"
                        }
                    }, React.createElement("span", {
                        className: "copied-span copied-span-ex hidden"
                    }, "Task Link Copied"), !isMobile() ? React.createElement("div", {
                        name: "task-number-copy-" + this.props.items.index,
                        className: "copy-task-ex-link-menu",
                        title: "Copy Task Link",
                        "data-clipboard-text": link
                    }) : null) : null), React.createElement("div", {
                        className: "content-block"
                    }, React.createElement("div", {
                        className: "col-md-4 table-style"
                    }, React.createElement("div", {
                        className: "col-md-3 label-cls"
                    }, "Requester"), React.createElement("div", {
                        className: "col-md-9",
                        style: {
                            textAlign: "right"
                        }
                    }, React.createElement(TaskRequester, {
                        items: this.props.items,
                        mode: this.props.mode,
                        keyVal: this.props.keyVal,
                        allWriters: this.state.allWriters,
                        writers: this.props.writers,
                        favWriters: this.props.favWriters,
                        currentUser: this.props.currentUser,
                        storeId: storeId
                    })), requesterDiffHtml), React.createElement("div", {
                        style: {
                            clear: "both"
                        }
                    }), React.createElement("div", {
                        className: "col-md-4 table-style"
                    }, React.createElement("div", {
                        className: "col-md-3 label-cls"
                    }, "Assignees"), React.createElement("div", {
                        className: "col-md-9",
                        style: {
                            textAlign: "right"
                        }
                    }, React.createElement(TaskAssignees, {
                        assignees: this.props.items.assignees,
                        mode: this.props.mode,
                        keyVal: this.props.keyVal,
                        allWriters: this.state.allWriters,
                        writers: this.props.writers,
                        favWriters: this.props.favWriters,
                        currentUser: this.props.currentUser,
                        storeId: storeId
                    })), assigneesDiffHtml), React.createElement("div", {
                        style: {
                            clear: "both"
                        }
                    }), React.createElement("div", {
                        className: "col-md-4 table-style"
                    }, React.createElement("div", {
                        className: "col-md-3 label-cls"
                    }, "State"), React.createElement("div", {
                        className: "col-md-9",
                        style: {
                            textAlign: "right"
                        }
                    }, React.createElement(TaskState, {
                        items: this.props.items,
                        mode: this.props.mode,
                        keyVal: this.props.keyVal,
                        propKey: this.props.propKey,
                        storeId: storeId
                    })), stateDiffHtml), React.createElement("div", {
                        style: {
                            clear: "both"
                        }
                    }), React.createElement("div", {
                        className: "col-md-4 table-style table-last-row"
                    }, React.createElement("div", {
                        className: "col-md-3 label-cls"
                    }, "Priority"), React.createElement("div", {
                        className: "col-md-9",
                        style: {
                            textAlign: "right"
                        }
                    }, React.createElement(TaskPriority, {
                        items: this.props.items,
                        mode: this.props.mode,
                        keyVal: this.props.keyVal,
                        propKey: this.props.propKey,
                        storeId: storeId
                    })), priorityDiffHtml), React.createElement("div", {
                        style: {
                            clear: "both"
                        }
                    })), React.createElement("div", {
                        style: {
                            clear: "both"
                        }
                    }), React.createElement(TaskDescription, {
                        items: this.props.items,
                        description: this.props.items.description,
                        keyVal: this.props.keyVal,
                        mode: this.props.mode,
                        storeId: storeId,
                        taskNum: this.props.taskNum
                    }))));
                } else {
                    return React.createElement("div", {
                        className: (this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "impBackgroundFFF " : " ") + outterCls,
                        key: this.props.propKey
                    }, React.createElement(TaskListsCompHeader, {
                        items: this.props.items,
                        mode: this.props.mode,
                        keyVal: this.props.keyVal,
                        allWriters: this.props.allWriters,
                        writers: this.props.writers,
                        currentUser: this.props.currentUser,
                        divId: this.props.divId,
                        taskNum: this.props.taskNum,
                        storeId: storeId,
                        favWriters: this.props.favWriters,
                        isChecklist: this.props.isChecklist,
                        slideTask: this.props.slideTask,
                        toggleTaskIndex: this.props.toggleTaskIndex
                    }));
                }
            }
        });
        var TaskTypeDivider = createReactClass({
            render: function() {
                var titleDisplay = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "block" : "none";
                var titleTopMargin = this.props.items.newItem ? "-10px" : "-22px";
                var className = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "panel-collapse collapse in" : "panel-collapse collapse";
                var hideDivider = this.props.mode == "readSort" ? "none" : "block";
                var storeId = this.props.storeId;
                var hideTitle = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "none" : "block";
                var isEnabled = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? true : false;
                if (isEnabled) {
                    return React.createElement("div", {
                        className: this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "impBackgroundFFF" : "",
                        key: this.props.propKey,
                        style: {
                            display: hideDivider
                        }
                    }, React.createElement("div", {
                        className: "panel-heading"
                    }, React.createElement("div", {
                        className: "title-outter",
                        style: {
                            display: hideTitle
                        }
                    }, React.createElement("h4", {
                        className: "panel-title"
                    }, this.props.items.title))), React.createElement("div", {
                        id: this.props.divId + "_collapse_" + this.props.mode + this.props.items.index,
                        className: className,
                        style: {
                            display: titleDisplay,
                            marginTop: titleTopMargin
                        }
                    }, React.createElement("div", {
                        className: "panel-body"
                    }, React.createElement("div", {
                        className: "mb-10"
                    }, React.createElement(TaskTitle, {
                        items: this.props.items,
                        keyVal: this.props.keyVal,
                        mode: this.props.mode,
                        storeId: storeId
                    }), React.createElement("div", {
                        style: {
                            float: "left",
                            clear: "both"
                        }
                    })))));
                } else {
                    return React.createElement("div", {
                        className: this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "impBackgroundFFF" : "",
                        key: this.props.propKey,
                        style: {
                            display: hideDivider
                        }
                    }, React.createElement("div", {
                        className: "panel-heading"
                    }, React.createElement("div", {
                        className: "title-outter",
                        style: {
                            display: hideTitle
                        }
                    }, React.createElement("h4", {
                        className: "panel-title"
                    }, this.props.items.title))));
                }
            }
        });
        var TaskListsComp = createReactClass({
            getInitialState: function() {
                return {
                    allWriters: this.props.allWriters,
                    currentUser: this.props.currentUser,
                    divId: this.props.divId,
                    favWriters: this.props.favWriters,
                    isChecklist: this.props.isChecklist,
                    items: this.props.items,
                    key: this.props.propKey,
                    keyVal: this.props.keyVal,
                    mode: this.props.mode,
                    storeId: this.props.storeId,
                    taskNum: this.props.taskNum,
                    tasksLength: this.props.tasksLength,
                    writers: this.props.writers
                };
            },
            render: function() {
                var outterClass = "panel panel-default ";
                var hideDivider = this.state.mode == "readSort" ? "none" : "block";
                var storeId = this.state.storeId;
                var isDiffSection = this.state.items.diffOpType ? true : false;
                if (this.state.items.deleted) {
                    hideDivider = "none";
                }
                switch (this.state.items.state) {
                  case "Accepted":
                    outterClass += "panel-accepted";
                    break;

                  case "NoLongerApplicable":
                    outterClass += "panel-grey";
                    break;

                  case "Finished":
                  case "Delivered":
                  case "Rejected":
                  case "Started":
                    outterClass += "panel-openTask";
                    break;

                  default:
                    outterClass += "panel-white";
                    break;
                }
                if (this.state.items.type == "DIVIDER") {
                    outterClass = "panel panel-default panel-blue panel-divider";
                }
                if (isDiffSection) {
                    var outterClass = "panel panel-default panel-white";
                    switch (this.state.items.diffOpType) {
                      case "NEW":
                        outterClass += " panel-diff-added";
                        break;

                      case "DELETED":
                        outterClass += " panel-diff-deleted";
                        break;

                      case "MODIFIED":
                        outterClass += " panel-diff-modified";
                        break;
                    }
                }
                if (this.props.addLastTaskCls) {
                    outterClass += " last-task";
                }
                switch (this.state.items.type) {
                  case "TASK_REQUEST":
                    return React.createElement("div", {
                        className: "el-container " + outterClass,
                        name: "sort_" + this.state.keyVal,
                        id: "sort_" + this.state.keyVal,
                        style: {
                            display: this.state.items.deleted ? "none" : "block"
                        }
                    }, React.createElement(TaskTypeRequest, {
                        items: this.state.items,
                        mode: this.state.mode,
                        keyVal: this.state.keyVal,
                        propKey: this.state.key,
                        tasksLength: this.state.tasksLength,
                        allWriters: this.state.allWriters,
                        writers: this.state.writers,
                        favWriters: this.state.favWriters,
                        currentUser: this.state.currentUser,
                        divId: this.state.divId,
                        taskNum: this.state.taskNum,
                        storeId: storeId,
                        isChecklist: this.state.isChecklist,
                        slideTask: this.props.slideTask,
                        toggleTaskIndex: this.props.toggleTaskIndex
                    }));
                    break;

                  case "DIVIDER":
                    return this.state.mode == "nonSort" ? null : React.createElement("div", {
                        className: "el-container " + outterClass,
                        style: {
                            display: hideDivider
                        },
                        name: "sort_" + this.state.keyVal,
                        id: "sort_" + this.state.keyVal
                    }, React.createElement(TaskTypeDivider, {
                        items: this.state.items,
                        mode: this.state.mode,
                        keyVal: this.state.keyVal,
                        propKey: this.state.key,
                        tasksLength: this.state.tasksLength,
                        divId: this.state.divId,
                        storeId: storeId,
                        toggleTaskIndex: this.props.toggleTaskIndex,
                        slideTask: this.props.slideTask
                    }));
                    break;
                }
            }
        });
        module.exports = TaskListsComp;
    }, {
        "../actions/TaskActions": 1,
        "../actions/WritersActions": 2,
        "../stores/TaskStore": 12,
        "./ReactChosen.react": 3,
        "./TaskCollapseArrow.react": 5,
        "./TaskListsCompHeader.react": 8,
        "./TaskStateReadViewHtml.react": 9,
        "clipboard/dist/clipboard.min": 16,
        "create-react-class": 18,
        react: "react",
        "react-awesome-popover": 27,
        "react-dom": "react-dom"
    } ],
    8: [ function(require, module, exports) {
        var React = require("react");
        var createReactClass = require("create-react-class");
        var ReactDOM = require("react-dom");
        var Popover = require("react-awesome-popover");
        var ClipboardJS = require("clipboard/dist/clipboard.min");
        var TaskStateReadViewHtml = require("./TaskStateReadViewHtml.react");
        var TaskCollapseArrow = require("./TaskCollapseArrow.react");
        var WritersStore = require("../stores/WritersStore");
        var TaskStore = require("../stores/TaskStore");
        function getWriters() {
            return WritersStore.getData();
        }
        var isMobile = function() {
            try {
                document.createEvent("TouchEvent");
                return true;
            } catch (e) {
                return false;
            }
        };
        var TaskRequester = createReactClass({
            getInitialState: function() {
                var allWriters = this.props.allWriters;
                return {
                    keyVal: this.props.keyVal,
                    storeId: this.props.storeId,
                    mode: this.props.mode,
                    allWriters: allWriters
                };
            },
            componentDidUpdate: function() {
                var me = this, isOpenInMobile = isMobile();
                this.state.allWriters.map(function(val, key) {
                    var imgPath = "";
                    if (val.type == "role" && typeof val.profileImageUri == "undefined") {
                        if (isOpenInMobile) {
                            imgPath = "./role_human.jpg";
                        } else {
                            imgPath = "/main/images/role_human.jpg";
                        }
                    } else {
                        if (val.profileImageUri && val.profileImageUri != "") {
                            imgPath = val.profileImageUri;
                        } else {
                            if (isOpenInMobile) {
                                imgPath = "./no_image.jpg";
                            } else {
                                imgPath = "/main/images/no_image.jpg";
                            }
                        }
                    }
                    if (val.address == me.props.requester && val.initial) {
                        var hoverHTML = '<img src="' + imgPath + '" class="hc-pic" />' + '<p class="hc-p">' + (val.name != undefined ? "<b>" + val.name + "</b><br>" : "") + val.address + "</p>";
                        $("div[data-title-requester='" + val.address + "'], span[data-title-requester='" + val.address + "']").unbind("click");
                        $("div[data-title-requester='" + val.address + "'], span[data-title-requester='" + val.address + "']").hovercard({
                            detailsHTML: hoverHTML,
                            width: "250",
                            openOnLeft: true
                        });
                        $("div[data-title-requester='" + val.address + "'], span[data-title-requester='" + val.address + "']").bind("click");
                    }
                });
            },
            shouldComponentUpdate: function(nextProps, nextState, nextContext) {
                return true;
            },
            render: function() {
                var me = this;
                var requester = this.props.requester;
                if (me.props.mode != "template") {
                    var name = "";
                    var key = 0;
                    if (typeof requester != "undefined" && requester != "") {
                        me.state.allWriters.map(function(writer, key) {
                            if (writer) {
                                if (writer.address == requester) {
                                    name = writer.name != "" ? writer.name : writer.type && writer.type == "role" ? writer.initial : writer.address;
                                    key = key;
                                }
                            }
                        });
                    }
                    return React.createElement("div", null, name == "" ? null : React.createElement("div", {
                        key: "div-req" + key + "-" + requester
                    }, React.createElement("span", {
                        className: "header-requester requesters",
                        "data-title-requester": requester,
                        key: "reqs" + key
                    }, React.createElement("span", null, name))));
                } else {
                    return null;
                }
            }
        });
        var TaskAssignees = createReactClass({
            getInitialState: function() {
                var currentUser = this.props.currentUser;
                return {
                    assignees: this.props.assignees,
                    allWriters: this.props.allWriters,
                    mode: this.props.mode
                };
            },
            componentDidMount: function() {
                if (ReactDOM.findDOMNode(this.refs["header-assignees"]) && ReactDOM.findDOMNode(this.refs["header-assignees"]) != null) {
                    ReactDOM.findDOMNode(this.refs["header-assignees"]).setAttribute("assigneesCount", this.state.assignees.length);
                }
            },
            componentDidUpdate: function() {
                var me = this, isOpenInMobile = isMobile();
                this.state.allWriters.map(function(val, key) {
                    var imgPath = "";
                    if (val.type == "role" && typeof val.profileImageUri == "undefined") {
                        if (isOpenInMobile) imgPath = "./role_human.jpg"; else imgPath = "/main/images/role_human.jpg";
                    } else {
                        if (val.profileImageUri && val.profileImageUri != "") {
                            imgPath = val.profileImageUri;
                        } else {
                            if (isOpenInMobile) imgPath = "./no_image.jpg"; else imgPath = "/main/images/no_image.jpg";
                        }
                    }
                    me.state.assignees.map(function(assigneeVal, assigneeKey) {
                        if (val.address == assigneeVal && val.initial) {
                            var hoverHTML = '<img src="' + imgPath + '" class="hc-pic" />' + '<p class="hc-p">' + (val.name != undefined ? "<b>" + val.name + "</b><br>" : "") + val.address + "</p>";
                            $("div[data-title-assignee='" + val.address + "'], span[data-title-assignee='" + val.address + "']").unbind("click");
                            $("div[data-title-assignee='" + val.address + "'], span[data-title-assignee='" + val.address + "']").hovercard({
                                detailsHTML: hoverHTML,
                                width: "250",
                                openOnLeft: true
                            });
                            $("div[data-title-assignee='" + val.address + "'], span[data-title-assignee='" + val.address + "']").bind("click");
                        }
                    });
                });
            },
            shouldComponentUpdate: function(nextProps, nextState, nextContext) {
                if (this.state.mode == "template") {
                    return false;
                }
                return true;
            },
            render: function() {
                var allWriters = this.state.allWriters;
                var noInitialCls = "";
                var assignees = this.state.assignees;
                if (this.props.mode == "template") {
                    return null;
                } else {
                    return React.createElement("div", null, React.createElement("div", {
                        className: "assignee-outter header-assignees",
                        title: "",
                        ref: "header-assignees"
                    }, assignees.map(function(val, key) {
                        var name = "";
                        var type = "";
                        singleAssigneeValue = "";
                        if (Object.keys(allWriters).length > 0) {
                            allWriters.map(function(writer, key) {
                                if (writer.address == val) {
                                    singleAssigneeValue = writer.name == "" || writer.name == undefined ? writer.address : writer.name;
                                    name = writer.initial == "" ? writer.address : writer.initial;
                                    type = writer.type ? writer.type : "human";
                                }
                            });
                        }
                        if (name == "") {
                            name = val;
                            noInitialCls = "noInitialCls";
                        } else {
                            noInitialCls = "";
                        }
                        name = assignees.length == 1 ? type == "role" && singleAssigneeValue == "" ? name : singleAssigneeValue : name;
                        return val == "More" || name == "" ? null : React.createElement("div", {
                            key: "div" + key + "-" + val
                        }, React.createElement("div", {
                            className: "header-task-assignees chosen-single " + noInitialCls,
                            key: key,
                            "data-title-assignee": val
                        }, React.createElement("span", null, name)));
                    })));
                }
            }
        });
        var TaskStateHeader = createReactClass({
            render: function() {
                var state = this.props.state;
                var style = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "none" : "block";
                var className = this.props.items.newItem || this.props.taskNum && this.props.items.taskNumber == this.props.taskNum ? "glyphicon glyphicon-chevron-down collapse-i" : "glyphicon glyphicon-chevron-right collapse-i";
                var storeId = this.props.storeId;
                var taskStateBtnsHTML = React.createElement(TaskStateReadViewHtml, {
                    taskState: this.props.state
                });
                return React.createElement("div", {
                    className: "button-outter right-align",
                    style: {
                        display: style,
                        float: "right"
                    }
                }, taskStateBtnsHTML);
            }
        });
        var TaskPriorityHeader = createReactClass({
            render: function() {
                var priority = this.props.priority;
                var style = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "none" : "block";
                var className = this.props.items.newItem || this.props.taskNum && this.props.items.taskNumber == this.props.taskNum ? "glyphicon glyphicon-chevron-down collapse-i" : "glyphicon glyphicon-chevron-right collapse-i";
                var storeId = this.props.storeId, html = React.createElement("div", {
                    style: {
                        width: "27px",
                        opacity: 0
                    }
                }, ".");
                switch (priority) {
                  case "High":
                    html = React.createElement("div", {
                        "data-value": "High",
                        title: "High Priority",
                        className: "btn-info-high btn-info-selected"
                    });
                    break;

                  case "Medium":
                    html = React.createElement("div", {
                        "data-value": "Medium",
                        title: "Medium Priority",
                        className: "btn-info-medium btn-info-selected"
                    });
                    break;

                  case "Low":
                    html = React.createElement("div", {
                        "data-value": "Low",
                        title: "Low Priority",
                        className: "btn-info-low btn-info-selected"
                    });
                    break;

                  default:
                    break;
                }
                var mrgnTop = "0px";
                if (this.props.mode == "read" || this.props.mode == "readSort" || this.props.mode == "template" || this.props.state == "NoLongerApplicable") {
                    mrgnTop = "4px";
                }
                if (html != null) {
                    return React.createElement("div", {
                        className: "button-outter right-align",
                        style: {
                            display: style,
                            float: "right",
                            marginTop: mrgnTop
                        }
                    }, html);
                } else {
                    return html;
                }
            }
        });
        var TaskListsCompHeader = createReactClass({
            getInitialState: function() {
                return {
                    open: false
                };
            },
            componentDidMount: function() {
                this.bindClipBoard(".copy-task-link-menu");
                this.bindClipBoard(".copy-task-link-mobile-menu");
            },
            bindClipBoard: function(el) {
                var clipboard = new ClipboardJS(el);
                clipboard.on("success", function(e) {
                    $(e.trigger).parent("div").find("span.copied-span").show();
                    setTimeout(function() {
                        $(e.trigger).parent("div").find("span.copied-span").hide();
                    }, 2e3);
                    e.clearSelection();
                });
                clipboard.on("error", function(e) {
                    console.error("Action:", e.action);
                    console.error("Trigger:", e.trigger);
                });
            },
            shouldComponentUpdate: function(nextProps, nextState, nextContext) {
                var updateHeader = this.props.items.shouldUpdateHeader || this.props.items.diffOpType ? true : false;
                return updateHeader;
            },
            returnAditionalInfo: function(additionalInfo, changedValue) {
                var isEnabled = typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? true : false;
                if (additionalInfo && !isEnabled) {
                    var diffWritersObj = {};
                    this.props.allWriters.map(function(val, key) {
                        diffWritersObj[val.fullAdress] = val;
                    });
                    if (additionalInfo.titleChanged && changedValue == "titleChanged") {
                        return React.createElement("span", {
                            className: "diff-text"
                        }, React.createElement("span", {
                            className: "task-bullet"
                        }), " ", React.createElement("b", null, "Title"), " was changed (open task to see) ");
                    }
                    if (additionalInfo.stateChange && changedValue == "stateChange") {
                        if (additionalInfo.stateChange && additionalInfo.stateChange == "none") {
                            return null;
                        } else if (additionalInfo.stateChange && additionalInfo.stateChange == "expected") {
                            return React.createElement("span", {
                                className: "diff-text"
                            }, React.createElement("span", {
                                className: "task-bullet"
                            }), " This Task was ", React.createElement("b", null, this.props.items.taskState ? this.props.items.taskState : this.props.items.state), " ");
                        } else {
                            return React.createElement("span", {
                                className: "diff-text"
                            }, React.createElement("span", {
                                className: "task-bullet"
                            }), " This Task was moved from ", React.createElement("b", null, this.props.items.baseValue.state), " to ", React.createElement("b", null, this.props.items.state), " ");
                        }
                    }
                    if (additionalInfo.requesterChange && changedValue == "requesterChange") {
                        var removedWriterName = additionalInfo.requesterChange.removed;
                        var removedWriterAddress = additionalInfo.requesterChange.removed;
                        var addedWriterName = additionalInfo.requesterChange.added;
                        var addedWriterAddress = additionalInfo.requesterChange.added;
                        if (diffWritersObj[additionalInfo.requesterChange.removed]) {
                            var writer = diffWritersObj[additionalInfo.requesterChange.removed];
                            removedWriterName = writer.type == "role" && writer.name == "" ? writer.initial : writer.name;
                            assigneeAddress = writer.type == "role" ? writer.initial && writer.initial != "" ? writer.address : "" : writer.address;
                        }
                        if (diffWritersObj[additionalInfo.requesterChange.added]) {
                            var writer = diffWritersObj[additionalInfo.requesterChange.added];
                            addedWriterName = writer.type == "role" && writer.name == "" ? writer.initial : writer.name;
                            assigneeAddress = writer.type == "role" ? writer.initial && writer.initial != "" ? writer.address : "" : writer.address;
                        }
                        if (additionalInfo.requesterChange.added && additionalInfo.requesterChange.added != "" && additionalInfo.requesterChange.removed && additionalInfo.requesterChange.removed != "") {
                            return React.createElement("span", {
                                className: "diff-text"
                            }, React.createElement("span", {
                                className: "task-bullet"
                            }), " Requester ", React.createElement("b", null, React.createElement("span", {
                                title: removedWriterAddress
                            }, removedWriterName)), " was replaced by ", React.createElement("b", null, React.createElement("span", {
                                title: addedWriterAddress
                            }, addedWriterName)), " ");
                        } else if (additionalInfo.requesterChange.added && additionalInfo.requesterChange.added != "") {
                            return React.createElement("span", {
                                className: "diff-text"
                            }, React.createElement("span", {
                                className: "task-bullet"
                            }), " Requester ", React.createElement("b", null, React.createElement("span", {
                                title: addedWriterAddress
                            }, addedWriterName)), " was added ");
                        } else if (additionalInfo.requesterChange.removed && additionalInfo.requesterChange.removed != "") {
                            return React.createElement("span", {
                                className: "diff-text"
                            }, React.createElement("span", {
                                className: "task-bullet"
                            }), " Requester ", React.createElement("b", null, React.createElement("span", {
                                title: removedWriterAddress
                            }, removedWriterName)), " was removed ");
                        } else {
                            return null;
                        }
                    }
                    if (additionalInfo.assigneeChange && changedValue == "assigneeChange") {
                        var assigneesAdded = "";
                        var assigneesRemoved = "";
                        var addedWriters = [];
                        var removedWriters = [];
                        if (additionalInfo.assigneeChange.added.length > 0) {
                            additionalInfo.assigneeChange.added.map(function(val, key) {
                                var assigneeName = val;
                                var assigneeAddress = val;
                                if (diffWritersObj[val]) {
                                    if (additionalInfo.assigneeChange.added.length == 1) {
                                        var writer = diffWritersObj[val];
                                        assigneeName = writer.type == "role" && writer.name == "" ? writer.initial : writer.name;
                                        assigneeAddress = writer.type == "role" ? writer.initial && writer.initial != "" ? writer.address : "" : writer.address;
                                    } else {
                                        var writer = diffWritersObj[val];
                                        assigneeName = writer.initial ? writer.initial : writer.address;
                                        assigneeAddress = writer.type == "role" ? writer.initial && writer.initial != "" ? writer.address : "" : writer.address;
                                    }
                                } else {
                                    assigneeAddress = "";
                                }
                                if (addedWriters.indexOf(val) == -1) {
                                    addedWriters.push({
                                        writerName: assigneeName,
                                        writerAddress: assigneeAddress
                                    });
                                }
                            });
                        }
                        if (additionalInfo.assigneeChange.removed.length > 0) {
                            additionalInfo.assigneeChange.removed.map(function(val, key) {
                                var removedWriterName = val;
                                var removedWriterAddress = val;
                                if (diffWritersObj[val]) {
                                    if (additionalInfo.assigneeChange.removed.length == 1) {
                                        var writer = diffWritersObj[val];
                                        removedWriterName = writer.type == "role" && writer.name == "" ? writer.initial : writer.name;
                                        removedWriterAddress = writer.type == "role" ? writer.initial && writer.initial != "" ? writer.address : "" : writer.address;
                                    } else {
                                        var writer = diffWritersObj[val];
                                        removedWriterName = writer.type == "role" ? writer.initial ? writer.initial : writer.address : writer.name;
                                        removedWriterAddress = writer.type == "role" ? writer.initial && writer.initial != "" ? writer.address : "" : writer.address;
                                    }
                                }
                                removedWriters.push({
                                    writerName: removedWriterName,
                                    writerAddress: removedWriterAddress
                                });
                            });
                        }
                        if (additionalInfo.assigneeChange.added.length > 0 && additionalInfo.assigneeChange.removed.length > 0) {
                            return React.createElement("span", {
                                className: "diff-text"
                            }, React.createElement("span", {
                                className: "task-bullet"
                            }), " Assignees ", React.createElement("b", null, addedWriters.map(function(val, key) {
                                return React.createElement("span", {
                                    title: val.writerAddress
                                }, val.writerName, addedWriters.length - 1 == key ? " " : ", ");
                            })), " added and ", React.createElement("b", null, removedWriters.map(function(val, key) {
                                return React.createElement("span", {
                                    title: val.writerAddress
                                }, val.writerName, removedWriters.length - 1 == key ? " " : ", ");
                            })), " removed ");
                        } else if (additionalInfo.assigneeChange.added.length > 0) {
                            return React.createElement("span", {
                                className: "diff-text"
                            }, React.createElement("span", {
                                className: "task-bullet"
                            }), " Assignee", additionalInfo.assigneeChange.added.length == 1 ? null : "s", " ", React.createElement("b", null, addedWriters.map(function(val, key) {
                                return React.createElement("span", {
                                    title: val.writerAddress
                                }, val.writerName, addedWriters.length - 1 == key ? " " : ", ");
                            })), " added ");
                        } else if (additionalInfo.assigneeChange.removed.length > 0) {
                            return React.createElement("span", {
                                className: "diff-text"
                            }, React.createElement("span", {
                                className: "task-bullet"
                            }), " Assignee", additionalInfo.assigneeChange.removed.length == 1 ? null : "s", " ", React.createElement("b", null, removedWriters.map(function(val, key) {
                                return React.createElement("span", {
                                    title: val.writerAddress
                                }, val.writerName, removedWriters.length - 1 == key ? " " : ", ");
                            })), " removed ");
                        } else {
                            return null;
                        }
                    }
                    if (additionalInfo.descriptionChanged && changedValue == "descriptionChanged") {
                        return React.createElement("span", {
                            className: "diff-text"
                        }, React.createElement("span", {
                            className: "task-bullet"
                        }), " ", React.createElement("b", null, "Description"), " was changed (open task to see) ");
                    }
                }
            },
            render: function() {
                var style = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "none" : "block";
                typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask;
                var className = this.props.items.newItem || typeof this.props.toggleTaskIndex != "undefined" && this.props.items.index == this.props.toggleTaskIndex && this.props.slideTask ? "glyphicon glyphicon-chevron-down collapse-i" : "glyphicon glyphicon-chevron-right collapse-i";
                var fields = this.props.items.taskNumber.toString().split(/_/);
                var newItem = false;
                var titleOutter = this.props.items.state != "Delivered" && this.props.mode != "read" && this.props.mode != "readSort" && this.props.items.state != "NoLongerApplicable" && this.props.items.state != "Accepted" ? "title-cls" : "";
                var storeId = this.props.storeId;
                var headerCls = "panel-heading";
                if (fields[0] == "New") {
                    var newItem = true;
                }
                var isDiffSection = this.props.items.diffOpType ? true : false;
                var diffIcon, taskDiffType = "";
                var additionalInfo = this.props.items.additionalInfo ? this.props.items.additionalInfo : "undefined";
                var diffHtml = null;
                if (isDiffSection) {
                    headerCls = "panel-heading diff-section-heading";
                    switch (this.props.items.diffOpType) {
                      case "NEW":
                        diffIcon = "diff-added-icon";
                        taskDiffType = "This task was added.";
                        break;

                      case "DELETED":
                        diffIcon = "diff-deleted-icon";
                        taskDiffType = "This task was deleted.";
                        break;

                      case "MODIFIED":
                        diffIcon = "diff-modified-icon";
                        taskDiffType = "This task was modified.";
                        break;
                    }
                    diffHtml = React.createElement("span", {
                        className: "diff-type-icon " + diffIcon,
                        title: taskDiffType
                    });
                    var isOpenInMobile = isMobile();
                    var hoverTitle = taskDiffType == "" ? "No Value" : taskDiffType;
                }
                var jsonData = TaskStore.getData(this.props.storeId), tnum = this.props.items.taskNumber, ttitle = this.props.items.title.replace(/"/g, "'").replace(/[\[\]']+/g, "");
                var url = jsonData.baseUrl + "ttn/" + jsonData.tmailNum + "#task=" + jsonData.secNum + ":" + tnum, link = "[ TASK " + tnum + ' titled "' + ttitle + '" in "' + jsonData.sectionTitle + '" in THREAD "' + jsonData.tmailSubject + '", ' + url + " ]";
                if (jsonData.mailboxType == "forward") {
                    url = jsonData.baseUrl + "ttn/" + jsonData.tmailNum + "#forwarded-task=" + jsonData.fwdtmailNum + ":" + jsonData.secNum + ":" + tnum;
                    var isInComment = jsonData.cnum ? " in FORWARDED COMMENT " + jsonData.cnum : " ";
                    link = "[ FORWARDED TASK " + tnum + ' titled "' + ttitle + '" in "' + jsonData.sectionTitle + '"' + isInComment + " in " + jsonData.tmailNum + ' in THREAD "' + jsonData.tmailSubject + '", ' + url + " ]";
                }
                return React.createElement("div", {
                    className: headerCls
                }, this.props.items.newItem ? null : React.createElement(TaskCollapseArrow, {
                    items: this.props.items,
                    keyVal: this.props.keyVal,
                    mode: this.props.mode,
                    divId: this.props.divId,
                    taskNum: this.props.taskNum,
                    storeId: storeId,
                    slideTask: this.props.slideTask,
                    toggleTaskIndex: this.props.toggleTaskIndex
                }), React.createElement("div", {
                    className: "request-icon-outter",
                    style: {
                        display: style
                    }
                }, React.createElement("i", {
                    className: this.props.items.isFromChecklist ? "task-checklist-icon" : "task-r-icon",
                    name: "task-icon-" + this.props.keyVal
                }), React.createElement("div", {
                    className: "taskId"
                }, React.createElement("span", {
                    name: "task-number-" + this.props.items.index,
                    className: newItem ? "newTask content-id header-task-number" : "content-id header-task-number"
                }, "#", newItem ? "New" : this.props.items.taskNumber)), !isMobile() && !newItem && jsonData.mailboxType != "draft" ? React.createElement("div", {
                    style: {
                        left: "-34px",
                        position: "absolute",
                        top: "1px"
                    }
                }, React.createElement("span", {
                    className: "copied-span hidden"
                }, "Task Link Copied"), React.createElement("div", {
                    name: "task-number-header-copy-" + this.props.items.index,
                    className: "copy-task-link-menu",
                    title: "Copy Task Link",
                    "data-clipboard-text": link
                })) : null, diffHtml), React.createElement("div", {
                    className: "title-outter " + titleOutter,
                    style: {
                        display: style
                    }
                }, isMobile() && !newItem && jsonData.mailboxType != "draft" ? React.createElement("div", {
                    style: {
                        position: "relative",
                        cursor: "pointer"
                    }
                }, React.createElement("span", {
                    className: "copied-mobile-span copied-span hidden"
                }, "Task Link Copied"), React.createElement("h4", {
                    className: "task-header-title panel-title copy-task-link-mobile-menu",
                    "data-clipboard-text": link
                }, " ", this.props.items.title, " ")) : React.createElement("h4", {
                    className: "task-header-title panel-title"
                }, " ", this.props.items.title, " ")), isDiffSection && typeof this.props.items.diffOpType != "undefined" && this.props.items.diffOpType == "DELETED" || typeof this.props.items.isFromChecklist != "undefined" && this.props.items.isFromChecklist == true && this.props.isChecklist == true ? null : React.createElement(TaskPriorityHeader, {
                    priority: this.props.items.priority,
                    mode: this.props.mode,
                    keyVal: this.props.keyVal,
                    items: this.props.items,
                    taskNum: this.props.taskNum,
                    storeId: storeId,
                    slideTask: this.props.slideTask,
                    toggleTaskIndex: this.props.toggleTaskIndex
                }), isDiffSection && typeof this.props.items.diffOpType != "undefined" && this.props.items.diffOpType == "DELETED" || typeof this.props.items.isFromChecklist != "undefined" && this.props.items.isFromChecklist == true && this.props.isChecklist == true ? null : React.createElement(TaskStateHeader, {
                    state: this.props.items.state,
                    mode: this.props.mode,
                    keyVal: this.props.keyVal,
                    items: this.props.items,
                    taskNum: this.props.taskNum,
                    storeId: storeId,
                    slideTask: this.props.slideTask,
                    toggleTaskIndex: this.props.toggleTaskIndex
                }), React.createElement("div", {
                    className: "row"
                }, React.createElement("div", {
                    className: "col-md-12",
                    style: {
                        marginTop: "10px"
                    }
                }, isDiffSection && typeof this.props.items.diffOpType != "undefined" && this.props.items.diffOpType == "DELETED" || this.props.mode == "template" ? null : React.createElement("div", {
                    className: "col-md-5 header-requester-outter",
                    style: {
                        display: style,
                        position: "relative",
                        width: "auto"
                    }
                }, React.createElement(TaskRequester, {
                    requester: this.props.items.requester,
                    allWriters: this.props.allWriters,
                    storeId: storeId,
                    mode: this.props.mode,
                    slideTask: this.props.slideTask,
                    toggleTaskIndex: this.props.toggleTaskIndex
                })), isDiffSection && typeof this.props.items.diffOpType != "undefined" && this.props.items.diffOpType == "DELETED" ? null : React.createElement("div", {
                    className: "col-md-7",
                    style: {
                        display: style,
                        position: "relative",
                        width: "auto",
                        float: "right"
                    }
                }, React.createElement(TaskAssignees, {
                    assignees: this.props.items.assignees,
                    allWriters: this.props.allWriters,
                    writers: this.props.writers,
                    favWriters: this.props.favWriters,
                    currentUser: this.props.currentUser,
                    storeId: storeId,
                    mode: this.props.mode,
                    slideTask: this.props.slideTask,
                    toggleTaskIndex: this.props.toggleTaskIndex
                })))), React.createElement("div", {
                    className: "row"
                }, React.createElement("div", {
                    className: "col-md-12 taskDiffSentenceOutter"
                }, this.returnAditionalInfo(additionalInfo, "titleChanged"), this.returnAditionalInfo(additionalInfo, "stateChange"), this.returnAditionalInfo(additionalInfo, "requesterChange"), this.returnAditionalInfo(additionalInfo, "assigneeChange"), this.returnAditionalInfo(additionalInfo, "descriptionChanged"))));
            }
        });
        module.exports = TaskListsCompHeader;
    }, {
        "../stores/TaskStore": 12,
        "../stores/WritersStore": 13,
        "./TaskCollapseArrow.react": 5,
        "./TaskStateReadViewHtml.react": 9,
        "clipboard/dist/clipboard.min": 16,
        "create-react-class": 18,
        react: "react",
        "react-awesome-popover": 27,
        "react-dom": "react-dom"
    } ],
    9: [ function(require, module, exports) {
        var React = require("react");
        var createReactClass = require("create-react-class");
        var TaskStateReadViewHtml = createReactClass({
            render: function() {
                var state = this.props.taskState;
                var html = "";
                switch (state) {
                  case "Accepted":
                    html = React.createElement("span", {
                        "data-state": "Accepted",
                        className: "state-actions taskState accepted readView"
                    }, "Accepted");
                    break;

                  case "Unstarted":
                    html = React.createElement("span", {
                        "data-state": "Unstarted",
                        className: "state-actions taskState start btn btn-info readView",
                        "data-title": "disabled-button"
                    }, "Start");
                    break;

                  case "Started":
                    html = React.createElement("span", {
                        "data-state": "Started",
                        className: "state-actions taskState start btn btn-info readView",
                        "data-title": "disabled-button"
                    }, "Finish");
                    break;

                  case "Finished":
                    html = React.createElement("span", {
                        "data-state": "Finished",
                        className: "state-actions taskState delivered btn btn-info readView",
                        "data-title": "disabled-button"
                    }, "Deliver");
                    break;

                  case "Delivered":
                    html = React.createElement("span", {
                        "data-state": "Delivered",
                        className: "state-actions"
                    }, React.createElement("span", {
                        className: "taskState delivered btn btn-success readView",
                        "data-title": "disabled-button"
                    }, "Accept"), React.createElement("span", {
                        className: "taskState rejected btn btn-danger",
                        "data-title": "disabled-button"
                    }, "Reject"));
                    break;

                  case "Rejected":
                    html = React.createElement("span", {
                        "data-state": "Rejected",
                        className: "state-actions taskState rejected btn btn-info readView",
                        "data-title": "disabled-button"
                    }, "ReStart");
                    break;

                  case "NoLongerApplicable":
                    html = React.createElement("span", {
                        "data-state": "NoLongerApplicable",
                        className: "state-actions taskState btn noLonger pull-right",
                        title: "No Longer Applicable"
                    }, "No Longer Appl.");
                    break;

                  default:
                    break;
                }
                return React.createElement("div", {
                    style: {
                        position: "relative"
                    }
                }, html);
            }
        });
        module.exports = TaskStateReadViewHtml;
    }, {
        "create-react-class": 18,
        react: "react"
    } ],
    10: [ function(require, module, exports) {
        var keyMirror = require("fbjs/lib/keyMirror");
        module.exports = keyMirror({
            RECIEVE_TASKDATA: null,
            UPDATE_TASKDATA: null,
            GET_UPDATED_JSON: null,
            DELETE_TASK: null,
            ADD_NEW_TASK: null,
            ADD_NEW_DIVIDER: null,
            CANCEL_NEW_TASK: null,
            SAVE_NEW_TASK: null,
            CHANGE_VIEW_MODE: null,
            MANUAL_SORT_DATA: null,
            SET_WRITERS: null,
            SET_FAV_WRITERS: null,
            UPDATE_WRITERS: null,
            UPDATE_FAV_WRITERS: null,
            CHECK_TASK_EMPTY_SLIDE: null,
            TASKS_SORT_BY: null,
            TASKS_FILTER_BY: null,
            TASK_SLIDE_TOGGLE: null
        });
    }, {
        "fbjs/lib/keyMirror": 23
    } ],
    11: [ function(require, module, exports) {
        var Dispatcher = require("flux").Dispatcher;
        var AppDispatcher = new Dispatcher();
        AppDispatcher.handleAction = function(action) {
            this.dispatch({
                source: "VIEW_ACTION",
                action: action
            });
        };
        module.exports = AppDispatcher;
    }, {
        flux: "flux"
    } ],
    12: [ function(require, module, exports) {
        var AppDispatcher = require("../dispatcher/AppDispatcher");
        var EventEmitter = require("events").EventEmitter;
        var TaskConstants = require("../constants/TaskConstants");
        var _ = require("underscore");
        var _taskData = [];
        var _stateData, _editViewData = [];
        var addedTask = false;
        function loadTaskData(data, storeId) {
            _editViewData[storeId] = JSON.parse(JSON.stringify(data));
            _taskData[storeId] = data;
            addedTask = false;
            var count = 0;
            var value = 0;
            var arr = [];
            var uniqueVals = [];
            if (_taskData[storeId].taskables && _taskData[storeId].taskables.length > 0) {
                _taskData[storeId].taskables.map(function(val, key) {
                    if (val.type == "TASK_REQUEST") {
                        var fields = val.taskNumber.toString().split(/_/);
                        if (fields[1]) {
                            if (value < parseInt(fields[1])) {
                                value = parseInt(fields[1]);
                            }
                        } else {
                            if (value < parseInt(val.taskNumber)) {
                                value = parseInt(val.taskNumber);
                            }
                        }
                        if (val.assignees) {
                            arr = $.merge(arr, val.assignees);
                        }
                        if (val.requester) {
                            arr.push(val.requester);
                        }
                        if (!val.priority) {
                            val.priority = "NoPrioritySet";
                        }
                    }
                    _taskData[storeId].taskables[key].taskId = "tid_" + key;
                });
            }
            _taskData[storeId].lastTaskNumber = value;
            _taskData[storeId].additionalActors = [];
            $.each(arr, function(i, el) {
                if ($.inArray(el, uniqueVals) === -1) uniqueVals.push(el);
            });
            if (uniqueVals.length > 0) {
                _taskData[storeId].additionalActors = uniqueVals;
            }
        }
        function updateData(key, indexName, indexValue, storeId) {
            if (key == "Null" && indexName == "taskNum") {
                _taskData[storeId].taskNum = indexValue;
                _taskData[storeId].expandTask = true;
            } else {
                _taskData[storeId].taskables[key][indexName] = indexValue;
                if (typeof _taskData[storeId].taskables[key].shouldUpdateHeader != "undefined") {
                    delete _taskData[storeId].taskables[key].shouldUpdateHeader;
                }
                if (typeof _taskData[storeId].updateComponent != "undefined") {
                    delete _taskData[storeId].updateComponent;
                }
                if (indexName == "title") {
                    if (_taskData[storeId].taskables[key]["title"] == "") {
                        _taskData[storeId].taskables[key].isTitleEmpty = true;
                        _taskData[storeId].isValidationIssue = true;
                    } else {
                        delete _taskData[storeId].taskables[key].isTitleEmpty;
                        delete _taskData[storeId].isValidationIssue;
                    }
                }
                if (indexName == "title" || indexName == "assignees" || indexName == "state" || indexName == "requester" || indexName == "description" || indexName == "priority") {
                    _taskData[storeId].taskables[key].shouldUpdateHeader = true;
                }
            }
            if (indexName == "state") {
                _taskData[storeId].updateComponent = true;
            }
        }
        function getUpdatedJson(storeId) {
            if (typeof _taskData[storeId].sortData != "undefined") {
                var newData = [];
                _taskData[storeId].sortData.map(function(val, key) {
                    var fields = val.split(/sort_/);
                    _taskData[storeId].taskables[fields[1]].index = key;
                    newData.push(_taskData[storeId].taskables[fields[1]]);
                    delete _taskData[storeId].taskables[key].shouldUpdateHeader;
                });
                _taskData[storeId].taskables = newData;
                delete _taskData[storeId].sortData;
            }
            var newData = [];
            _taskData[storeId].taskables.map(function(val, key) {
                if (typeof val.deleted == "undefined" || val.deleted == false) {
                    val.index = newData.length;
                    newData.push(val);
                }
                delete _taskData[storeId].taskables[key].taskId;
            });
            _taskData[storeId].taskables = newData;
            if (typeof _taskData[storeId].sortBy != "undefined") {
                delete _taskData[storeId].sortBy;
            }
            if (typeof _taskData[storeId].filterBy != "undefined") {
                delete _taskData[storeId].filterBy;
            }
            if (typeof _taskData[storeId].updateComponent != "undefined") {
                delete _taskData[storeId].updateComponent;
            }
            if (typeof _taskData[storeId].slideTask != "undefined") {
                delete _taskData[storeId].slideTask;
            }
            if (typeof _taskData[storeId].toggleTaskIndex != "undefined") {
                delete _taskData[storeId].toggleTaskIndex;
            }
            data = _taskData[storeId];
        }
        function changeViewMode(mode, storeId) {
            if (mode == "template") {
                _taskData[storeId] = JSON.parse(JSON.stringify(_editViewData[storeId]));
                _taskData[storeId].taskables.map(function(val, key) {
                    val.state = "Unstarted";
                    val.requester = "";
                    val.assignees = [];
                });
            } else {
                _taskData[storeId] = JSON.parse(JSON.stringify(_editViewData[storeId]));
            }
            _taskData[storeId].mode = mode;
            addedTask = false;
        }
        function manualSortData(data, storeId) {
            _taskData[storeId].sortData = data;
        }
        function tasksFilterBy(filterBy, storeId) {
            if (typeof _taskData[storeId].sortData != "undefined" && filterBy != "all") {
                var newData = [];
                _taskData[storeId].sortData.map(function(val, key) {
                    var fields = val.split(/sort_/);
                    _taskData[storeId].taskables[fields[1]].index = key;
                    newData.push(_taskData[storeId].taskables[fields[1]]);
                });
                _taskData[storeId].taskables = newData;
                delete _taskData[storeId].sortData;
            }
            _taskData[storeId].filterBy = filterBy;
        }
        function slideTaskAndCheckTitle(slideId, arrowId) {
            if (!$(slideId).hasClass("in")) {
                $(slideId).parent().addClass("impBackgroundFFF");
                $(slideId).parent().children(".panel-heading").children("div").not(".arrow-icon-outter").css({
                    display: "none"
                });
            } else {
                $(slideId).parent().removeClass("impBackgroundFFF");
                $(slideId).parent().children(".panel-heading").children("div").not(".arrow-icon-outter").css({
                    display: "block"
                });
            }
            $(slideId).slideToggle(500);
            $(slideId).toggleClass("in");
            if ($(arrowId).hasClass("glyphicon-chevron-right")) {
                $(arrowId).removeClass("glyphicon-chevron-right");
                $(arrowId).addClass("glyphicon-chevron-down");
            } else {
                $(arrowId).removeClass("glyphicon-chevron-down");
                $(arrowId).addClass("glyphicon-chevron-right");
            }
        }
        function slideTaskToggle(key, storeId, view) {
            _taskData[storeId].toggleTaskIndex = !view ? -1 : key;
            _taskData[storeId].slideTask = view;
            _taskData[storeId].taskables[key].shouldUpdateHeader = true;
        }
        function tasksSortBy(sortBy, storeId) {
            if (typeof _taskData[storeId].sortData != "undefined" && (sortBy != "" || sortBy != "manual")) {
                var newData = [];
                _taskData[storeId].sortData.map(function(val, key) {
                    var fields = val.split(/sort_/);
                    _taskData[storeId].taskables[fields[1]].index = key;
                    newData.push(_taskData[storeId].taskables[fields[1]]);
                });
                _taskData[storeId].taskables = newData;
                delete _taskData[storeId].sortData;
            }
            _taskData[storeId].sortBy = sortBy;
        }
        var TaskStore = _.extend({}, EventEmitter.prototype, {
            getData: function(storeId) {
                if (_taskData[storeId].taskNum > 0 && _taskData[storeId].taskNum != undefined && _taskData[storeId].taskNum != null && _taskData[storeId].taskNum != "undefined" && _taskData[storeId].taskNum != "null" && _taskData[storeId].taskNum != "") {
                    if (!_taskData[storeId].filterBy) _taskData[storeId].filterBy = "all";
                } else {
                    if (!_taskData[storeId].filterBy) _taskData[storeId].filterBy = "openTasks";
                }
                return _taskData[storeId];
            },
            getStoreJson: function(storeId) {
                return _taskData[storeId];
            },
            emitChange: function() {
                this.emit("change");
            },
            addChangeListener: function(callback) {
                this.on("change", callback);
            },
            removeChangeListener: function(callback) {
                this.removeListener("change", callback);
            }
        });
        AppDispatcher.register(function(payload) {
            var action = payload.action;
            var text;
            switch (action.actionType) {
              case TaskConstants.RECIEVE_TASKDATA:
                loadTaskData(action.data, action.storeId);
                break;

              case TaskConstants.UPDATE_TASKDATA:
                updateData(action.key, action.indexName, action.value, action.storeId);
                TaskStore.emitChange();
                break;

              case TaskConstants.GET_UPDATED_JSON:
                getUpdatedJson(action.storeId);
                TaskStore.emitChange();
                break;

              case TaskConstants.CHANGE_VIEW_MODE:
                changeViewMode(action.flag, action.storeId);
                TaskStore.emitChange();
                break;

              case TaskConstants.MANUAL_SORT_DATA:
                manualSortData(action.data, action.storeId);
                break;

              case TaskConstants.CHECK_TASK_EMPTY_SLIDE:
                slideTaskAndCheckTitle(action.slideId, action.arrowId);
                break;

              case TaskConstants.TASK_SLIDE_TOGGLE:
                slideTaskToggle(action.key, action.storeId, action.view);
                TaskStore.emitChange();
                break;

              case TaskConstants.TASKS_SORT_BY:
                tasksSortBy(action.sortBy, action.storeId);
                TaskStore.emitChange();
                break;

              case TaskConstants.TASKS_FILTER_BY:
                tasksFilterBy(action.filterBy, action.storeId);
                TaskStore.emitChange();
                break;
            }
            return true;
        });
        module.exports = TaskStore;
    }, {
        "../constants/TaskConstants": 10,
        "../dispatcher/AppDispatcher": 11,
        events: 19,
        underscore: "underscore"
    } ],
    13: [ function(require, module, exports) {
        var AppDispatcher = require("../dispatcher/AppDispatcher");
        var EventEmitter = require("events").EventEmitter;
        var TaskConstants = require("../constants/TaskConstants");
        var _ = require("underscore");
        var _writers = {};
        var _stateData, _changeViewData = {};
        var addedTask = false;
        function loadTaskData(data) {
            _writers = data;
        }
        function updateWriters(writers, favWriters, value) {
            if (favWriters) {
                favWriters.map(function(val, key) {
                    if (val.address == value) {
                        writers.push(val);
                    }
                });
            }
            _writers = writers;
        }
        var WritersStore = _.extend({}, EventEmitter.prototype, {
            getData: function() {
                return _writers;
            },
            emitChange: function() {
                this.emit("change");
            },
            addChangeListener: function(callback) {
                this.on("change", callback);
            },
            removeChangeListener: function(callback) {
                this.removeListener("change", callback);
            }
        });
        AppDispatcher.register(function(payload) {
            var action = payload.action;
            var text;
            switch (action.actionType) {
              case TaskConstants.SET_WRITERS:
                loadTaskData(action.writers);
                break;

              case TaskConstants.UPDATE_WRITERS:
                updateWriters(action.writers, action.favWriters, action.value);
                break;

              default:
                return true;
            }
            WritersStore.emitChange();
            return true;
        });
        module.exports = WritersStore;
    }, {
        "../constants/TaskConstants": 10,
        "../dispatcher/AppDispatcher": 11,
        events: 19,
        underscore: "underscore"
    } ],
    14: [ function(require, module, exports) {
        var AppDispatcher = require("../dispatcher/AppDispatcher");
        var EventEmitter = require("events").EventEmitter;
        var TaskConstants = require("../constants/TaskConstants");
        var _ = require("underscore");
        var _favWriters = {};
        var _stateData, _changeViewData = {};
        var addedTask = false;
        function loadTaskData(favWriters, writers) {
            var data = [];
            if (typeof favWriters != "undefined") {
                var obj = favWriters;
                Object.keys(obj).map(function(key) {
                    var arr = [];
                    var addressExists = false;
                    var writerAddress = "";
                    arr = {
                        name: obj[key][0],
                        address: obj[key][1],
                        type: obj[key][2],
                        org_name: obj[key][3],
                        initial: obj[key][4] ? obj[key][4] : ""
                    };
                    writerAddress = obj[key][1];
                    if (writers) {
                        writers.map(function(val, key) {
                            if (val.defaultAddress == writerAddress) {
                                addressExists = true;
                            }
                        });
                    }
                    if (!addressExists) {
                        data.push(arr);
                    }
                });
            }
            _favWriters = data;
        }
        function updateFavWriters(writers, value) {
            writers.map(function(val, key) {
                if (val.address == value) {
                    writers.splice(key, 1);
                }
            });
            _favWriters = writers;
        }
        var FavWritersStore = _.extend({}, EventEmitter.prototype, {
            getData: function() {
                return _favWriters;
            },
            emitChange: function() {
                this.emit("change");
            },
            addChangeListener: function(callback) {
                this.on("change", callback);
            },
            removeChangeListener: function(callback) {
                this.removeListener("change", callback);
            }
        });
        AppDispatcher.register(function(payload) {
            var action = payload.action;
            var text;
            switch (action.actionType) {
              case TaskConstants.SET_FAV_WRITERS:
                loadTaskData(action.favWriters, action.writers);
                break;

              case TaskConstants.UPDATE_FAV_WRITERS:
                updateFavWriters(action.writers, action.value);
                break;

              default:
                return true;
            }
            FavWritersStore.emitChange();
            return true;
        });
        module.exports = FavWritersStore;
    }, {
        "../constants/TaskConstants": 10,
        "../dispatcher/AppDispatcher": 11,
        events: 19,
        underscore: "underscore"
    } ],
    15: [ function(require, module, exports) {
        var TaskActions = require("../actions/TaskActions");
        var writersActions = require("../actions/WritersActions");
        module.exports = {
            setTaskData: function(data, storeId) {
                TaskActions.recieveTaskData(data, storeId);
            },
            setWritersData: function(writers) {
                writersActions.setWriters(writers);
            },
            setFavWritersData: function(favWriters, writers) {
                writersActions.setFavWriters(favWriters, writers);
            }
        };
    }, {
        "../actions/TaskActions": 1,
        "../actions/WritersActions": 2
    } ],
    16: [ function(require, module, exports) {
        (function(global) {
            !function(t) {
                if ("object" == typeof exports && "undefined" != typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else {
                    var e;
                    e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, 
                    e.Clipboard = t();
                }
            }(function() {
                var t, e, n;
                return function t(e, n, o) {
                    function i(a, c) {
                        if (!n[a]) {
                            if (!e[a]) {
                                var l = "function" == typeof require && require;
                                if (!c && l) return l(a, !0);
                                if (r) return r(a, !0);
                                var s = new Error("Cannot find module '" + a + "'");
                                throw s.code = "MODULE_NOT_FOUND", s;
                            }
                            var u = n[a] = {
                                exports: {}
                            };
                            e[a][0].call(u.exports, function(t) {
                                var n = e[a][1][t];
                                return i(n || t);
                            }, u, u.exports, t, e, n, o);
                        }
                        return n[a].exports;
                    }
                    for (var r = "function" == typeof require && require, a = 0; a < o.length; a++) i(o[a]);
                    return i;
                }({
                    1: [ function(t, e, n) {
                        function o(t, e) {
                            for (;t && t.nodeType !== i; ) {
                                if ("function" == typeof t.matches && t.matches(e)) return t;
                                t = t.parentNode;
                            }
                        }
                        var i = 9;
                        if ("undefined" != typeof Element && !Element.prototype.matches) {
                            var r = Element.prototype;
                            r.matches = r.matchesSelector || r.mozMatchesSelector || r.msMatchesSelector || r.oMatchesSelector || r.webkitMatchesSelector;
                        }
                        e.exports = o;
                    }, {} ],
                    2: [ function(t, e, n) {
                        function o(t, e, n, o, r) {
                            var a = i.apply(this, arguments);
                            return t.addEventListener(n, a, r), {
                                destroy: function() {
                                    t.removeEventListener(n, a, r);
                                }
                            };
                        }
                        function i(t, e, n, o) {
                            return function(n) {
                                n.delegateTarget = r(n.target, e), n.delegateTarget && o.call(t, n);
                            };
                        }
                        var r = t("./closest");
                        e.exports = o;
                    }, {
                        "./closest": 1
                    } ],
                    3: [ function(t, e, n) {
                        n.node = function(t) {
                            return void 0 !== t && t instanceof HTMLElement && 1 === t.nodeType;
                        }, n.nodeList = function(t) {
                            var e = Object.prototype.toString.call(t);
                            return void 0 !== t && ("[object NodeList]" === e || "[object HTMLCollection]" === e) && "length" in t && (0 === t.length || n.node(t[0]));
                        }, n.string = function(t) {
                            return "string" == typeof t || t instanceof String;
                        }, n.fn = function(t) {
                            return "[object Function]" === Object.prototype.toString.call(t);
                        };
                    }, {} ],
                    4: [ function(t, e, n) {
                        function o(t, e, n) {
                            if (!t && !e && !n) throw new Error("Missing required arguments");
                            if (!c.string(e)) throw new TypeError("Second argument must be a String");
                            if (!c.fn(n)) throw new TypeError("Third argument must be a Function");
                            if (c.node(t)) return i(t, e, n);
                            if (c.nodeList(t)) return r(t, e, n);
                            if (c.string(t)) return a(t, e, n);
                            throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
                        }
                        function i(t, e, n) {
                            return t.addEventListener(e, n), {
                                destroy: function() {
                                    t.removeEventListener(e, n);
                                }
                            };
                        }
                        function r(t, e, n) {
                            return Array.prototype.forEach.call(t, function(t) {
                                t.addEventListener(e, n);
                            }), {
                                destroy: function() {
                                    Array.prototype.forEach.call(t, function(t) {
                                        t.removeEventListener(e, n);
                                    });
                                }
                            };
                        }
                        function a(t, e, n) {
                            return l(document.body, t, e, n);
                        }
                        var c = t("./is"), l = t("delegate");
                        e.exports = o;
                    }, {
                        "./is": 3,
                        delegate: 2
                    } ],
                    5: [ function(t, e, n) {
                        function o(t) {
                            var e;
                            if ("SELECT" === t.nodeName) t.focus(), e = t.value; else if ("INPUT" === t.nodeName || "TEXTAREA" === t.nodeName) {
                                var n = t.hasAttribute("readonly");
                                n || t.setAttribute("readonly", ""), t.select(), t.setSelectionRange(0, t.value.length), 
                                n || t.removeAttribute("readonly"), e = t.value;
                            } else {
                                t.hasAttribute("contenteditable") && t.focus();
                                var o = window.getSelection(), i = document.createRange();
                                i.selectNodeContents(t), o.removeAllRanges(), o.addRange(i), e = o.toString();
                            }
                            return e;
                        }
                        e.exports = o;
                    }, {} ],
                    6: [ function(t, e, n) {
                        function o() {}
                        o.prototype = {
                            on: function(t, e, n) {
                                var o = this.e || (this.e = {});
                                return (o[t] || (o[t] = [])).push({
                                    fn: e,
                                    ctx: n
                                }), this;
                            },
                            once: function(t, e, n) {
                                function o() {
                                    i.off(t, o), e.apply(n, arguments);
                                }
                                var i = this;
                                return o._ = e, this.on(t, o, n);
                            },
                            emit: function(t) {
                                var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), o = 0, i = n.length;
                                for (o; o < i; o++) n[o].fn.apply(n[o].ctx, e);
                                return this;
                            },
                            off: function(t, e) {
                                var n = this.e || (this.e = {}), o = n[t], i = [];
                                if (o && e) for (var r = 0, a = o.length; r < a; r++) o[r].fn !== e && o[r].fn._ !== e && i.push(o[r]);
                                return i.length ? n[t] = i : delete n[t], this;
                            }
                        }, e.exports = o;
                    }, {} ],
                    7: [ function(e, n, o) {
                        !function(i, r) {
                            if ("function" == typeof t && t.amd) t([ "module", "select" ], r); else if (void 0 !== o) r(n, e("select")); else {
                                var a = {
                                    exports: {}
                                };
                                r(a, i.select), i.clipboardAction = a.exports;
                            }
                        }(this, function(t, e) {
                            "use strict";
                            function n(t) {
                                return t && t.__esModule ? t : {
                                    default: t
                                };
                            }
                            function o(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                            }
                            var i = n(e), r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                                return typeof t;
                            } : function(t) {
                                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                            }, a = function() {
                                function t(t, e) {
                                    for (var n = 0; n < e.length; n++) {
                                        var o = e[n];
                                        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), 
                                        Object.defineProperty(t, o.key, o);
                                    }
                                }
                                return function(e, n, o) {
                                    return n && t(e.prototype, n), o && t(e, o), e;
                                };
                            }(), c = function() {
                                function t(e) {
                                    o(this, t), this.resolveOptions(e), this.initSelection();
                                }
                                return a(t, [ {
                                    key: "resolveOptions",
                                    value: function t() {
                                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                        this.action = e.action, this.container = e.container, this.emitter = e.emitter, 
                                        this.target = e.target, this.text = e.text, this.trigger = e.trigger, this.selectedText = "";
                                    }
                                }, {
                                    key: "initSelection",
                                    value: function t() {
                                        this.text ? this.selectFake() : this.target && this.selectTarget();
                                    }
                                }, {
                                    key: "selectFake",
                                    value: function t() {
                                        var e = this, n = "rtl" == document.documentElement.getAttribute("dir");
                                        this.removeFake(), this.fakeHandlerCallback = function() {
                                            return e.removeFake();
                                        }, this.fakeHandler = this.container.addEventListener("click", this.fakeHandlerCallback) || !0, 
                                        this.fakeElem = document.createElement("textarea"), this.fakeElem.style.fontSize = "12pt", 
                                        this.fakeElem.style.border = "0", this.fakeElem.style.padding = "0", this.fakeElem.style.margin = "0", 
                                        this.fakeElem.style.position = "absolute", this.fakeElem.style[n ? "right" : "left"] = "-9999px";
                                        var o = window.pageYOffset || document.documentElement.scrollTop;
                                        this.fakeElem.style.top = o + "px", this.fakeElem.setAttribute("readonly", ""), 
                                        this.fakeElem.value = this.text, this.container.appendChild(this.fakeElem), this.selectedText = (0, 
                                        i.default)(this.fakeElem), this.copyText();
                                    }
                                }, {
                                    key: "removeFake",
                                    value: function t() {
                                        this.fakeHandler && (this.container.removeEventListener("click", this.fakeHandlerCallback), 
                                        this.fakeHandler = null, this.fakeHandlerCallback = null), this.fakeElem && (this.container.removeChild(this.fakeElem), 
                                        this.fakeElem = null);
                                    }
                                }, {
                                    key: "selectTarget",
                                    value: function t() {
                                        this.selectedText = (0, i.default)(this.target), this.copyText();
                                    }
                                }, {
                                    key: "copyText",
                                    value: function t() {
                                        var e = void 0;
                                        try {
                                            e = document.execCommand(this.action);
                                        } catch (t) {
                                            e = !1;
                                        }
                                        this.handleResult(e);
                                    }
                                }, {
                                    key: "handleResult",
                                    value: function t(e) {
                                        this.emitter.emit(e ? "success" : "error", {
                                            action: this.action,
                                            text: this.selectedText,
                                            trigger: this.trigger,
                                            clearSelection: this.clearSelection.bind(this)
                                        });
                                    }
                                }, {
                                    key: "clearSelection",
                                    value: function t() {
                                        this.trigger && this.trigger.focus(), window.getSelection().removeAllRanges();
                                    }
                                }, {
                                    key: "destroy",
                                    value: function t() {
                                        this.removeFake();
                                    }
                                }, {
                                    key: "action",
                                    set: function t() {
                                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "copy";
                                        if (this._action = e, "copy" !== this._action && "cut" !== this._action) throw new Error('Invalid "action" value, use either "copy" or "cut"');
                                    },
                                    get: function t() {
                                        return this._action;
                                    }
                                }, {
                                    key: "target",
                                    set: function t(e) {
                                        if (void 0 !== e) {
                                            if (!e || "object" !== (void 0 === e ? "undefined" : r(e)) || 1 !== e.nodeType) throw new Error('Invalid "target" value, use a valid Element');
                                            if ("copy" === this.action && e.hasAttribute("disabled")) throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                                            if ("cut" === this.action && (e.hasAttribute("readonly") || e.hasAttribute("disabled"))) throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                                            this._target = e;
                                        }
                                    },
                                    get: function t() {
                                        return this._target;
                                    }
                                } ]), t;
                            }();
                            t.exports = c;
                        });
                    }, {
                        select: 5
                    } ],
                    8: [ function(e, n, o) {
                        !function(i, r) {
                            if ("function" == typeof t && t.amd) t([ "module", "./clipboard-action", "tiny-emitter", "good-listener" ], r); else if (void 0 !== o) r(n, e("./clipboard-action"), e("tiny-emitter"), e("good-listener")); else {
                                var a = {
                                    exports: {}
                                };
                                r(a, i.clipboardAction, i.tinyEmitter, i.goodListener), i.clipboard = a.exports;
                            }
                        }(this, function(t, e, n, o) {
                            "use strict";
                            function i(t) {
                                return t && t.__esModule ? t : {
                                    default: t
                                };
                            }
                            function r(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                            }
                            function a(t, e) {
                                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !e || "object" != typeof e && "function" != typeof e ? t : e;
                            }
                            function c(t, e) {
                                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                                t.prototype = Object.create(e && e.prototype, {
                                    constructor: {
                                        value: t,
                                        enumerable: !1,
                                        writable: !0,
                                        configurable: !0
                                    }
                                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
                            }
                            function l(t, e) {
                                var n = "data-clipboard-" + t;
                                if (e.hasAttribute(n)) return e.getAttribute(n);
                            }
                            var s = i(e), u = i(n), f = i(o), d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                                return typeof t;
                            } : function(t) {
                                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                            }, h = function() {
                                function t(t, e) {
                                    for (var n = 0; n < e.length; n++) {
                                        var o = e[n];
                                        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), 
                                        Object.defineProperty(t, o.key, o);
                                    }
                                }
                                return function(e, n, o) {
                                    return n && t(e.prototype, n), o && t(e, o), e;
                                };
                            }(), p = function(t) {
                                function e(t, n) {
                                    r(this, e);
                                    var o = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
                                    return o.resolveOptions(n), o.listenClick(t), o;
                                }
                                return c(e, t), h(e, [ {
                                    key: "resolveOptions",
                                    value: function t() {
                                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                        this.action = "function" == typeof e.action ? e.action : this.defaultAction, this.target = "function" == typeof e.target ? e.target : this.defaultTarget, 
                                        this.text = "function" == typeof e.text ? e.text : this.defaultText, this.container = "object" === d(e.container) ? e.container : document.body;
                                    }
                                }, {
                                    key: "listenClick",
                                    value: function t(e) {
                                        var n = this;
                                        this.listener = (0, f.default)(e, "click", function(t) {
                                            return n.onClick(t);
                                        });
                                    }
                                }, {
                                    key: "onClick",
                                    value: function t(e) {
                                        var n = e.delegateTarget || e.currentTarget;
                                        this.clipboardAction && (this.clipboardAction = null), this.clipboardAction = new s.default({
                                            action: this.action(n),
                                            target: this.target(n),
                                            text: this.text(n),
                                            container: this.container,
                                            trigger: n,
                                            emitter: this
                                        });
                                    }
                                }, {
                                    key: "defaultAction",
                                    value: function t(e) {
                                        return l("action", e);
                                    }
                                }, {
                                    key: "defaultTarget",
                                    value: function t(e) {
                                        var n = l("target", e);
                                        if (n) return document.querySelector(n);
                                    }
                                }, {
                                    key: "defaultText",
                                    value: function t(e) {
                                        return l("text", e);
                                    }
                                }, {
                                    key: "destroy",
                                    value: function t() {
                                        this.listener.destroy(), this.clipboardAction && (this.clipboardAction.destroy(), 
                                        this.clipboardAction = null);
                                    }
                                } ], [ {
                                    key: "isSupported",
                                    value: function t() {
                                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [ "copy", "cut" ], n = "string" == typeof e ? [ e ] : e, o = !!document.queryCommandSupported;
                                        return n.forEach(function(t) {
                                            o = o && !!document.queryCommandSupported(t);
                                        }), o;
                                    }
                                } ]), e;
                            }(u.default);
                            t.exports = p;
                        });
                    }, {
                        "./clipboard-action": 7,
                        "good-listener": 4,
                        "tiny-emitter": 6
                    } ]
                }, {}, [ 8 ])(8);
            });
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    17: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var _assign = require("object-assign");
            var emptyObject = require("fbjs/lib/emptyObject");
            var _invariant = require("fbjs/lib/invariant");
            if (process.env.NODE_ENV !== "production") {
                var warning = require("fbjs/lib/warning");
            }
            var MIXINS_KEY = "mixins";
            function identity(fn) {
                return fn;
            }
            var ReactPropTypeLocationNames;
            if (process.env.NODE_ENV !== "production") {
                ReactPropTypeLocationNames = {
                    prop: "prop",
                    context: "context",
                    childContext: "child context"
                };
            } else {
                ReactPropTypeLocationNames = {};
            }
            function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
                var injectedMixins = [];
                var ReactClassInterface = {
                    mixins: "DEFINE_MANY",
                    statics: "DEFINE_MANY",
                    propTypes: "DEFINE_MANY",
                    contextTypes: "DEFINE_MANY",
                    childContextTypes: "DEFINE_MANY",
                    getDefaultProps: "DEFINE_MANY_MERGED",
                    getInitialState: "DEFINE_MANY_MERGED",
                    getChildContext: "DEFINE_MANY_MERGED",
                    render: "DEFINE_ONCE",
                    componentWillMount: "DEFINE_MANY",
                    componentDidMount: "DEFINE_MANY",
                    componentWillReceiveProps: "DEFINE_MANY",
                    shouldComponentUpdate: "DEFINE_ONCE",
                    componentWillUpdate: "DEFINE_MANY",
                    componentDidUpdate: "DEFINE_MANY",
                    componentWillUnmount: "DEFINE_MANY",
                    UNSAFE_componentWillMount: "DEFINE_MANY",
                    UNSAFE_componentWillReceiveProps: "DEFINE_MANY",
                    UNSAFE_componentWillUpdate: "DEFINE_MANY",
                    updateComponent: "OVERRIDE_BASE"
                };
                var ReactClassStaticInterface = {
                    getDerivedStateFromProps: "DEFINE_MANY_MERGED"
                };
                var RESERVED_SPEC_KEYS = {
                    displayName: function(Constructor, displayName) {
                        Constructor.displayName = displayName;
                    },
                    mixins: function(Constructor, mixins) {
                        if (mixins) {
                            for (var i = 0; i < mixins.length; i++) {
                                mixSpecIntoComponent(Constructor, mixins[i]);
                            }
                        }
                    },
                    childContextTypes: function(Constructor, childContextTypes) {
                        if (process.env.NODE_ENV !== "production") {
                            validateTypeDef(Constructor, childContextTypes, "childContext");
                        }
                        Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
                    },
                    contextTypes: function(Constructor, contextTypes) {
                        if (process.env.NODE_ENV !== "production") {
                            validateTypeDef(Constructor, contextTypes, "context");
                        }
                        Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
                    },
                    getDefaultProps: function(Constructor, getDefaultProps) {
                        if (Constructor.getDefaultProps) {
                            Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
                        } else {
                            Constructor.getDefaultProps = getDefaultProps;
                        }
                    },
                    propTypes: function(Constructor, propTypes) {
                        if (process.env.NODE_ENV !== "production") {
                            validateTypeDef(Constructor, propTypes, "prop");
                        }
                        Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
                    },
                    statics: function(Constructor, statics) {
                        mixStaticSpecIntoComponent(Constructor, statics);
                    },
                    autobind: function() {}
                };
                function validateTypeDef(Constructor, typeDef, location) {
                    for (var propName in typeDef) {
                        if (typeDef.hasOwnProperty(propName)) {
                            if (process.env.NODE_ENV !== "production") {
                                warning(typeof typeDef[propName] === "function", "%s: %s type `%s` is invalid; it must be a function, usually from " + "React.PropTypes.", Constructor.displayName || "ReactClass", ReactPropTypeLocationNames[location], propName);
                            }
                        }
                    }
                }
                function validateMethodOverride(isAlreadyDefined, name) {
                    var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
                    if (ReactClassMixin.hasOwnProperty(name)) {
                        _invariant(specPolicy === "OVERRIDE_BASE", "ReactClassInterface: You are attempting to override " + "`%s` from your class specification. Ensure that your method names " + "do not overlap with React methods.", name);
                    }
                    if (isAlreadyDefined) {
                        _invariant(specPolicy === "DEFINE_MANY" || specPolicy === "DEFINE_MANY_MERGED", "ReactClassInterface: You are attempting to define " + "`%s` on your component more than once. This conflict may be due " + "to a mixin.", name);
                    }
                }
                function mixSpecIntoComponent(Constructor, spec) {
                    if (!spec) {
                        if (process.env.NODE_ENV !== "production") {
                            var typeofSpec = typeof spec;
                            var isMixinValid = typeofSpec === "object" && spec !== null;
                            if (process.env.NODE_ENV !== "production") {
                                warning(isMixinValid, "%s: You're attempting to include a mixin that is either null " + "or not an object. Check the mixins included by the component, " + "as well as any mixins they include themselves. " + "Expected object but got %s.", Constructor.displayName || "ReactClass", spec === null ? null : typeofSpec);
                            }
                        }
                        return;
                    }
                    _invariant(typeof spec !== "function", "ReactClass: You're attempting to " + "use a component class or function as a mixin. Instead, just use a " + "regular object.");
                    _invariant(!isValidElement(spec), "ReactClass: You're attempting to " + "use a component as a mixin. Instead, just use a regular object.");
                    var proto = Constructor.prototype;
                    var autoBindPairs = proto.__reactAutoBindPairs;
                    if (spec.hasOwnProperty(MIXINS_KEY)) {
                        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
                    }
                    for (var name in spec) {
                        if (!spec.hasOwnProperty(name)) {
                            continue;
                        }
                        if (name === MIXINS_KEY) {
                            continue;
                        }
                        var property = spec[name];
                        var isAlreadyDefined = proto.hasOwnProperty(name);
                        validateMethodOverride(isAlreadyDefined, name);
                        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
                            RESERVED_SPEC_KEYS[name](Constructor, property);
                        } else {
                            var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
                            var isFunction = typeof property === "function";
                            var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
                            if (shouldAutoBind) {
                                autoBindPairs.push(name, property);
                                proto[name] = property;
                            } else {
                                if (isAlreadyDefined) {
                                    var specPolicy = ReactClassInterface[name];
                                    _invariant(isReactClassMethod && (specPolicy === "DEFINE_MANY_MERGED" || specPolicy === "DEFINE_MANY"), "ReactClass: Unexpected spec policy %s for key %s " + "when mixing in component specs.", specPolicy, name);
                                    if (specPolicy === "DEFINE_MANY_MERGED") {
                                        proto[name] = createMergedResultFunction(proto[name], property);
                                    } else if (specPolicy === "DEFINE_MANY") {
                                        proto[name] = createChainedFunction(proto[name], property);
                                    }
                                } else {
                                    proto[name] = property;
                                    if (process.env.NODE_ENV !== "production") {
                                        if (typeof property === "function" && spec.displayName) {
                                            proto[name].displayName = spec.displayName + "_" + name;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                function mixStaticSpecIntoComponent(Constructor, statics) {
                    if (!statics) {
                        return;
                    }
                    for (var name in statics) {
                        var property = statics[name];
                        if (!statics.hasOwnProperty(name)) {
                            continue;
                        }
                        var isReserved = name in RESERVED_SPEC_KEYS;
                        _invariant(!isReserved, "ReactClass: You are attempting to define a reserved " + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + "as an instance property instead; it will still be accessible on the " + "constructor.", name);
                        var isAlreadyDefined = name in Constructor;
                        if (isAlreadyDefined) {
                            var specPolicy = ReactClassStaticInterface.hasOwnProperty(name) ? ReactClassStaticInterface[name] : null;
                            _invariant(specPolicy === "DEFINE_MANY_MERGED", "ReactClass: You are attempting to define " + "`%s` on your component more than once. This conflict may be " + "due to a mixin.", name);
                            Constructor[name] = createMergedResultFunction(Constructor[name], property);
                            return;
                        }
                        Constructor[name] = property;
                    }
                }
                function mergeIntoWithNoDuplicateKeys(one, two) {
                    _invariant(one && two && typeof one === "object" && typeof two === "object", "mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.");
                    for (var key in two) {
                        if (two.hasOwnProperty(key)) {
                            _invariant(one[key] === undefined, "mergeIntoWithNoDuplicateKeys(): " + "Tried to merge two objects with the same key: `%s`. This conflict " + "may be due to a mixin; in particular, this may be caused by two " + "getInitialState() or getDefaultProps() methods returning objects " + "with clashing keys.", key);
                            one[key] = two[key];
                        }
                    }
                    return one;
                }
                function createMergedResultFunction(one, two) {
                    return function mergedResult() {
                        var a = one.apply(this, arguments);
                        var b = two.apply(this, arguments);
                        if (a == null) {
                            return b;
                        } else if (b == null) {
                            return a;
                        }
                        var c = {};
                        mergeIntoWithNoDuplicateKeys(c, a);
                        mergeIntoWithNoDuplicateKeys(c, b);
                        return c;
                    };
                }
                function createChainedFunction(one, two) {
                    return function chainedFunction() {
                        one.apply(this, arguments);
                        two.apply(this, arguments);
                    };
                }
                function bindAutoBindMethod(component, method) {
                    var boundMethod = method.bind(component);
                    if (process.env.NODE_ENV !== "production") {
                        boundMethod.__reactBoundContext = component;
                        boundMethod.__reactBoundMethod = method;
                        boundMethod.__reactBoundArguments = null;
                        var componentName = component.constructor.displayName;
                        var _bind = boundMethod.bind;
                        boundMethod.bind = function(newThis) {
                            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                args[_key - 1] = arguments[_key];
                            }
                            if (newThis !== component && newThis !== null) {
                                if (process.env.NODE_ENV !== "production") {
                                    warning(false, "bind(): React component methods may only be bound to the " + "component instance. See %s", componentName);
                                }
                            } else if (!args.length) {
                                if (process.env.NODE_ENV !== "production") {
                                    warning(false, "bind(): You are binding a component method to the component. " + "React does this for you automatically in a high-performance " + "way, so you can safely remove this call. See %s", componentName);
                                }
                                return boundMethod;
                            }
                            var reboundMethod = _bind.apply(boundMethod, arguments);
                            reboundMethod.__reactBoundContext = component;
                            reboundMethod.__reactBoundMethod = method;
                            reboundMethod.__reactBoundArguments = args;
                            return reboundMethod;
                        };
                    }
                    return boundMethod;
                }
                function bindAutoBindMethods(component) {
                    var pairs = component.__reactAutoBindPairs;
                    for (var i = 0; i < pairs.length; i += 2) {
                        var autoBindKey = pairs[i];
                        var method = pairs[i + 1];
                        component[autoBindKey] = bindAutoBindMethod(component, method);
                    }
                }
                var IsMountedPreMixin = {
                    componentDidMount: function() {
                        this.__isMounted = true;
                    }
                };
                var IsMountedPostMixin = {
                    componentWillUnmount: function() {
                        this.__isMounted = false;
                    }
                };
                var ReactClassMixin = {
                    replaceState: function(newState, callback) {
                        this.updater.enqueueReplaceState(this, newState, callback);
                    },
                    isMounted: function() {
                        if (process.env.NODE_ENV !== "production") {
                            warning(this.__didWarnIsMounted, "%s: isMounted is deprecated. Instead, make sure to clean up " + "subscriptions and pending requests in componentWillUnmount to " + "prevent memory leaks.", this.constructor && this.constructor.displayName || this.name || "Component");
                            this.__didWarnIsMounted = true;
                        }
                        return !!this.__isMounted;
                    }
                };
                var ReactClassComponent = function() {};
                _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
                function createClass(spec) {
                    var Constructor = identity(function(props, context, updater) {
                        if (process.env.NODE_ENV !== "production") {
                            warning(this instanceof Constructor, "Something is calling a React component directly. Use a factory or " + "JSX instead. See: https://fb.me/react-legacyfactory");
                        }
                        if (this.__reactAutoBindPairs.length) {
                            bindAutoBindMethods(this);
                        }
                        this.props = props;
                        this.context = context;
                        this.refs = emptyObject;
                        this.updater = updater || ReactNoopUpdateQueue;
                        this.state = null;
                        var initialState = this.getInitialState ? this.getInitialState() : null;
                        if (process.env.NODE_ENV !== "production") {
                            if (initialState === undefined && this.getInitialState._isMockFunction) {
                                initialState = null;
                            }
                        }
                        _invariant(typeof initialState === "object" && !Array.isArray(initialState), "%s.getInitialState(): must return an object or null", Constructor.displayName || "ReactCompositeComponent");
                        this.state = initialState;
                    });
                    Constructor.prototype = new ReactClassComponent();
                    Constructor.prototype.constructor = Constructor;
                    Constructor.prototype.__reactAutoBindPairs = [];
                    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
                    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
                    mixSpecIntoComponent(Constructor, spec);
                    mixSpecIntoComponent(Constructor, IsMountedPostMixin);
                    if (Constructor.getDefaultProps) {
                        Constructor.defaultProps = Constructor.getDefaultProps();
                    }
                    if (process.env.NODE_ENV !== "production") {
                        if (Constructor.getDefaultProps) {
                            Constructor.getDefaultProps.isReactClassApproved = {};
                        }
                        if (Constructor.prototype.getInitialState) {
                            Constructor.prototype.getInitialState.isReactClassApproved = {};
                        }
                    }
                    _invariant(Constructor.prototype.render, "createClass(...): Class specification must implement a `render` method.");
                    if (process.env.NODE_ENV !== "production") {
                        warning(!Constructor.prototype.componentShouldUpdate, "%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", spec.displayName || "A component");
                        warning(!Constructor.prototype.componentWillRecieveProps, "%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", spec.displayName || "A component");
                        warning(!Constructor.prototype.UNSAFE_componentWillRecieveProps, "%s has a method called UNSAFE_componentWillRecieveProps(). " + "Did you mean UNSAFE_componentWillReceiveProps()?", spec.displayName || "A component");
                    }
                    for (var methodName in ReactClassInterface) {
                        if (!Constructor.prototype[methodName]) {
                            Constructor.prototype[methodName] = null;
                        }
                    }
                    return Constructor;
                }
                return createClass;
            }
            module.exports = factory;
        }).call(this, require("_process"));
    }, {
        _process: 26,
        "fbjs/lib/emptyObject": 21,
        "fbjs/lib/invariant": 22,
        "fbjs/lib/warning": 24,
        "object-assign": 25
    } ],
    18: [ function(require, module, exports) {
        "use strict";
        var React = require("react");
        var factory = require("./factory");
        if (typeof React === "undefined") {
            throw Error("create-react-class could not find the React object. If you are using script tags, " + "make sure that React is being loaded before create-react-class.");
        }
        var ReactNoopUpdateQueue = new React.Component().updater;
        module.exports = factory(React.Component, React.isValidElement, ReactNoopUpdateQueue);
    }, {
        "./factory": 17,
        react: "react"
    } ],
    19: [ function(require, module, exports) {
        var objectCreate = Object.create || objectCreatePolyfill;
        var objectKeys = Object.keys || objectKeysPolyfill;
        var bind = Function.prototype.bind || functionBindPolyfill;
        function EventEmitter() {
            if (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) {
                this._events = objectCreate(null);
                this._eventsCount = 0;
            }
            this._maxListeners = this._maxListeners || undefined;
        }
        module.exports = EventEmitter;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;
        var defaultMaxListeners = 10;
        var hasDefineProperty;
        try {
            var o = {};
            if (Object.defineProperty) Object.defineProperty(o, "x", {
                value: 0
            });
            hasDefineProperty = o.x === 0;
        } catch (err) {
            hasDefineProperty = false;
        }
        if (hasDefineProperty) {
            Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                enumerable: true,
                get: function() {
                    return defaultMaxListeners;
                },
                set: function(arg) {
                    if (typeof arg !== "number" || arg < 0 || arg !== arg) throw new TypeError('"defaultMaxListeners" must be a positive number');
                    defaultMaxListeners = arg;
                }
            });
        } else {
            EventEmitter.defaultMaxListeners = defaultMaxListeners;
        }
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== "number" || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
            this._maxListeners = n;
            return this;
        };
        function $getMaxListeners(that) {
            if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
            return that._maxListeners;
        }
        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return $getMaxListeners(this);
        };
        function emitNone(handler, isFn, self) {
            if (isFn) handler.call(self); else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i) listeners[i].call(self);
            }
        }
        function emitOne(handler, isFn, self, arg1) {
            if (isFn) handler.call(self, arg1); else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
            }
        }
        function emitTwo(handler, isFn, self, arg1, arg2) {
            if (isFn) handler.call(self, arg1, arg2); else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
            }
        }
        function emitThree(handler, isFn, self, arg1, arg2, arg3) {
            if (isFn) handler.call(self, arg1, arg2, arg3); else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
            }
        }
        function emitMany(handler, isFn, self, args) {
            if (isFn) handler.apply(self, args); else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
            }
        }
        EventEmitter.prototype.emit = function emit(type) {
            var er, handler, len, args, i, events;
            var doError = type === "error";
            events = this._events;
            if (events) doError = doError && events.error == null; else if (!doError) return false;
            if (doError) {
                if (arguments.length > 1) er = arguments[1];
                if (er instanceof Error) {
                    throw er;
                } else {
                    var err = new Error('Unhandled "error" event. (' + er + ")");
                    err.context = er;
                    throw err;
                }
                return false;
            }
            handler = events[type];
            if (!handler) return false;
            var isFn = typeof handler === "function";
            len = arguments.length;
            switch (len) {
              case 1:
                emitNone(handler, isFn, this);
                break;

              case 2:
                emitOne(handler, isFn, this, arguments[1]);
                break;

              case 3:
                emitTwo(handler, isFn, this, arguments[1], arguments[2]);
                break;

              case 4:
                emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
                break;

              default:
                args = new Array(len - 1);
                for (i = 1; i < len; i++) args[i - 1] = arguments[i];
                emitMany(handler, isFn, this, args);
            }
            return true;
        };
        function _addListener(target, type, listener, prepend) {
            var m;
            var events;
            var existing;
            if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
            events = target._events;
            if (!events) {
                events = target._events = objectCreate(null);
                target._eventsCount = 0;
            } else {
                if (events.newListener) {
                    target.emit("newListener", type, listener.listener ? listener.listener : listener);
                    events = target._events;
                }
                existing = events[type];
            }
            if (!existing) {
                existing = events[type] = listener;
                ++target._eventsCount;
            } else {
                if (typeof existing === "function") {
                    existing = events[type] = prepend ? [ listener, existing ] : [ existing, listener ];
                } else {
                    if (prepend) {
                        existing.unshift(listener);
                    } else {
                        existing.push(listener);
                    }
                }
                if (!existing.warned) {
                    m = $getMaxListeners(target);
                    if (m && m > 0 && existing.length > m) {
                        existing.warned = true;
                        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + ' "' + String(type) + '" listeners ' + "added. Use emitter.setMaxListeners() to " + "increase limit.");
                        w.name = "MaxListenersExceededWarning";
                        w.emitter = target;
                        w.type = type;
                        w.count = existing.length;
                        if (typeof console === "object" && console.warn) {
                            console.warn("%s: %s", w.name, w.message);
                        }
                    }
                }
            }
            return target;
        }
        EventEmitter.prototype.addListener = function addListener(type, listener) {
            return _addListener(this, type, listener, false);
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.prependListener = function prependListener(type, listener) {
            return _addListener(this, type, listener, true);
        };
        function onceWrapper() {
            if (!this.fired) {
                this.target.removeListener(this.type, this.wrapFn);
                this.fired = true;
                switch (arguments.length) {
                  case 0:
                    return this.listener.call(this.target);

                  case 1:
                    return this.listener.call(this.target, arguments[0]);

                  case 2:
                    return this.listener.call(this.target, arguments[0], arguments[1]);

                  case 3:
                    return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);

                  default:
                    var args = new Array(arguments.length);
                    for (var i = 0; i < args.length; ++i) args[i] = arguments[i];
                    this.listener.apply(this.target, args);
                }
            }
        }
        function _onceWrap(target, type, listener) {
            var state = {
                fired: false,
                wrapFn: undefined,
                target: target,
                type: type,
                listener: listener
            };
            var wrapped = bind.call(onceWrapper, state);
            wrapped.listener = listener;
            state.wrapFn = wrapped;
            return wrapped;
        }
        EventEmitter.prototype.once = function once(type, listener) {
            if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
            this.on(type, _onceWrap(this, type, listener));
            return this;
        };
        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
            if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
            this.prependListener(type, _onceWrap(this, type, listener));
            return this;
        };
        EventEmitter.prototype.removeListener = function removeListener(type, listener) {
            var list, events, position, i, originalListener;
            if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
            events = this._events;
            if (!events) return this;
            list = events[type];
            if (!list) return this;
            if (list === listener || list.listener === listener) {
                if (--this._eventsCount === 0) this._events = objectCreate(null); else {
                    delete events[type];
                    if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
                }
            } else if (typeof list !== "function") {
                position = -1;
                for (i = list.length - 1; i >= 0; i--) {
                    if (list[i] === listener || list[i].listener === listener) {
                        originalListener = list[i].listener;
                        position = i;
                        break;
                    }
                }
                if (position < 0) return this;
                if (position === 0) list.shift(); else spliceOne(list, position);
                if (list.length === 1) events[type] = list[0];
                if (events.removeListener) this.emit("removeListener", type, originalListener || listener);
            }
            return this;
        };
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
            var listeners, events, i;
            events = this._events;
            if (!events) return this;
            if (!events.removeListener) {
                if (arguments.length === 0) {
                    this._events = objectCreate(null);
                    this._eventsCount = 0;
                } else if (events[type]) {
                    if (--this._eventsCount === 0) this._events = objectCreate(null); else delete events[type];
                }
                return this;
            }
            if (arguments.length === 0) {
                var keys = objectKeys(events);
                var key;
                for (i = 0; i < keys.length; ++i) {
                    key = keys[i];
                    if (key === "removeListener") continue;
                    this.removeAllListeners(key);
                }
                this.removeAllListeners("removeListener");
                this._events = objectCreate(null);
                this._eventsCount = 0;
                return this;
            }
            listeners = events[type];
            if (typeof listeners === "function") {
                this.removeListener(type, listeners);
            } else if (listeners) {
                for (i = listeners.length - 1; i >= 0; i--) {
                    this.removeListener(type, listeners[i]);
                }
            }
            return this;
        };
        function _listeners(target, type, unwrap) {
            var events = target._events;
            if (!events) return [];
            var evlistener = events[type];
            if (!evlistener) return [];
            if (typeof evlistener === "function") return unwrap ? [ evlistener.listener || evlistener ] : [ evlistener ];
            return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }
        EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true);
        };
        EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false);
        };
        EventEmitter.listenerCount = function(emitter, type) {
            if (typeof emitter.listenerCount === "function") {
                return emitter.listenerCount(type);
            } else {
                return listenerCount.call(emitter, type);
            }
        };
        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
            var events = this._events;
            if (events) {
                var evlistener = events[type];
                if (typeof evlistener === "function") {
                    return 1;
                } else if (evlistener) {
                    return evlistener.length;
                }
            }
            return 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };
        function spliceOne(list, index) {
            for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
            list.pop();
        }
        function arrayClone(arr, n) {
            var copy = new Array(n);
            for (var i = 0; i < n; ++i) copy[i] = arr[i];
            return copy;
        }
        function unwrapListeners(arr) {
            var ret = new Array(arr.length);
            for (var i = 0; i < ret.length; ++i) {
                ret[i] = arr[i].listener || arr[i];
            }
            return ret;
        }
        function objectCreatePolyfill(proto) {
            var F = function() {};
            F.prototype = proto;
            return new F();
        }
        function objectKeysPolyfill(obj) {
            var keys = [];
            for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
                keys.push(k);
            }
            return k;
        }
        function functionBindPolyfill(context) {
            var fn = this;
            return function() {
                return fn.apply(context, arguments);
            };
        }
    }, {} ],
    20: [ function(require, module, exports) {
        "use strict";
        function makeEmptyFunction(arg) {
            return function() {
                return arg;
            };
        }
        var emptyFunction = function emptyFunction() {};
        emptyFunction.thatReturns = makeEmptyFunction;
        emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
        emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
        emptyFunction.thatReturnsNull = makeEmptyFunction(null);
        emptyFunction.thatReturnsThis = function() {
            return this;
        };
        emptyFunction.thatReturnsArgument = function(arg) {
            return arg;
        };
        module.exports = emptyFunction;
    }, {} ],
    21: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var emptyObject = {};
            if (process.env.NODE_ENV !== "production") {
                Object.freeze(emptyObject);
            }
            module.exports = emptyObject;
        }).call(this, require("_process"));
    }, {
        _process: 26
    } ],
    22: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var validateFormat = function validateFormat(format) {};
            if (process.env.NODE_ENV !== "production") {
                validateFormat = function validateFormat(format) {
                    if (format === undefined) {
                        throw new Error("invariant requires an error message argument");
                    }
                };
            }
            function invariant(condition, format, a, b, c, d, e, f) {
                validateFormat(format);
                if (!condition) {
                    var error;
                    if (format === undefined) {
                        error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
                    } else {
                        var args = [ a, b, c, d, e, f ];
                        var argIndex = 0;
                        error = new Error(format.replace(/%s/g, function() {
                            return args[argIndex++];
                        }));
                        error.name = "Invariant Violation";
                    }
                    error.framesToPop = 1;
                    throw error;
                }
            }
            module.exports = invariant;
        }).call(this, require("_process"));
    }, {
        _process: 26
    } ],
    23: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var invariant = require("./invariant");
            var keyMirror = function keyMirror(obj) {
                var ret = {};
                var key;
                !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== "production" ? invariant(false, "keyMirror(...): Argument must be an object.") : invariant(false) : void 0;
                for (key in obj) {
                    if (!obj.hasOwnProperty(key)) {
                        continue;
                    }
                    ret[key] = key;
                }
                return ret;
            };
            module.exports = keyMirror;
        }).call(this, require("_process"));
    }, {
        "./invariant": 22,
        _process: 26
    } ],
    24: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var emptyFunction = require("./emptyFunction");
            var warning = emptyFunction;
            if (process.env.NODE_ENV !== "production") {
                var printWarning = function printWarning(format) {
                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }
                    var argIndex = 0;
                    var message = "Warning: " + format.replace(/%s/g, function() {
                        return args[argIndex++];
                    });
                    if (typeof console !== "undefined") {
                        console.error(message);
                    }
                    try {
                        throw new Error(message);
                    } catch (x) {}
                };
                warning = function warning(condition, format) {
                    if (format === undefined) {
                        throw new Error("`warning(condition, format, ...args)` requires a warning " + "message argument");
                    }
                    if (format.indexOf("Failed Composite propType: ") === 0) {
                        return;
                    }
                    if (!condition) {
                        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                            args[_key2 - 2] = arguments[_key2];
                        }
                        printWarning.apply(undefined, [ format ].concat(args));
                    }
                };
            }
            module.exports = warning;
        }).call(this, require("_process"));
    }, {
        "./emptyFunction": 20,
        _process: 26
    } ],
    25: [ function(require, module, exports) {
        "use strict";
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
            if (val === null || val === undefined) {
                throw new TypeError("Object.assign cannot be called with null or undefined");
            }
            return Object(val);
        }
        function shouldUseNative() {
            try {
                if (!Object.assign) {
                    return false;
                }
                var test1 = new String("abc");
                test1[5] = "de";
                if (Object.getOwnPropertyNames(test1)[0] === "5") {
                    return false;
                }
                var test2 = {};
                for (var i = 0; i < 10; i++) {
                    test2["_" + String.fromCharCode(i)] = i;
                }
                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                });
                if (order2.join("") !== "0123456789") {
                    return false;
                }
                var test3 = {};
                "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                    test3[letter] = letter;
                });
                if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                    return false;
                }
                return true;
            } catch (err) {
                return false;
            }
        }
        module.exports = shouldUseNative() ? Object.assign : function(target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for (var s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);
                for (var key in from) {
                    if (hasOwnProperty.call(from, key)) {
                        to[key] = from[key];
                    }
                }
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) {
                        if (propIsEnumerable.call(from, symbols[i])) {
                            to[symbols[i]] = from[symbols[i]];
                        }
                    }
                }
            }
            return to;
        };
    }, {} ],
    26: [ function(require, module, exports) {
        var process = module.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        (function() {
            try {
                if (typeof setTimeout === "function") {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                if (typeof clearTimeout === "function") {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        })();
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }
            try {
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }
            try {
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }
        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        };
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {}
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name) {
            return [];
        };
        process.binding = function(name) {
            throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
            return "/";
        };
        process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
            return 0;
        };
    }, {} ],
    27: [ function(require, module, exports) {
        (function(global) {
            (function(global, factory) {
                typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require("react"), require("react-dom")) : typeof define === "function" && define.amd ? define([ "react", "react-dom" ], factory) : global.ReactAwesomePopover = factory(global.React, global.ReactDOM);
            })(this, function(React, ReactDOM) {
                "use strict";
                React = React && React.hasOwnProperty("default") ? React["default"] : React;
                ReactDOM = ReactDOM && ReactDOM.hasOwnProperty("default") ? ReactDOM["default"] : ReactDOM;
                function commonjsRequire() {
                    throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
                }
                function unwrapExports(x) {
                    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
                }
                function createCommonjsModule(fn, module) {
                    return module = {
                        exports: {}
                    }, fn(module, module.exports), module.exports;
                }
                "use strict";
                function makeEmptyFunction(arg) {
                    return function() {
                        return arg;
                    };
                }
                var emptyFunction = function emptyFunction() {};
                emptyFunction.thatReturns = makeEmptyFunction;
                emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
                emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
                emptyFunction.thatReturnsNull = makeEmptyFunction(null);
                emptyFunction.thatReturnsThis = function() {
                    return this;
                };
                emptyFunction.thatReturnsArgument = function(arg) {
                    return arg;
                };
                var emptyFunction_1 = emptyFunction;
                "use strict";
                function invariant(condition, format, a, b, c, d, e, f) {
                    if (!condition) {
                        var error;
                        if (format === undefined) {
                            error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
                        } else {
                            var args = [ a, b, c, d, e, f ];
                            var argIndex = 0;
                            error = new Error(format.replace(/%s/g, function() {
                                return args[argIndex++];
                            }));
                            error.name = "Invariant Violation";
                        }
                        error.framesToPop = 1;
                        throw error;
                    }
                }
                var invariant_1 = invariant;
                "use strict";
                var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
                var ReactPropTypesSecret_1 = ReactPropTypesSecret;
                "use strict";
                var factoryWithThrowingShims = function() {
                    function shim(props, propName, componentName, location, propFullName, secret) {
                        if (secret === ReactPropTypesSecret_1) {
                            return;
                        }
                        invariant_1(false, "Calling PropTypes validators directly is not supported by the `prop-types` package. " + "Use PropTypes.checkPropTypes() to call them. " + "Read more at http://fb.me/use-check-prop-types");
                    }
                    shim.isRequired = shim;
                    function getShim() {
                        return shim;
                    }
                    var ReactPropTypes = {
                        array: shim,
                        bool: shim,
                        func: shim,
                        number: shim,
                        object: shim,
                        string: shim,
                        symbol: shim,
                        any: shim,
                        arrayOf: getShim,
                        element: shim,
                        instanceOf: getShim,
                        node: shim,
                        objectOf: getShim,
                        oneOf: getShim,
                        oneOfType: getShim,
                        shape: getShim,
                        exact: getShim
                    };
                    ReactPropTypes.checkPropTypes = emptyFunction_1;
                    ReactPropTypes.PropTypes = ReactPropTypes;
                    return ReactPropTypes;
                };
                var propTypes = createCommonjsModule(function(module) {
                    {
                        module.exports = factoryWithThrowingShims();
                    }
                });
                var Manager_1 = createCommonjsModule(function(module, exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    var _createClass = function() {
                        function defineProperties(target, props) {
                            for (var i = 0; i < props.length; i++) {
                                var descriptor = props[i];
                                descriptor.enumerable = descriptor.enumerable || false;
                                descriptor.configurable = true;
                                if ("value" in descriptor) descriptor.writable = true;
                                Object.defineProperty(target, descriptor.key, descriptor);
                            }
                        }
                        return function(Constructor, protoProps, staticProps) {
                            if (protoProps) defineProperties(Constructor.prototype, protoProps);
                            if (staticProps) defineProperties(Constructor, staticProps);
                            return Constructor;
                        };
                    }();
                    var _react2 = _interopRequireDefault(React);
                    var _propTypes2 = _interopRequireDefault(propTypes);
                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        };
                    }
                    function _objectWithoutProperties(obj, keys) {
                        var target = {};
                        for (var i in obj) {
                            if (keys.indexOf(i) >= 0) continue;
                            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
                            target[i] = obj[i];
                        }
                        return target;
                    }
                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError("Cannot call a class as a function");
                        }
                    }
                    function _possibleConstructorReturn(self, call) {
                        if (!self) {
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        }
                        return call && (typeof call === "object" || typeof call === "function") ? call : self;
                    }
                    function _inherits(subClass, superClass) {
                        if (typeof superClass !== "function" && superClass !== null) {
                            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                        }
                        subClass.prototype = Object.create(superClass && superClass.prototype, {
                            constructor: {
                                value: subClass,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                    }
                    var Manager = function(_Component) {
                        _inherits(Manager, _Component);
                        function Manager() {
                            var _ref;
                            var _temp, _this, _ret;
                            _classCallCheck(this, Manager);
                            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }
                            return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Manager.__proto__ || Object.getPrototypeOf(Manager)).call.apply(_ref, [ this ].concat(args))), 
                            _this), _this._setTargetNode = function(node) {
                                _this._targetNode = node;
                            }, _this._getTargetNode = function() {
                                return _this._targetNode;
                            }, _temp), _possibleConstructorReturn(_this, _ret);
                        }
                        _createClass(Manager, [ {
                            key: "getChildContext",
                            value: function getChildContext() {
                                return {
                                    popperManager: {
                                        setTargetNode: this._setTargetNode,
                                        getTargetNode: this._getTargetNode
                                    }
                                };
                            }
                        }, {
                            key: "render",
                            value: function render() {
                                var _props = this.props, tag = _props.tag, children = _props.children, restProps = _objectWithoutProperties(_props, [ "tag", "children" ]);
                                if (tag !== false) {
                                    return (0, React.createElement)(tag, restProps, children);
                                } else {
                                    return children;
                                }
                            }
                        } ]);
                        return Manager;
                    }(React.Component);
                    Manager.childContextTypes = {
                        popperManager: _propTypes2.default.object.isRequired
                    };
                    Manager.propTypes = {
                        tag: _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.bool ])
                    };
                    Manager.defaultProps = {
                        tag: "div"
                    };
                    exports.default = Manager;
                });
                unwrapExports(Manager_1);
                var Target_1 = createCommonjsModule(function(module, exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    var _extends = Object.assign || function(target) {
                        for (var i = 1; i < arguments.length; i++) {
                            var source = arguments[i];
                            for (var key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    target[key] = source[key];
                                }
                            }
                        }
                        return target;
                    };
                    var _react2 = _interopRequireDefault(React);
                    var _propTypes2 = _interopRequireDefault(propTypes);
                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        };
                    }
                    function _objectWithoutProperties(obj, keys) {
                        var target = {};
                        for (var i in obj) {
                            if (keys.indexOf(i) >= 0) continue;
                            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
                            target[i] = obj[i];
                        }
                        return target;
                    }
                    var Target = function Target(props, context) {
                        var _props$component = props.component, component = _props$component === undefined ? "div" : _props$component, innerRef = props.innerRef, children = props.children, restProps = _objectWithoutProperties(props, [ "component", "innerRef", "children" ]);
                        var popperManager = context.popperManager;
                        var targetRef = function targetRef(node) {
                            popperManager.setTargetNode(node);
                            if (typeof innerRef === "function") {
                                innerRef(node);
                            }
                        };
                        if (typeof children === "function") {
                            var targetProps = {
                                ref: targetRef
                            };
                            return children({
                                targetProps: targetProps,
                                restProps: restProps
                            });
                        }
                        var componentProps = _extends({}, restProps);
                        if (typeof component === "string") {
                            componentProps.ref = targetRef;
                        } else {
                            componentProps.innerRef = targetRef;
                        }
                        return (0, React.createElement)(component, componentProps, children);
                    };
                    Target.contextTypes = {
                        popperManager: _propTypes2.default.object.isRequired
                    };
                    Target.propTypes = {
                        component: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ]),
                        innerRef: _propTypes2.default.func,
                        children: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ])
                    };
                    exports.default = Target;
                });
                unwrapExports(Target_1);
                var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
                var longerTimeoutBrowsers = [ "Edge", "Trident", "Firefox" ];
                var timeoutDuration = 0;
                for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
                    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
                        timeoutDuration = 1;
                        break;
                    }
                }
                function microtaskDebounce(fn) {
                    var called = false;
                    return function() {
                        if (called) {
                            return;
                        }
                        called = true;
                        Promise.resolve().then(function() {
                            called = false;
                            fn();
                        });
                    };
                }
                function taskDebounce(fn) {
                    var scheduled = false;
                    return function() {
                        if (!scheduled) {
                            scheduled = true;
                            setTimeout(function() {
                                scheduled = false;
                                fn();
                            }, timeoutDuration);
                        }
                    };
                }
                var supportsMicroTasks = isBrowser && window.Promise;
                var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
                function isFunction(functionToCheck) {
                    var getType = {};
                    return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
                }
                function getStyleComputedProperty(element, property) {
                    if (element.nodeType !== 1) {
                        return [];
                    }
                    var css = window.getComputedStyle(element, null);
                    return property ? css[property] : css;
                }
                function getParentNode(element) {
                    if (element.nodeName === "HTML") {
                        return element;
                    }
                    return element.parentNode || element.host;
                }
                function getScrollParent(element) {
                    if (!element) {
                        return window.document.body;
                    }
                    switch (element.nodeName) {
                      case "HTML":
                      case "BODY":
                        return element.ownerDocument.body;

                      case "#document":
                        return element.body;
                    }
                    var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
                    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
                        return element;
                    }
                    return getScrollParent(getParentNode(element));
                }
                function getOffsetParent(element) {
                    var offsetParent = element && element.offsetParent;
                    var nodeName = offsetParent && offsetParent.nodeName;
                    if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
                        if (element) {
                            return element.ownerDocument.documentElement;
                        }
                        return window.document.documentElement;
                    }
                    if ([ "TD", "TABLE" ].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
                        return getOffsetParent(offsetParent);
                    }
                    return offsetParent;
                }
                function isOffsetContainer(element) {
                    var nodeName = element.nodeName;
                    if (nodeName === "BODY") {
                        return false;
                    }
                    return nodeName === "HTML" || getOffsetParent(element.firstElementChild) === element;
                }
                function getRoot(node) {
                    if (node.parentNode !== null) {
                        return getRoot(node.parentNode);
                    }
                    return node;
                }
                function findCommonOffsetParent(element1, element2) {
                    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
                        return window.document.documentElement;
                    }
                    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
                    var start = order ? element1 : element2;
                    var end = order ? element2 : element1;
                    var range = document.createRange();
                    range.setStart(start, 0);
                    range.setEnd(end, 0);
                    var commonAncestorContainer = range.commonAncestorContainer;
                    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
                        if (isOffsetContainer(commonAncestorContainer)) {
                            return commonAncestorContainer;
                        }
                        return getOffsetParent(commonAncestorContainer);
                    }
                    var element1root = getRoot(element1);
                    if (element1root.host) {
                        return findCommonOffsetParent(element1root.host, element2);
                    } else {
                        return findCommonOffsetParent(element1, getRoot(element2).host);
                    }
                }
                function getScroll(element) {
                    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "top";
                    var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
                    var nodeName = element.nodeName;
                    if (nodeName === "BODY" || nodeName === "HTML") {
                        var html = element.ownerDocument.documentElement;
                        var scrollingElement = element.ownerDocument.scrollingElement || html;
                        return scrollingElement[upperSide];
                    }
                    return element[upperSide];
                }
                function includeScroll(rect, element) {
                    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                    var scrollTop = getScroll(element, "top");
                    var scrollLeft = getScroll(element, "left");
                    var modifier = subtract ? -1 : 1;
                    rect.top += scrollTop * modifier;
                    rect.bottom += scrollTop * modifier;
                    rect.left += scrollLeft * modifier;
                    rect.right += scrollLeft * modifier;
                    return rect;
                }
                function getBordersSize(styles, axis) {
                    var sideA = axis === "x" ? "Left" : "Top";
                    var sideB = sideA === "Left" ? "Right" : "Bottom";
                    return +styles["border" + sideA + "Width"].split("px")[0] + +styles["border" + sideB + "Width"].split("px")[0];
                }
                var isIE10 = undefined;
                var isIE10$1 = function() {
                    if (isIE10 === undefined) {
                        isIE10 = navigator.appVersion.indexOf("MSIE 10") !== -1;
                    }
                    return isIE10;
                };
                function getSize(axis, body, html, computedStyle) {
                    return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE10$1() ? html["offset" + axis] + computedStyle["margin" + (axis === "Height" ? "Top" : "Left")] + computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")] : 0);
                }
                function getWindowSizes() {
                    var body = window.document.body;
                    var html = window.document.documentElement;
                    var computedStyle = isIE10$1() && window.getComputedStyle(html);
                    return {
                        height: getSize("Height", body, html, computedStyle),
                        width: getSize("Width", body, html, computedStyle)
                    };
                }
                var classCallCheck = function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                };
                var createClass = function() {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();
                var defineProperty = function(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                };
                var _extends = Object.assign || function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) {
                            if (Object.prototype.hasOwnProperty.call(source, key)) {
                                target[key] = source[key];
                            }
                        }
                    }
                    return target;
                };
                function getClientRect(offsets) {
                    return _extends({}, offsets, {
                        right: offsets.left + offsets.width,
                        bottom: offsets.top + offsets.height
                    });
                }
                function getBoundingClientRect(element) {
                    var rect = {};
                    if (isIE10$1()) {
                        try {
                            rect = element.getBoundingClientRect();
                            var scrollTop = getScroll(element, "top");
                            var scrollLeft = getScroll(element, "left");
                            rect.top += scrollTop;
                            rect.left += scrollLeft;
                            rect.bottom += scrollTop;
                            rect.right += scrollLeft;
                        } catch (err) {}
                    } else {
                        rect = element.getBoundingClientRect();
                    }
                    var result = {
                        left: rect.left,
                        top: rect.top,
                        width: rect.right - rect.left,
                        height: rect.bottom - rect.top
                    };
                    var sizes = element.nodeName === "HTML" ? getWindowSizes() : {};
                    var width = sizes.width || element.clientWidth || result.right - result.left;
                    var height = sizes.height || element.clientHeight || result.bottom - result.top;
                    var horizScrollbar = element.offsetWidth - width;
                    var vertScrollbar = element.offsetHeight - height;
                    if (horizScrollbar || vertScrollbar) {
                        var styles = getStyleComputedProperty(element);
                        horizScrollbar -= getBordersSize(styles, "x");
                        vertScrollbar -= getBordersSize(styles, "y");
                        result.width -= horizScrollbar;
                        result.height -= vertScrollbar;
                    }
                    return getClientRect(result);
                }
                function getOffsetRectRelativeToArbitraryNode(children, parent) {
                    var isIE10 = isIE10$1();
                    var isHTML = parent.nodeName === "HTML";
                    var childrenRect = getBoundingClientRect(children);
                    var parentRect = getBoundingClientRect(parent);
                    var scrollParent = getScrollParent(children);
                    var styles = getStyleComputedProperty(parent);
                    var borderTopWidth = +styles.borderTopWidth.split("px")[0];
                    var borderLeftWidth = +styles.borderLeftWidth.split("px")[0];
                    var offsets = getClientRect({
                        top: childrenRect.top - parentRect.top - borderTopWidth,
                        left: childrenRect.left - parentRect.left - borderLeftWidth,
                        width: childrenRect.width,
                        height: childrenRect.height
                    });
                    offsets.marginTop = 0;
                    offsets.marginLeft = 0;
                    if (!isIE10 && isHTML) {
                        var marginTop = +styles.marginTop.split("px")[0];
                        var marginLeft = +styles.marginLeft.split("px")[0];
                        offsets.top -= borderTopWidth - marginTop;
                        offsets.bottom -= borderTopWidth - marginTop;
                        offsets.left -= borderLeftWidth - marginLeft;
                        offsets.right -= borderLeftWidth - marginLeft;
                        offsets.marginTop = marginTop;
                        offsets.marginLeft = marginLeft;
                    }
                    if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== "BODY") {
                        offsets = includeScroll(offsets, parent);
                    }
                    return offsets;
                }
                function getViewportOffsetRectRelativeToArtbitraryNode(element) {
                    var html = element.ownerDocument.documentElement;
                    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
                    var width = Math.max(html.clientWidth, window.innerWidth || 0);
                    var height = Math.max(html.clientHeight, window.innerHeight || 0);
                    var scrollTop = getScroll(html);
                    var scrollLeft = getScroll(html, "left");
                    var offset = {
                        top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
                        left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
                        width: width,
                        height: height
                    };
                    return getClientRect(offset);
                }
                function isFixed(element) {
                    var nodeName = element.nodeName;
                    if (nodeName === "BODY" || nodeName === "HTML") {
                        return false;
                    }
                    if (getStyleComputedProperty(element, "position") === "fixed") {
                        return true;
                    }
                    return isFixed(getParentNode(element));
                }
                function getBoundaries(popper, reference, padding, boundariesElement) {
                    var boundaries = {
                        top: 0,
                        left: 0
                    };
                    var offsetParent = findCommonOffsetParent(popper, reference);
                    if (boundariesElement === "viewport") {
                        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
                    } else {
                        var boundariesNode = void 0;
                        if (boundariesElement === "scrollParent") {
                            boundariesNode = getScrollParent(getParentNode(reference));
                            if (boundariesNode.nodeName === "BODY") {
                                boundariesNode = popper.ownerDocument.documentElement;
                            }
                        } else if (boundariesElement === "window") {
                            boundariesNode = popper.ownerDocument.documentElement;
                        } else {
                            boundariesNode = boundariesElement;
                        }
                        var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);
                        if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
                            var _getWindowSizes = getWindowSizes(), height = _getWindowSizes.height, width = _getWindowSizes.width;
                            boundaries.top += offsets.top - offsets.marginTop;
                            boundaries.bottom = height + offsets.top;
                            boundaries.left += offsets.left - offsets.marginLeft;
                            boundaries.right = width + offsets.left;
                        } else {
                            boundaries = offsets;
                        }
                    }
                    boundaries.left += padding;
                    boundaries.top += padding;
                    boundaries.right -= padding;
                    boundaries.bottom -= padding;
                    return boundaries;
                }
                function getArea(_ref) {
                    var width = _ref.width, height = _ref.height;
                    return width * height;
                }
                function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
                    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
                    if (placement.indexOf("auto") === -1) {
                        return placement;
                    }
                    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
                    var rects = {
                        top: {
                            width: boundaries.width,
                            height: refRect.top - boundaries.top
                        },
                        right: {
                            width: boundaries.right - refRect.right,
                            height: boundaries.height
                        },
                        bottom: {
                            width: boundaries.width,
                            height: boundaries.bottom - refRect.bottom
                        },
                        left: {
                            width: refRect.left - boundaries.left,
                            height: boundaries.height
                        }
                    };
                    var sortedAreas = Object.keys(rects).map(function(key) {
                        return _extends({
                            key: key
                        }, rects[key], {
                            area: getArea(rects[key])
                        });
                    }).sort(function(a, b) {
                        return b.area - a.area;
                    });
                    var filteredAreas = sortedAreas.filter(function(_ref2) {
                        var width = _ref2.width, height = _ref2.height;
                        return width >= popper.clientWidth && height >= popper.clientHeight;
                    });
                    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
                    var variation = placement.split("-")[1];
                    return computedPlacement + (variation ? "-" + variation : "");
                }
                function getReferenceOffsets(state, popper, reference) {
                    var commonOffsetParent = findCommonOffsetParent(popper, reference);
                    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
                }
                function getOuterSizes(element) {
                    var styles = window.getComputedStyle(element);
                    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
                    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
                    var result = {
                        width: element.offsetWidth + y,
                        height: element.offsetHeight + x
                    };
                    return result;
                }
                function getOppositePlacement(placement) {
                    var hash = {
                        left: "right",
                        right: "left",
                        bottom: "top",
                        top: "bottom"
                    };
                    return placement.replace(/left|right|bottom|top/g, function(matched) {
                        return hash[matched];
                    });
                }
                function getPopperOffsets(popper, referenceOffsets, placement) {
                    placement = placement.split("-")[0];
                    var popperRect = getOuterSizes(popper);
                    var popperOffsets = {
                        width: popperRect.width,
                        height: popperRect.height
                    };
                    var isHoriz = [ "right", "left" ].indexOf(placement) !== -1;
                    var mainSide = isHoriz ? "top" : "left";
                    var secondarySide = isHoriz ? "left" : "top";
                    var measurement = isHoriz ? "height" : "width";
                    var secondaryMeasurement = !isHoriz ? "height" : "width";
                    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
                    if (placement === secondarySide) {
                        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
                    } else {
                        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
                    }
                    return popperOffsets;
                }
                function find(arr, check) {
                    if (Array.prototype.find) {
                        return arr.find(check);
                    }
                    return arr.filter(check)[0];
                }
                function findIndex(arr, prop, value) {
                    if (Array.prototype.findIndex) {
                        return arr.findIndex(function(cur) {
                            return cur[prop] === value;
                        });
                    }
                    var match = find(arr, function(obj) {
                        return obj[prop] === value;
                    });
                    return arr.indexOf(match);
                }
                function runModifiers(modifiers, data, ends) {
                    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, "name", ends));
                    modifiersToRun.forEach(function(modifier) {
                        if (modifier["function"]) {
                            console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
                        }
                        var fn = modifier["function"] || modifier.fn;
                        if (modifier.enabled && isFunction(fn)) {
                            data.offsets.popper = getClientRect(data.offsets.popper);
                            data.offsets.reference = getClientRect(data.offsets.reference);
                            data = fn(data, modifier);
                        }
                    });
                    return data;
                }
                function update() {
                    if (this.state.isDestroyed) {
                        return;
                    }
                    var data = {
                        instance: this,
                        styles: {},
                        arrowStyles: {},
                        attributes: {},
                        flipped: false,
                        offsets: {}
                    };
                    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);
                    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
                    data.originalPlacement = data.placement;
                    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
                    data.offsets.popper.position = "absolute";
                    data = runModifiers(this.modifiers, data);
                    if (!this.state.isCreated) {
                        this.state.isCreated = true;
                        this.options.onCreate(data);
                    } else {
                        this.options.onUpdate(data);
                    }
                }
                function isModifierEnabled(modifiers, modifierName) {
                    return modifiers.some(function(_ref) {
                        var name = _ref.name, enabled = _ref.enabled;
                        return enabled && name === modifierName;
                    });
                }
                function getSupportedPropertyName(property) {
                    var prefixes = [ false, "ms", "Webkit", "Moz", "O" ];
                    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
                    for (var i = 0; i < prefixes.length - 1; i++) {
                        var prefix = prefixes[i];
                        var toCheck = prefix ? "" + prefix + upperProp : property;
                        if (typeof window.document.body.style[toCheck] !== "undefined") {
                            return toCheck;
                        }
                    }
                    return null;
                }
                function destroy() {
                    this.state.isDestroyed = true;
                    if (isModifierEnabled(this.modifiers, "applyStyle")) {
                        this.popper.removeAttribute("x-placement");
                        this.popper.style.left = "";
                        this.popper.style.position = "";
                        this.popper.style.top = "";
                        this.popper.style[getSupportedPropertyName("transform")] = "";
                    }
                    this.disableEventListeners();
                    if (this.options.removeOnDestroy) {
                        this.popper.parentNode.removeChild(this.popper);
                    }
                    return this;
                }
                function getWindow(element) {
                    var ownerDocument = element.ownerDocument;
                    return ownerDocument ? ownerDocument.defaultView : window;
                }
                function attachToScrollParents(scrollParent, event, callback, scrollParents) {
                    var isBody = scrollParent.nodeName === "BODY";
                    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
                    target.addEventListener(event, callback, {
                        passive: true
                    });
                    if (!isBody) {
                        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
                    }
                    scrollParents.push(target);
                }
                function setupEventListeners(reference, options, state, updateBound) {
                    state.updateBound = updateBound;
                    getWindow(reference).addEventListener("resize", state.updateBound, {
                        passive: true
                    });
                    var scrollElement = getScrollParent(reference);
                    attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
                    state.scrollElement = scrollElement;
                    state.eventsEnabled = true;
                    return state;
                }
                function enableEventListeners() {
                    if (!this.state.eventsEnabled) {
                        this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
                    }
                }
                function removeEventListeners(reference, state) {
                    getWindow(reference).removeEventListener("resize", state.updateBound);
                    state.scrollParents.forEach(function(target) {
                        target.removeEventListener("scroll", state.updateBound);
                    });
                    state.updateBound = null;
                    state.scrollParents = [];
                    state.scrollElement = null;
                    state.eventsEnabled = false;
                    return state;
                }
                function disableEventListeners() {
                    if (this.state.eventsEnabled) {
                        window.cancelAnimationFrame(this.scheduleUpdate);
                        this.state = removeEventListeners(this.reference, this.state);
                    }
                }
                function isNumeric(n) {
                    return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
                }
                function setStyles(element, styles) {
                    Object.keys(styles).forEach(function(prop) {
                        var unit = "";
                        if ([ "width", "height", "top", "right", "bottom", "left" ].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
                            unit = "px";
                        }
                        element.style[prop] = styles[prop] + unit;
                    });
                }
                function setAttributes(element, attributes) {
                    Object.keys(attributes).forEach(function(prop) {
                        var value = attributes[prop];
                        if (value !== false) {
                            element.setAttribute(prop, attributes[prop]);
                        } else {
                            element.removeAttribute(prop);
                        }
                    });
                }
                function applyStyle(data) {
                    setStyles(data.instance.popper, data.styles);
                    setAttributes(data.instance.popper, data.attributes);
                    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
                        setStyles(data.arrowElement, data.arrowStyles);
                    }
                    return data;
                }
                function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
                    var referenceOffsets = getReferenceOffsets(state, popper, reference);
                    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
                    popper.setAttribute("x-placement", placement);
                    setStyles(popper, {
                        position: "absolute"
                    });
                    return options;
                }
                function computeStyle(data, options) {
                    var x = options.x, y = options.y;
                    var popper = data.offsets.popper;
                    var legacyGpuAccelerationOption = find(data.instance.modifiers, function(modifier) {
                        return modifier.name === "applyStyle";
                    }).gpuAcceleration;
                    if (legacyGpuAccelerationOption !== undefined) {
                        console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
                    }
                    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
                    var offsetParent = getOffsetParent(data.instance.popper);
                    var offsetParentRect = getBoundingClientRect(offsetParent);
                    var styles = {
                        position: popper.position
                    };
                    var offsets = {
                        left: Math.floor(popper.left),
                        top: Math.floor(popper.top),
                        bottom: Math.floor(popper.bottom),
                        right: Math.floor(popper.right)
                    };
                    var sideA = x === "bottom" ? "top" : "bottom";
                    var sideB = y === "right" ? "left" : "right";
                    var prefixedProperty = getSupportedPropertyName("transform");
                    var left = void 0, top = void 0;
                    if (sideA === "bottom") {
                        top = -offsetParentRect.height + offsets.bottom;
                    } else {
                        top = offsets.top;
                    }
                    if (sideB === "right") {
                        left = -offsetParentRect.width + offsets.right;
                    } else {
                        left = offsets.left;
                    }
                    if (gpuAcceleration && prefixedProperty) {
                        styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
                        styles[sideA] = 0;
                        styles[sideB] = 0;
                        styles.willChange = "transform";
                    } else {
                        var invertTop = sideA === "bottom" ? -1 : 1;
                        var invertLeft = sideB === "right" ? -1 : 1;
                        styles[sideA] = top * invertTop;
                        styles[sideB] = left * invertLeft;
                        styles.willChange = sideA + ", " + sideB;
                    }
                    var attributes = {
                        "x-placement": data.placement
                    };
                    data.attributes = _extends({}, attributes, data.attributes);
                    data.styles = _extends({}, styles, data.styles);
                    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
                    return data;
                }
                function isModifierRequired(modifiers, requestingName, requestedName) {
                    var requesting = find(modifiers, function(_ref) {
                        var name = _ref.name;
                        return name === requestingName;
                    });
                    var isRequired = !!requesting && modifiers.some(function(modifier) {
                        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
                    });
                    if (!isRequired) {
                        var _requesting = "`" + requestingName + "`";
                        var requested = "`" + requestedName + "`";
                        console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
                    }
                    return isRequired;
                }
                function arrow(data, options) {
                    if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
                        return data;
                    }
                    var arrowElement = options.element;
                    if (typeof arrowElement === "string") {
                        arrowElement = data.instance.popper.querySelector(arrowElement);
                        if (!arrowElement) {
                            return data;
                        }
                    } else {
                        if (!data.instance.popper.contains(arrowElement)) {
                            console.warn("WARNING: `arrow.element` must be child of its popper element!");
                            return data;
                        }
                    }
                    var placement = data.placement.split("-")[0];
                    var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                    var isVertical = [ "left", "right" ].indexOf(placement) !== -1;
                    var len = isVertical ? "height" : "width";
                    var sideCapitalized = isVertical ? "Top" : "Left";
                    var side = sideCapitalized.toLowerCase();
                    var altSide = isVertical ? "left" : "top";
                    var opSide = isVertical ? "bottom" : "right";
                    var arrowElementSize = getOuterSizes(arrowElement)[len];
                    if (reference[opSide] - arrowElementSize < popper[side]) {
                        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
                    }
                    if (reference[side] + arrowElementSize > popper[opSide]) {
                        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
                    }
                    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
                    var popperMarginSide = getStyleComputedProperty(data.instance.popper, "margin" + sideCapitalized).replace("px", "");
                    var sideValue = center - getClientRect(data.offsets.popper)[side] - popperMarginSide;
                    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
                    data.arrowElement = arrowElement;
                    data.offsets.arrow = {};
                    data.offsets.arrow[side] = Math.round(sideValue);
                    data.offsets.arrow[altSide] = "";
                    return data;
                }
                function getOppositeVariation(variation) {
                    if (variation === "end") {
                        return "start";
                    } else if (variation === "start") {
                        return "end";
                    }
                    return variation;
                }
                var placements = [ "auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start" ];
                var validPlacements = placements.slice(3);
                function clockwise(placement) {
                    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                    var index = validPlacements.indexOf(placement);
                    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
                    return counter ? arr.reverse() : arr;
                }
                var BEHAVIORS = {
                    FLIP: "flip",
                    CLOCKWISE: "clockwise",
                    COUNTERCLOCKWISE: "counterclockwise"
                };
                function flip(data, options) {
                    if (isModifierEnabled(data.instance.modifiers, "inner")) {
                        return data;
                    }
                    if (data.flipped && data.placement === data.originalPlacement) {
                        return data;
                    }
                    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);
                    var placement = data.placement.split("-")[0];
                    var placementOpposite = getOppositePlacement(placement);
                    var variation = data.placement.split("-")[1] || "";
                    var flipOrder = [];
                    switch (options.behavior) {
                      case BEHAVIORS.FLIP:
                        flipOrder = [ placement, placementOpposite ];
                        break;

                      case BEHAVIORS.CLOCKWISE:
                        flipOrder = clockwise(placement);
                        break;

                      case BEHAVIORS.COUNTERCLOCKWISE:
                        flipOrder = clockwise(placement, true);
                        break;

                      default:
                        flipOrder = options.behavior;
                    }
                    flipOrder.forEach(function(step, index) {
                        if (placement !== step || flipOrder.length === index + 1) {
                            return data;
                        }
                        placement = data.placement.split("-")[0];
                        placementOpposite = getOppositePlacement(placement);
                        var popperOffsets = data.offsets.popper;
                        var refOffsets = data.offsets.reference;
                        var floor = Math.floor;
                        var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
                        var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
                        var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
                        var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
                        var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
                        var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
                        var isVertical = [ "top", "bottom" ].indexOf(placement) !== -1;
                        var flippedVariation = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
                        if (overlapsRef || overflowsBoundaries || flippedVariation) {
                            data.flipped = true;
                            if (overlapsRef || overflowsBoundaries) {
                                placement = flipOrder[index + 1];
                            }
                            if (flippedVariation) {
                                variation = getOppositeVariation(variation);
                            }
                            data.placement = placement + (variation ? "-" + variation : "");
                            data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
                            data = runModifiers(data.instance.modifiers, data, "flip");
                        }
                    });
                    return data;
                }
                function keepTogether(data) {
                    var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                    var placement = data.placement.split("-")[0];
                    var floor = Math.floor;
                    var isVertical = [ "top", "bottom" ].indexOf(placement) !== -1;
                    var side = isVertical ? "right" : "bottom";
                    var opSide = isVertical ? "left" : "top";
                    var measurement = isVertical ? "width" : "height";
                    if (popper[side] < floor(reference[opSide])) {
                        data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
                    }
                    if (popper[opSide] > floor(reference[side])) {
                        data.offsets.popper[opSide] = floor(reference[side]);
                    }
                    return data;
                }
                function toValue(str, measurement, popperOffsets, referenceOffsets) {
                    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
                    var value = +split[1];
                    var unit = split[2];
                    if (!value) {
                        return str;
                    }
                    if (unit.indexOf("%") === 0) {
                        var element = void 0;
                        switch (unit) {
                          case "%p":
                            element = popperOffsets;
                            break;

                          case "%":
                          case "%r":
                          default:
                            element = referenceOffsets;
                        }
                        var rect = getClientRect(element);
                        return rect[measurement] / 100 * value;
                    } else if (unit === "vh" || unit === "vw") {
                        var size = void 0;
                        if (unit === "vh") {
                            size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                        } else {
                            size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                        }
                        return size / 100 * value;
                    } else {
                        return value;
                    }
                }
                function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
                    var offsets = [ 0, 0 ];
                    var useHeight = [ "right", "left" ].indexOf(basePlacement) !== -1;
                    var fragments = offset.split(/(\+|\-)/).map(function(frag) {
                        return frag.trim();
                    });
                    var divider = fragments.indexOf(find(fragments, function(frag) {
                        return frag.search(/,|\s/) !== -1;
                    }));
                    if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
                        console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
                    }
                    var splitRegex = /\s*,\s*|\s+/;
                    var ops = divider !== -1 ? [ fragments.slice(0, divider).concat([ fragments[divider].split(splitRegex)[0] ]), [ fragments[divider].split(splitRegex)[1] ].concat(fragments.slice(divider + 1)) ] : [ fragments ];
                    ops = ops.map(function(op, index) {
                        var measurement = (index === 1 ? !useHeight : useHeight) ? "height" : "width";
                        var mergeWithPrevious = false;
                        return op.reduce(function(a, b) {
                            if (a[a.length - 1] === "" && [ "+", "-" ].indexOf(b) !== -1) {
                                a[a.length - 1] = b;
                                mergeWithPrevious = true;
                                return a;
                            } else if (mergeWithPrevious) {
                                a[a.length - 1] += b;
                                mergeWithPrevious = false;
                                return a;
                            } else {
                                return a.concat(b);
                            }
                        }, []).map(function(str) {
                            return toValue(str, measurement, popperOffsets, referenceOffsets);
                        });
                    });
                    ops.forEach(function(op, index) {
                        op.forEach(function(frag, index2) {
                            if (isNumeric(frag)) {
                                offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1);
                            }
                        });
                    });
                    return offsets;
                }
                function offset(data, _ref) {
                    var offset = _ref.offset;
                    var placement = data.placement, _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                    var basePlacement = placement.split("-")[0];
                    var offsets = void 0;
                    if (isNumeric(+offset)) {
                        offsets = [ +offset, 0 ];
                    } else {
                        offsets = parseOffset(offset, popper, reference, basePlacement);
                    }
                    if (basePlacement === "left") {
                        popper.top += offsets[0];
                        popper.left -= offsets[1];
                    } else if (basePlacement === "right") {
                        popper.top += offsets[0];
                        popper.left += offsets[1];
                    } else if (basePlacement === "top") {
                        popper.left += offsets[0];
                        popper.top -= offsets[1];
                    } else if (basePlacement === "bottom") {
                        popper.left += offsets[0];
                        popper.top += offsets[1];
                    }
                    data.popper = popper;
                    return data;
                }
                function preventOverflow(data, options) {
                    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
                    if (data.instance.reference === boundariesElement) {
                        boundariesElement = getOffsetParent(boundariesElement);
                    }
                    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
                    options.boundaries = boundaries;
                    var order = options.priority;
                    var popper = data.offsets.popper;
                    var check = {
                        primary: function primary(placement) {
                            var value = popper[placement];
                            if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
                                value = Math.max(popper[placement], boundaries[placement]);
                            }
                            return defineProperty({}, placement, value);
                        },
                        secondary: function secondary(placement) {
                            var mainSide = placement === "right" ? "left" : "top";
                            var value = popper[mainSide];
                            if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
                                value = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height));
                            }
                            return defineProperty({}, mainSide, value);
                        }
                    };
                    order.forEach(function(placement) {
                        var side = [ "left", "top" ].indexOf(placement) !== -1 ? "primary" : "secondary";
                        popper = _extends({}, popper, check[side](placement));
                    });
                    data.offsets.popper = popper;
                    return data;
                }
                function shift(data) {
                    var placement = data.placement;
                    var basePlacement = placement.split("-")[0];
                    var shiftvariation = placement.split("-")[1];
                    if (shiftvariation) {
                        var _data$offsets = data.offsets, reference = _data$offsets.reference, popper = _data$offsets.popper;
                        var isVertical = [ "bottom", "top" ].indexOf(basePlacement) !== -1;
                        var side = isVertical ? "left" : "top";
                        var measurement = isVertical ? "width" : "height";
                        var shiftOffsets = {
                            start: defineProperty({}, side, reference[side]),
                            end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
                        };
                        data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
                    }
                    return data;
                }
                function hide(data) {
                    if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
                        return data;
                    }
                    var refRect = data.offsets.reference;
                    var bound = find(data.instance.modifiers, function(modifier) {
                        return modifier.name === "preventOverflow";
                    }).boundaries;
                    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
                        if (data.hide === true) {
                            return data;
                        }
                        data.hide = true;
                        data.attributes["x-out-of-boundaries"] = "";
                    } else {
                        if (data.hide === false) {
                            return data;
                        }
                        data.hide = false;
                        data.attributes["x-out-of-boundaries"] = false;
                    }
                    return data;
                }
                function inner(data) {
                    var placement = data.placement;
                    var basePlacement = placement.split("-")[0];
                    var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                    var isHoriz = [ "left", "right" ].indexOf(basePlacement) !== -1;
                    var subtractLength = [ "top", "left" ].indexOf(basePlacement) === -1;
                    popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
                    data.placement = getOppositePlacement(placement);
                    data.offsets.popper = getClientRect(popper);
                    return data;
                }
                var modifiers = {
                    shift: {
                        order: 100,
                        enabled: true,
                        fn: shift
                    },
                    offset: {
                        order: 200,
                        enabled: true,
                        fn: offset,
                        offset: 0
                    },
                    preventOverflow: {
                        order: 300,
                        enabled: true,
                        fn: preventOverflow,
                        priority: [ "left", "right", "top", "bottom" ],
                        padding: 5,
                        boundariesElement: "scrollParent"
                    },
                    keepTogether: {
                        order: 400,
                        enabled: true,
                        fn: keepTogether
                    },
                    arrow: {
                        order: 500,
                        enabled: true,
                        fn: arrow,
                        element: "[x-arrow]"
                    },
                    flip: {
                        order: 600,
                        enabled: true,
                        fn: flip,
                        behavior: "flip",
                        padding: 5,
                        boundariesElement: "viewport"
                    },
                    inner: {
                        order: 700,
                        enabled: false,
                        fn: inner
                    },
                    hide: {
                        order: 800,
                        enabled: true,
                        fn: hide
                    },
                    computeStyle: {
                        order: 850,
                        enabled: true,
                        fn: computeStyle,
                        gpuAcceleration: true,
                        x: "bottom",
                        y: "right"
                    },
                    applyStyle: {
                        order: 900,
                        enabled: true,
                        fn: applyStyle,
                        onLoad: applyStyleOnLoad,
                        gpuAcceleration: undefined
                    }
                };
                var Defaults = {
                    placement: "bottom",
                    eventsEnabled: true,
                    removeOnDestroy: false,
                    onCreate: function onCreate() {},
                    onUpdate: function onUpdate() {},
                    modifiers: modifiers
                };
                var Popper$1 = function() {
                    function Popper(reference, popper) {
                        var _this = this;
                        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                        classCallCheck(this, Popper);
                        this.scheduleUpdate = function() {
                            return requestAnimationFrame(_this.update);
                        };
                        this.update = debounce(this.update.bind(this));
                        this.options = _extends({}, Popper.Defaults, options);
                        this.state = {
                            isDestroyed: false,
                            isCreated: false,
                            scrollParents: []
                        };
                        this.reference = reference && reference.jquery ? reference[0] : reference;
                        this.popper = popper && popper.jquery ? popper[0] : popper;
                        this.options.modifiers = {};
                        Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function(name) {
                            _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
                        });
                        this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
                            return _extends({
                                name: name
                            }, _this.options.modifiers[name]);
                        }).sort(function(a, b) {
                            return a.order - b.order;
                        });
                        this.modifiers.forEach(function(modifierOptions) {
                            if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
                                modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
                            }
                        });
                        this.update();
                        var eventsEnabled = this.options.eventsEnabled;
                        if (eventsEnabled) {
                            this.enableEventListeners();
                        }
                        this.state.eventsEnabled = eventsEnabled;
                    }
                    createClass(Popper, [ {
                        key: "update",
                        value: function update$$1() {
                            return update.call(this);
                        }
                    }, {
                        key: "destroy",
                        value: function destroy$$1() {
                            return destroy.call(this);
                        }
                    }, {
                        key: "enableEventListeners",
                        value: function enableEventListeners$$1() {
                            return enableEventListeners.call(this);
                        }
                    }, {
                        key: "disableEventListeners",
                        value: function disableEventListeners$$1() {
                            return disableEventListeners.call(this);
                        }
                    } ]);
                    return Popper;
                }();
                Popper$1.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
                Popper$1.placements = placements;
                Popper$1.Defaults = Defaults;
                var popper = Object.freeze({
                    default: Popper$1
                });
                var _popper = popper && Popper$1 || popper;
                var Popper_1 = createCommonjsModule(function(module, exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    var _extends = Object.assign || function(target) {
                        for (var i = 1; i < arguments.length; i++) {
                            var source = arguments[i];
                            for (var key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    target[key] = source[key];
                                }
                            }
                        }
                        return target;
                    };
                    var _createClass = function() {
                        function defineProperties(target, props) {
                            for (var i = 0; i < props.length; i++) {
                                var descriptor = props[i];
                                descriptor.enumerable = descriptor.enumerable || false;
                                descriptor.configurable = true;
                                if ("value" in descriptor) descriptor.writable = true;
                                Object.defineProperty(target, descriptor.key, descriptor);
                            }
                        }
                        return function(Constructor, protoProps, staticProps) {
                            if (protoProps) defineProperties(Constructor.prototype, protoProps);
                            if (staticProps) defineProperties(Constructor, staticProps);
                            return Constructor;
                        };
                    }();
                    var _react2 = _interopRequireDefault(React);
                    var _propTypes2 = _interopRequireDefault(propTypes);
                    var _popper2 = _interopRequireDefault(_popper);
                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        };
                    }
                    function _defineProperty(obj, key, value) {
                        if (key in obj) {
                            Object.defineProperty(obj, key, {
                                value: value,
                                enumerable: true,
                                configurable: true,
                                writable: true
                            });
                        } else {
                            obj[key] = value;
                        }
                        return obj;
                    }
                    function _objectWithoutProperties(obj, keys) {
                        var target = {};
                        for (var i in obj) {
                            if (keys.indexOf(i) >= 0) continue;
                            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
                            target[i] = obj[i];
                        }
                        return target;
                    }
                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError("Cannot call a class as a function");
                        }
                    }
                    function _possibleConstructorReturn(self, call) {
                        if (!self) {
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        }
                        return call && (typeof call === "object" || typeof call === "function") ? call : self;
                    }
                    function _inherits(subClass, superClass) {
                        if (typeof superClass !== "function" && superClass !== null) {
                            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                        }
                        subClass.prototype = Object.create(superClass && superClass.prototype, {
                            constructor: {
                                value: subClass,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                    }
                    var Popper = function(_Component) {
                        _inherits(Popper, _Component);
                        function Popper() {
                            var _ref;
                            var _temp, _this, _ret;
                            _classCallCheck(this, Popper);
                            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }
                            return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Popper.__proto__ || Object.getPrototypeOf(Popper)).call.apply(_ref, [ this ].concat(args))), 
                            _this), _this.state = {}, _this._setArrowNode = function(node) {
                                _this._arrowNode = node;
                            }, _this._getTargetNode = function() {
                                return _this.context.popperManager.getTargetNode();
                            }, _this._getOffsets = function(data) {
                                return Object.keys(data.offsets).map(function(key) {
                                    return data.offsets[key];
                                });
                            }, _this._isDataDirty = function(data) {
                                if (_this.state.data) {
                                    return JSON.stringify(_this._getOffsets(_this.state.data)) !== JSON.stringify(_this._getOffsets(data));
                                } else {
                                    return true;
                                }
                            }, _this._updateStateModifier = {
                                enabled: true,
                                order: 900,
                                fn: function fn(data) {
                                    if (_this._isDataDirty(data)) {
                                        _this.setState({
                                            data: data
                                        });
                                    }
                                    return data;
                                }
                            }, _this._getPopperStyle = function() {
                                var data = _this.state.data;
                                if (!_this._popper || !data) {
                                    return {
                                        position: "absolute",
                                        pointerEvents: "none",
                                        opacity: 0
                                    };
                                }
                                var _data$offsets$popper = data.offsets.popper, top = _data$offsets$popper.top, left = _data$offsets$popper.left, position = _data$offsets$popper.position;
                                return _extends({
                                    position: position
                                }, data.styles);
                            }, _this._getPopperPlacement = function() {
                                return !!_this.state.data ? _this.state.data.placement : undefined;
                            }, _this._getPopperHide = function() {
                                return !!_this.state.data && _this.state.data.hide ? "" : undefined;
                            }, _this._getArrowStyle = function() {
                                if (!_this.state.data || !_this.state.data.offsets.arrow) {
                                    return {};
                                } else {
                                    var _this$state$data$offs = _this.state.data.offsets.arrow, top = _this$state$data$offs.top, left = _this$state$data$offs.left;
                                    return {
                                        top: top,
                                        left: left
                                    };
                                }
                            }, _temp), _possibleConstructorReturn(_this, _ret);
                        }
                        _createClass(Popper, [ {
                            key: "getChildContext",
                            value: function getChildContext() {
                                return {
                                    popper: {
                                        setArrowNode: this._setArrowNode,
                                        getArrowStyle: this._getArrowStyle
                                    }
                                };
                            }
                        }, {
                            key: "componentDidMount",
                            value: function componentDidMount() {
                                this._updatePopper();
                            }
                        }, {
                            key: "componentDidUpdate",
                            value: function componentDidUpdate(lastProps) {
                                if (lastProps.placement !== this.props.placement || lastProps.eventsEnabled !== this.props.eventsEnabled) {
                                    this._updatePopper();
                                }
                                if (this._popper && lastProps.children !== this.props.children) {
                                    this._popper.scheduleUpdate();
                                }
                            }
                        }, {
                            key: "componentWillUnmount",
                            value: function componentWillUnmount() {
                                this._destroyPopper();
                            }
                        }, {
                            key: "_updatePopper",
                            value: function _updatePopper() {
                                this._destroyPopper();
                                if (this._node) {
                                    this._createPopper();
                                }
                            }
                        }, {
                            key: "_createPopper",
                            value: function _createPopper() {
                                var _props = this.props, placement = _props.placement, eventsEnabled = _props.eventsEnabled;
                                var modifiers = _extends({}, this.props.modifiers, {
                                    applyStyle: {
                                        enabled: false
                                    },
                                    updateState: this._updateStateModifier
                                });
                                if (this._arrowNode) {
                                    modifiers.arrow = {
                                        element: this._arrowNode
                                    };
                                }
                                this._popper = new _popper2.default(this._getTargetNode(), this._node, {
                                    placement: placement,
                                    eventsEnabled: eventsEnabled,
                                    modifiers: modifiers
                                });
                                this._popper.scheduleUpdate();
                            }
                        }, {
                            key: "_destroyPopper",
                            value: function _destroyPopper() {
                                if (this._popper) {
                                    this._popper.destroy();
                                }
                            }
                        }, {
                            key: "render",
                            value: function render() {
                                var _this2 = this;
                                var _props2 = this.props, component = _props2.component, innerRef = _props2.innerRef, placement = _props2.placement, eventsEnabled = _props2.eventsEnabled, modifiers = _props2.modifiers, children = _props2.children, restProps = _objectWithoutProperties(_props2, [ "component", "innerRef", "placement", "eventsEnabled", "modifiers", "children" ]);
                                var popperRef = function popperRef(node) {
                                    _this2._node = node;
                                    if (typeof innerRef === "function") {
                                        innerRef(node);
                                    }
                                };
                                var popperStyle = this._getPopperStyle();
                                var popperPlacement = this._getPopperPlacement();
                                var popperHide = this._getPopperHide();
                                if (typeof children === "function") {
                                    var _popperProps;
                                    var popperProps = (_popperProps = {
                                        ref: popperRef,
                                        style: popperStyle
                                    }, _defineProperty(_popperProps, "data-placement", popperPlacement), _defineProperty(_popperProps, "data-x-out-of-boundaries", popperHide), 
                                    _popperProps);
                                    return children({
                                        popperProps: popperProps,
                                        restProps: restProps,
                                        scheduleUpdate: this._popper && this._popper.scheduleUpdate
                                    });
                                }
                                var componentProps = _extends({}, restProps, {
                                    style: _extends({}, restProps.style, popperStyle),
                                    "data-placement": popperPlacement,
                                    "data-x-out-of-boundaries": popperHide
                                });
                                if (typeof component === "string") {
                                    componentProps.ref = popperRef;
                                } else {
                                    componentProps.innerRef = popperRef;
                                }
                                return (0, React.createElement)(component, componentProps, children);
                            }
                        } ]);
                        return Popper;
                    }(React.Component);
                    Popper.contextTypes = {
                        popperManager: _propTypes2.default.object.isRequired
                    };
                    Popper.childContextTypes = {
                        popper: _propTypes2.default.object.isRequired
                    };
                    Popper.propTypes = {
                        component: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ]),
                        innerRef: _propTypes2.default.func,
                        placement: _propTypes2.default.oneOf(_popper2.default.placements),
                        eventsEnabled: _propTypes2.default.bool,
                        modifiers: _propTypes2.default.object,
                        children: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ])
                    };
                    Popper.defaultProps = {
                        component: "div",
                        placement: "bottom",
                        eventsEnabled: true,
                        modifiers: {}
                    };
                    exports.default = Popper;
                });
                unwrapExports(Popper_1);
                var Arrow_1 = createCommonjsModule(function(module, exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    var _extends = Object.assign || function(target) {
                        for (var i = 1; i < arguments.length; i++) {
                            var source = arguments[i];
                            for (var key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    target[key] = source[key];
                                }
                            }
                        }
                        return target;
                    };
                    var _react2 = _interopRequireDefault(React);
                    var _propTypes2 = _interopRequireDefault(propTypes);
                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        };
                    }
                    function _objectWithoutProperties(obj, keys) {
                        var target = {};
                        for (var i in obj) {
                            if (keys.indexOf(i) >= 0) continue;
                            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
                            target[i] = obj[i];
                        }
                        return target;
                    }
                    var Arrow = function Arrow(props, context) {
                        var _props$component = props.component, component = _props$component === undefined ? "span" : _props$component, innerRef = props.innerRef, children = props.children, restProps = _objectWithoutProperties(props, [ "component", "innerRef", "children" ]);
                        var popper = context.popper;
                        var arrowRef = function arrowRef(node) {
                            popper.setArrowNode(node);
                            if (typeof innerRef === "function") {
                                innerRef(node);
                            }
                        };
                        var arrowStyle = popper.getArrowStyle();
                        if (typeof children === "function") {
                            var arrowProps = {
                                ref: arrowRef,
                                style: arrowStyle
                            };
                            return children({
                                arrowProps: arrowProps,
                                restProps: restProps
                            });
                        }
                        var componentProps = _extends({}, restProps, {
                            style: _extends({}, arrowStyle, restProps.style)
                        });
                        if (typeof component === "string") {
                            componentProps.ref = arrowRef;
                        } else {
                            componentProps.innerRef = arrowRef;
                        }
                        return (0, React.createElement)(component, componentProps, children);
                    };
                    Arrow.contextTypes = {
                        popper: _propTypes2.default.object.isRequired
                    };
                    Arrow.propTypes = {
                        component: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ]),
                        innerRef: _propTypes2.default.func,
                        children: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ])
                    };
                    exports.default = Arrow;
                });
                unwrapExports(Arrow_1);
                var reactPopper = createCommonjsModule(function(module, exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.Arrow = exports.Popper = exports.Target = exports.Manager = undefined;
                    var _Manager3 = _interopRequireDefault(Manager_1);
                    var _Target3 = _interopRequireDefault(Target_1);
                    var _Popper3 = _interopRequireDefault(Popper_1);
                    var _Arrow3 = _interopRequireDefault(Arrow_1);
                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        };
                    }
                    exports.Manager = _Manager3.default;
                    exports.Target = _Target3.default;
                    exports.Popper = _Popper3.default;
                    exports.Arrow = _Arrow3.default;
                });
                unwrapExports(reactPopper);
                var reactPopper_1 = reactPopper.Arrow;
                var reactPopper_2 = reactPopper.Popper;
                var reactPopper_3 = reactPopper.Target;
                var reactPopper_4 = reactPopper.Manager;
                var randomID = createCommonjsModule(function(module) {
                    (function() {
                        var randomID = function(len, pattern) {
                            var possibilities = [ "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "0123456789", "~!@#$%^&()_+-={}[];'," ];
                            var chars = "";
                            var pattern = pattern ? pattern : "aA0";
                            pattern.split("").forEach(function(a) {
                                if (!isNaN(parseInt(a))) {
                                    chars += possibilities[2];
                                } else if (/[a-z]/.test(a)) {
                                    chars += possibilities[0];
                                } else if (/[A-Z]/.test(a)) {
                                    chars += possibilities[1];
                                } else {
                                    chars += possibilities[3];
                                }
                            });
                            var len = len ? len : 30;
                            var result = "";
                            while (len--) {
                                result += chars.charAt(Math.floor(Math.random() * chars.length));
                            }
                            return result;
                        };
                        if ("object" !== "undefined" && typeof commonjsRequire !== "undefined") {
                            module.exports = randomID;
                        } else {
                            window["randomID"] = randomID;
                        }
                    })();
                });
                var jsx = function() {
                    var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 60103;
                    return function createRawReactElement(type, props, key, children) {
                        var defaultProps = type && type.defaultProps;
                        var childrenLength = arguments.length - 3;
                        if (!props && childrenLength !== 0) {
                            props = {};
                        }
                        if (props && defaultProps) {
                            for (var propName in defaultProps) {
                                if (props[propName] === void 0) {
                                    props[propName] = defaultProps[propName];
                                }
                            }
                        } else if (!props) {
                            props = defaultProps || {};
                        }
                        if (childrenLength === 1) {
                            props.children = children;
                        } else if (childrenLength > 1) {
                            var childArray = Array(childrenLength);
                            for (var i = 0; i < childrenLength; i++) {
                                childArray[i] = arguments[i + 3];
                            }
                            props.children = childArray;
                        }
                        return {
                            $$typeof: REACT_ELEMENT_TYPE,
                            type: type,
                            key: key === undefined ? null : "" + key,
                            ref: null,
                            props: props,
                            _owner: null
                        };
                    };
                }();
                var asyncGenerator = function() {
                    function AwaitValue(value) {
                        this.value = value;
                    }
                    function AsyncGenerator(gen) {
                        var front, back;
                        function send(key, arg) {
                            return new Promise(function(resolve, reject) {
                                var request = {
                                    key: key,
                                    arg: arg,
                                    resolve: resolve,
                                    reject: reject,
                                    next: null
                                };
                                if (back) {
                                    back = back.next = request;
                                } else {
                                    front = back = request;
                                    resume(key, arg);
                                }
                            });
                        }
                        function resume(key, arg) {
                            try {
                                var result = gen[key](arg);
                                var value = result.value;
                                if (value instanceof AwaitValue) {
                                    Promise.resolve(value.value).then(function(arg) {
                                        resume("next", arg);
                                    }, function(arg) {
                                        resume("throw", arg);
                                    });
                                } else {
                                    settle(result.done ? "return" : "normal", result.value);
                                }
                            } catch (err) {
                                settle("throw", err);
                            }
                        }
                        function settle(type, value) {
                            switch (type) {
                              case "return":
                                front.resolve({
                                    value: value,
                                    done: true
                                });
                                break;

                              case "throw":
                                front.reject(value);
                                break;

                              default:
                                front.resolve({
                                    value: value,
                                    done: false
                                });
                                break;
                            }
                            front = front.next;
                            if (front) {
                                resume(front.key, front.arg);
                            } else {
                                back = null;
                            }
                        }
                        this._invoke = send;
                        if (typeof gen.return !== "function") {
                            this.return = undefined;
                        }
                    }
                    if (typeof Symbol === "function" && Symbol.asyncIterator) {
                        AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
                            return this;
                        };
                    }
                    AsyncGenerator.prototype.next = function(arg) {
                        return this._invoke("next", arg);
                    };
                    AsyncGenerator.prototype.throw = function(arg) {
                        return this._invoke("throw", arg);
                    };
                    AsyncGenerator.prototype.return = function(arg) {
                        return this._invoke("return", arg);
                    };
                    return {
                        wrap: function(fn) {
                            return function() {
                                return new AsyncGenerator(fn.apply(this, arguments));
                            };
                        },
                        await: function(value) {
                            return new AwaitValue(value);
                        }
                    };
                }();
                var classCallCheck$1 = function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                };
                var createClass$1 = function() {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();
                var _extends$1 = Object.assign || function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) {
                            if (Object.prototype.hasOwnProperty.call(source, key)) {
                                target[key] = source[key];
                            }
                        }
                    }
                    return target;
                };
                var inherits = function(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                };
                var possibleConstructorReturn = function(self, call) {
                    if (!self) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return call && (typeof call === "object" || typeof call === "function") ? call : self;
                };
                var _ref3 = jsx("feGaussianBlur", {
                    in: "SourceAlpha",
                    stdDeviation: 3
                });
                var _ref4 = jsx("feOffset", {
                    dx: 7,
                    dy: 1,
                    result: "offsetblur"
                });
                var _ref5 = jsx("feComponentTransfer", {}, void 0, jsx("feFuncA", {
                    type: "linear",
                    slope: "0.2"
                }));
                var _ref6 = jsx("feMerge", {}, void 0, jsx("feMergeNode", {}), jsx("feMergeNode", {
                    in: "SourceGraphic"
                }));
                var ArrowComponent = function(_React$Component) {
                    inherits(ArrowComponent, _React$Component);
                    function ArrowComponent() {
                        classCallCheck$1(this, ArrowComponent);
                        var _this = possibleConstructorReturn(this, (ArrowComponent.__proto__ || Object.getPrototypeOf(ArrowComponent)).call(this));
                        _this.id = randomID(19, "a");
                        return _this;
                    }
                    createClass$1(ArrowComponent, [ {
                        key: "render",
                        value: function render() {
                            var _props = this.props, dataPlacement = _props.dataPlacement, customArrow = _props.customArrow;
                            var id = this.id;
                            var _ref2 = jsx("defs", {
                                xmlns: "http://www.w3.org/2000/svg"
                            }, void 0, jsx("filter", {
                                id: id,
                                height: "130%"
                            }, void 0, _ref3, _ref4, _ref5, _ref6));
                            return jsx(reactPopper_1, {}, void 0, function(_ref) {
                                var arrowProps = _ref.arrowProps;
                                arrowProps.style.position = "absolute";
                                if (/right/gi.test(dataPlacement)) {
                                    arrowProps.style.transform = "rotate(-180deg)";
                                    arrowProps.style.left = "-19px";
                                } else if (/bottom/gi.test(dataPlacement)) {
                                    arrowProps.style.transform = "rotate(-90deg)";
                                    arrowProps.style.top = "-20px";
                                } else if (/top/gi.test(dataPlacement)) {
                                    arrowProps.style.transform = "rotate(90deg)";
                                    arrowProps.style.bottom = "-21px";
                                } else if (/left/gi.test(dataPlacement)) {
                                    arrowProps.style.right = "-19px";
                                }
                                return customArrow ? React.createElement("span", arrowProps, customArrow) : React.createElement("span", arrowProps, jsx("svg", {
                                    xmlnsXlink: "http://www.w3.org/1999/xlink",
                                    viewBox: "0 0 100 100",
                                    version: "1.1",
                                    x: "0px",
                                    y: "0px",
                                    width: 30,
                                    height: 30
                                }, void 0, _ref2, jsx("polygon", {
                                    filter: "url(#" + id + ")",
                                    points: "36 23 64 55 36 80",
                                    fill: "#fff",
                                    fillRule: "evenodd"
                                })));
                            });
                        }
                    } ]);
                    return ArrowComponent;
                }(React.Component);
                var PopoverComponent = function(_React$Component) {
                    inherits(PopoverComponent, _React$Component);
                    function PopoverComponent(props) {
                        classCallCheck$1(this, PopoverComponent);
                        var _this = possibleConstructorReturn(this, (PopoverComponent.__proto__ || Object.getPrototypeOf(PopoverComponent)).call(this, props));
                        _this.click = _this.click.bind(_this);
                        _this.onMouseOver = _this.onMouseOver.bind(_this);
                        _this.closePopoverOnMouseLeave = _this.closePopoverOnMouseLeave.bind(_this);
                        return _this;
                    }
                    createClass$1(PopoverComponent, [ {
                        key: "closePopoverOnMouseLeave",
                        value: function closePopoverOnMouseLeave(e) {
                            e.preventDefault();
                            this.props.onClosePopover();
                        }
                    }, {
                        key: "click",
                        value: function click(e) {
                            var thispopover = this.refs.popover._node;
                            var close = e.target.closest(".popover-content");
                            if (!close) {
                                this.props.onClosePopover();
                            } else {
                                var child_popover = thispopover.querySelector(".popover-content");
                                if (!child_popover) {
                                    if (close.getAttribute("data-id") != thispopover.getAttribute("data-id")) {
                                        this.props.onClosePopover();
                                    }
                                }
                            }
                        }
                    }, {
                        key: "componentWillUnmount",
                        value: function componentWillUnmount() {
                            var _props = this.props, action = _props.action, onClose = _props.onClose;
                            if (action === "click") {
                                document.removeEventListener("click", this.click, false);
                            } else if (action === "hover") {
                                document.removeEventListener("mouseover", this.onMouseOver, false);
                                this.refs.popover._node.removeEventListener("mouseleave", this.closePopoverOnMouseLeave, false);
                            }
                            if (onClose) onClose();
                        }
                    }, {
                        key: "onMouseOver",
                        value: function onMouseOver(e) {
                            var popover = this.refs.popover._node;
                            var child = popover.querySelector(".popover-content");
                            if (!child) {
                                popover.addEventListener("mouseleave", this.closePopoverOnMouseLeave, false);
                            }
                            if (!e.target.closest(".manager")) {
                                this.props.onClosePopover();
                            }
                        }
                    }, {
                        key: "componentDidMount",
                        value: function componentDidMount() {
                            var _props2 = this.props, action = _props2.action, onOpen = _props2.onOpen;
                            if (action === "click") {
                                document.addEventListener("click", this.click, false);
                            } else if (action === "hover") {
                                document.addEventListener("mouseover", this.onMouseOver, false);
                            }
                            if (onOpen) onOpen();
                        }
                    }, {
                        key: "render",
                        value: function render() {
                            var _props3 = this.props, placement = _props3.placement, modifiers = _props3.modifiers, arrow = _props3.arrow, className = _props3.className, motion = _props3.motion, id = _props3.id, customArrow = _props3.customArrow, children = _props3.children;
                            return React.createElement(reactPopper_2, {
                                placement: placement,
                                modifiers: modifiers,
                                ref: "popover"
                            }, function(_ref) {
                                var popperProps = _ref.popperProps;
                                popperProps.className = "popover-content";
                                if (arrow) {
                                    if (popperProps["data-placement"]) {
                                        popperProps.className = "popover-content rap-" + popperProps["data-placement"].split("-")[0];
                                    }
                                }
                                if (className) {
                                    popperProps.className += " " + className;
                                }
                                popperProps.style.width = "250px";
                                if (motion) {
                                    var ArrowCallback = arrow ? jsx(ArrowComponent, {
                                        customArrow: customArrow,
                                        dataPlacement: popperProps["data-placement"]
                                    }) : null;
                                    return children[1]({
                                        "data-id": id
                                    }, popperProps, ArrowCallback);
                                } else {
                                    return React.createElement("div", _extends$1({}, popperProps, {
                                        "data-id": id
                                    }), jsx("div", {}, void 0, children[1], arrow ? jsx(ArrowComponent, {
                                        customArrow: customArrow,
                                        dataPlacement: popperProps["data-placement"]
                                    }) : null));
                                }
                            });
                        }
                    } ]);
                    return PopoverComponent;
                }(React.Component);
                var TargetComponent = function(_React$Component) {
                    inherits(TargetComponent, _React$Component);
                    function TargetComponent(props) {
                        classCallCheck$1(this, TargetComponent);
                        var _this = possibleConstructorReturn(this, (TargetComponent.__proto__ || Object.getPrototypeOf(TargetComponent)).call(this, props));
                        _this.click = _this.click.bind(_this);
                        _this.onMouseEnter = _this.onMouseEnter.bind(_this);
                        _this.onMouseLeave = _this.onMouseLeave.bind(_this);
                        return _this;
                    }
                    createClass$1(TargetComponent, [ {
                        key: "onMouseLeave",
                        value: function onMouseLeave(e) {
                            var getElement = e.relatedTarget;
                            if (getElement && getElement.nodeName) {
                                var close = getElement.closest(".manager");
                                if (close) {
                                    var hasDataId = close.hasAttribute("data-target-id");
                                    if (hasDataId) {
                                        var getDataId = close.getAttribute("data-target-id");
                                        if (getDataId) {
                                            if (getDataId != this.props.id) this.props.closePopover();
                                        }
                                    }
                                }
                            }
                        }
                    }, {
                        key: "onMouseEnter",
                        value: function onMouseEnter() {
                            this.props.openPopover();
                        }
                    }, {
                        key: "componentDidMount",
                        value: function componentDidMount() {
                            var action = this.props.action;
                            var target = ReactDOM.findDOMNode(this);
                            this.target = target;
                            if (action === "click") {
                                target.addEventListener("click", this.click, false);
                            } else if (action === "hover") {
                                target.addEventListener("mouseenter", this.onMouseEnter, false);
                                target.addEventListener("mouseleave", this.onMouseLeave, false);
                            }
                        }
                    }, {
                        key: "componentWillUnmount",
                        value: function componentWillUnmount() {
                            var _props = this.props, action = _props.action;
                            if (action === "click") {
                                this.target.removeEventListener("click", this.click, false);
                            } else if (action === "hover") {
                                this.target.removeEventListener("mouseenter", this.onMouseEnter, false);
                                this.target.removeEventListener("mouseleave", this.onMouseLeave, false);
                            }
                        }
                    }, {
                        key: "click",
                        value: function click(e) {
                            e.stopImmediatePropagation();
                            if (!e.target.nextSibling) this.props.tooglePopover();
                        }
                    }, {
                        key: "render",
                        value: function render() {
                            var _this2 = this;
                            return jsx(reactPopper_3, {}, void 0, function(_ref) {
                                var targetProps = _ref.targetProps;
                                return React.createElement("div", _extends$1({
                                    className: "target-container"
                                }, targetProps), _this2.props.children);
                            });
                        }
                    } ]);
                    return TargetComponent;
                }(React.Component);
                function closestWebshim() {
                    if (window.Element && !Element.prototype.closest) {
                        Element.prototype.closest = function(s) {
                            var matches = (this.document || this.ownerDocument).querySelectorAll(s), i, el = this;
                            do {
                                i = matches.length;
                                while (--i >= 0 && matches.item(i) !== el) {}
                            } while (i < 0 && (el = el.parentElement));
                            return el;
                        };
                    }
                }
                var Popover$1 = function(_React$Component) {
                    inherits(Popover, _React$Component);
                    function Popover(props) {
                        classCallCheck$1(this, Popover);
                        var _this = possibleConstructorReturn(this, (Popover.__proto__ || Object.getPrototypeOf(Popover)).call(this, props));
                        _this.closePopover = _this.closePopover.bind(_this);
                        _this.tooglePopover = _this.tooglePopover.bind(_this);
                        _this.openPopover = _this.openPopover.bind(_this);
                        _this.state = {
                            isOpen: props.defaultIsOpen,
                            id: randomID(10, "a")
                        };
                        return _this;
                    }
                    createClass$1(Popover, [ {
                        key: "componentWillMount",
                        value: function componentWillMount() {
                            closestWebshim();
                        }
                    }, {
                        key: "openPopover",
                        value: function openPopover() {
                            this.setState({
                                isOpen: true
                            });
                        }
                    }, {
                        key: "tooglePopover",
                        value: function tooglePopover() {
                            this.setState({
                                isOpen: !this.state.isOpen
                            });
                        }
                    }, {
                        key: "closePopover",
                        value: function closePopover() {
                            this.setState({
                                isOpen: false
                            });
                        }
                    }, {
                        key: "componentWillReceiveProps",
                        value: function componentWillReceiveProps(_ref) {
                            var open = _ref.open;
                            this.setState({
                                isOpen: open
                            });
                        }
                    }, {
                        key: "render",
                        value: function render() {
                            var _props = this.props, className = _props.className, onClose = _props.onClose, onOpen = _props.onOpen, customArrow = _props.customArrow, arrow = _props.arrow, onClick = _props.onClick, placement = _props.placement, modifiers = _props.modifiers, render = _props.render, action = _props.action, motion = _props.motion, children = _props.children;
                            return jsx(reactPopper_4, {
                                className: "manager",
                                style: {
                                    display: "inline"
                                },
                                "data-target-id": this.state.id
                            }, void 0, jsx(TargetComponent, {
                                id: this.state.id,
                                closePopover: this.closePopover,
                                openPopover: this.openPopover,
                                tooglePopover: this.tooglePopover,
                                action: action
                            }, void 0, children[0]), this.state.isOpen ? React.createElement(PopoverComponent, _extends$1({
                                key: Math.random(1),
                                motion: motion,
                                className: className,
                                onClose: onClose,
                                onOpen: onOpen,
                                customArrow: customArrow,
                                onClosePopover: this.closePopover,
                                placement: placement,
                                modifiers: modifiers
                            }, this.props, {
                                id: this.state.id
                            })) : null);
                        }
                    } ]);
                    return Popover;
                }(React.Component);
                Popover$1.defaultProps = {
                    arrow: true,
                    placement: "auto",
                    action: "click",
                    modifiers: {},
                    motion: false,
                    className: undefined,
                    defaultIsOpen: false,
                    open: false
                };
                return Popover$1;
            });
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
        react: "react",
        "react-dom": "react-dom"
    } ],
    TaskList: [ function(require, module, exports) {
        var React = require("react");
        var ReactDOM = require("react-dom");
        var TaskAPI = require("./utils/TaskAPI");
        var TaskApp = require("./components/TaskApp.react");
        var TaskActions = require("./actions/TaskActions");
        var TaskStore = require("./stores/TaskStore");
        var allStoreIds = {};
        var App = {
            data: {},
            undeletedData: {},
            storeId: "0-0-0",
            getData: function(divId, undeleted) {
                var json = {};
                if (divId) {
                    json = TaskStore.getStoreJson(allStoreIds[divId]);
                } else {
                    json = JSON.parse(JSON.stringify(this.data));
                }
                this.undeletedData = JSON.parse(JSON.stringify(json));
                if (undeleted) return this.undeletedData;
                var arr = [];
                var emptyTasksKey = [];
                var me = this;
                json.taskables.map(function(val, key) {
                    if (val.newItem) {
                        delete val.newItem;
                    }
                    if (val.assignees) {
                        arr = $.merge(arr, val.assignees);
                    }
                    if (val.requester) {
                        arr.push(val.requester);
                    }
                    if (val.isTitleEmpty) {
                        emptyTasksKey.push(key);
                    }
                    if (json.mode == "template") {
                        val.requester = "";
                    }
                    if (typeof val.shouldUpdateHeader != "undefined") {
                        delete val.shouldUpdateHeader;
                    }
                });
                if (typeof json.sortData != "undefined") {
                    var newData = [];
                    json.sortData.map(function(val, key) {
                        var fields = val.split(/sort_/);
                        json.taskables[fields[1]].index = key;
                        newData.push(json.taskables[fields[1]]);
                    });
                    json.taskables = newData;
                    delete json.sortData;
                }
                if (typeof json.sortBy != "undefined") {
                    delete json.sortBy;
                }
                if (typeof json.filterBy != "undefined") {
                    delete json.filterBy;
                }
                if (typeof json.slideTask != "undefined") {
                    delete json.slideTask;
                }
                if (typeof json.toggleTaskIndex != "undefined") {
                    delete json.toggleTaskIndex;
                }
                if (typeof json.baseUrl != "undefined") {
                    delete json.baseUrl;
                }
                if (typeof json.tmailNum != "undefined") {
                    delete json.tmailNum;
                }
                if (typeof json.secNum != "undefined") {
                    delete json.secNum;
                }
                if (typeof json.sectionTitle != "undefined") {
                    delete json.sectionTitle;
                }
                if (typeof json.tmailSubject != "undefined") {
                    delete json.tmailSubject;
                }
                if (typeof json.fwdtmailSubject != "undefined") {
                    delete json.fwdtmailSubject;
                }
                if (typeof json.fwdtmailNum != "undefined") {
                    delete json.fwdtmailNum;
                }
                if (typeof json.mailboxType != "undefined") {
                    delete json.mailboxType;
                }
                if (typeof json.taskNum != "undefined") {
                    delete json.taskNum;
                }
                if (typeof json.fwdtaskNum != "undefined") {
                    delete json.fwdtaskNum;
                }
                if (typeof json.cnum != "undefined") {
                    delete json.cnum;
                }
                if (typeof json.expandTask != "undefined") {
                    delete json.expandTask;
                }
                if (emptyTasksKey.length > 0) {
                    $.each(emptyTasksKey, function(i, k) {
                        json.taskables.splice(k, 1);
                    });
                    json.taskables.map(function(val, key) {
                        json.taskables[key].index = key;
                    });
                }
                var newData = [];
                json.taskables.map(function(val, key) {
                    if (typeof val.deleted == "undefined" || val.deleted == false) {
                        val.index = newData.length;
                        newData.push(val);
                    }
                    delete json.taskables[key].taskId;
                });
                json.taskables = newData;
                var uniqueVals = [];
                $.each(arr, function(i, el) {
                    if ($.inArray(el, uniqueVals) === -1) uniqueVals.push(el);
                });
                json.lastTaskNumber = -1;
                delete json.lastTaskNumber;
                if (typeof json.updateComponent != "undefined") {
                    delete json.updateComponent;
                }
                json.additionalActors = uniqueVals;
                json.isValidationIssue ? delete json.isValidationIssue : "";
                if (typeof json.isChecklist != "undefined" && json.isChecklist == false) {
                    delete json.isChecklist;
                }
                return json;
            },
            setData: function(data) {
                this.data = JSON.parse(JSON.stringify(data));
                TaskAPI.setTaskData(this.data, this.storeId);
            },
            updateTaskNumData: function(taskNum) {
                TaskActions.updateTaskData("Null", "taskNum", taskNum, this.storeId);
            },
            loadSection: function(obj) {
                var data = obj.data;
                var divId = obj.divId;
                var filterBy = obj.filterBy;
                var sortBy = obj.sortBy;
                var hideHeader = obj.hideHeader;
                var expandTask = obj.expandTask;
                var addNewTask = obj.addNewTask;
                var writers = obj.writers;
                var favWriters = obj.favWriters;
                var taskNum = obj.taskNum;
                var tmailNum = obj.tmailNum ? obj.tmailNum : "0";
                var fwdtmailNum = obj.fwdtmailNum ? obj.fwdtmailNum : "0";
                var secNum = obj.secNum ? obj.secNum : "0";
                var changeNum = obj.changeNum ? obj.changeNum : "0";
                var isDiffMode = obj.isDiffMode ? obj.isDiffMode : data.wereTasksReordered ? true : false;
                data.isChecklist = data.isChecklist && data.mode == "template" ? data.isChecklist : obj.isChecklist ? obj.isChecklist : false;
                data.baseUrl = obj.baseUrl;
                data.tmailNum = obj.tmailNum;
                data.fwdtmailNum = fwdtmailNum;
                data.secNum = obj.secNum;
                data.mailboxType = obj.mailboxType;
                data.sectionTitle = obj.sectionTitle;
                data.tmailSubject = obj.tmailSubject;
                data.fwdtmailSubject = obj.fwdtmailSubject;
                data.cnum = obj.cnum;
                data.taskNum = obj.taskNum;
                this.currentUser = JSON.parse(JSON.stringify(obj.currentUser));
                this.storeId = tmailNum + "-" + secNum + "-" + changeNum;
                var diffVersion1 = obj.diffVersion1;
                var diffVersion2 = obj.diffVersion2;
                if (isDiffMode) {
                    var obj = {
                        accepted: [],
                        delivered: [],
                        finished: [],
                        restart: [],
                        started: [],
                        unstarted: [],
                        noLonger: [],
                        newlyAdded: [],
                        open: []
                    };
                    var newData = [];
                    data.taskables.map(function(val, key) {
                        val.index = key;
                        if (val.diffOpType == "DELETED") {
                            data.taskables[key].title = "";
                            data.taskables[key].description = "";
                            data.taskables[key].requester = "";
                            data.taskables[key].taskState = "";
                            data.taskables[key].taskPriority = "";
                            data.taskables[key].assignees = [];
                            data.taskables[key].taskType = "TASK_REQUEST";
                            if (val.baseValue) {
                                data.taskables[key].title = val.baseValue.title ? val.baseValue.title : "";
                                data.taskables[key].description = val.baseValue.description ? val.baseValue.description : "";
                                data.taskables[key].requester = val.baseValue.requester ? val.baseValue.requester : "";
                                data.taskables[key].taskState = val.baseValue.taskState ? val.baseValue.taskState : "";
                                data.taskables[key].taskPriority = val.baseValue.taskPriority ? val.baseValue.taskPriority : "";
                                data.taskables[key].assignees = val.baseValue.assignees ? val.baseValue.assignees : [];
                            }
                        }
                        if (!val.newItem) {
                            if (val.state && val.state == "Accepted" || val.taskState && val.taskState == "Accepted") {
                                obj["accepted"].push(val);
                            } else if (val.state && val.state == "Delivered" || val.taskState && val.taskState == "Delivered") {
                                obj["delivered"].push(val);
                            } else if (val.state && val.state == "Finished" || val.taskState && val.taskState == "Finished") {
                                obj["finished"].push(val);
                            } else if (val.state && val.state == "Rejected" || val.taskState && val.taskState == "Rejected") {
                                obj["restart"].push(val);
                            } else if (val.state && val.state == "Started" || val.taskState && val.taskState == "Started") {
                                obj["started"].push(val);
                            } else if (val.state && val.state == "Unstarted" || val.taskState && val.taskState == "Unstarted") {
                                obj["unstarted"].push(val);
                            } else if (val.state && val.state == "NoLongerApplicable" || val.taskState && val.taskState == "NoLongerApplicable") {
                                obj["noLonger"].push(val);
                            } else {
                                obj["open"].push(val);
                            }
                        }
                    });
                    if (typeof obj.accepted != "undefined" && obj.accepted.length > 0) {
                        $.merge(newData, obj.accepted);
                    }
                    if (typeof obj.delivered != "undefined" && obj.delivered.length > 0) {
                        $.merge(newData, obj.delivered);
                    }
                    if (typeof obj.finished != "undefined" && obj.finished.length > 0) {
                        $.merge(newData, obj.finished);
                    }
                    if (typeof obj.restart != "undefined" && obj.restart.length > 0) {
                        $.merge(newData, obj.restart);
                    }
                    if (typeof obj.started != "undefined" && obj.started.length > 0) {
                        $.merge(newData, obj.started);
                    }
                    if (typeof obj.unstarted != "undefined" && obj.unstarted.length > 0) {
                        $.merge(newData, obj.unstarted);
                    }
                    if (typeof obj.noLonger != "undefined" && obj.noLonger.length > 0) {
                        $.merge(newData, obj.noLonger);
                    }
                    data.taskables = newData;
                    data.filterBy = "changedTasks";
                }
                if (filterBy) data.filterBy = filterBy;
                if (sortBy) data.sortBy = sortBy;
                allStoreIds[divId] = this.storeId;
                if (writers) {
                    this.setWritersData(writers, favWriters, data);
                }
                if (favWriters) {
                    this.setFavWritersData(favWriters, writers);
                }
                this.setData(data);
                ReactDOM.render(React.createElement(TaskApp, {
                    mode: this.data.mode,
                    hideHeader: hideHeader,
                    expandTask: expandTask,
                    isDiffMode: isDiffMode,
                    currentUser: this.currentUser ? this.currentUser : "",
                    divId: divId,
                    taskNum: taskNum,
                    storeId: this.storeId,
                    diffVersion1: diffVersion1,
                    diffVersion2: diffVersion2,
                    isChecklist: data.isChecklist
                }), document.getElementById(divId));
            },
            setWritersData: function(writers, favWriters, data) {
                var duplicateValues = [];
                var taskData = data;
                var fullAdressWriters = {};
                writers.push(this.currentUser);
                writers.map(function(val, key) {
                    if (val.prefix && val.org_name) {
                        var fullAdress = val.prefix + "$" + val.org_name + "." + "tmail21.com";
                        val.fullAdress = fullAdress;
                        fullAdressWriters[fullAdress] = val;
                    }
                });
                if (taskData.taskables.length > 0) {
                    taskData.taskables.map(function(task, key) {
                        if (task.requester && task.requester != "") {
                            if (fullAdressWriters[task.requester]) {
                                task.requester = fullAdressWriters[task.requester].address;
                            }
                        }
                        if (task.assignees && task.assignees.length > 0) {
                            task.assignees.map(function(assignee, keyAssignee) {
                                if (fullAdressWriters[assignee]) {
                                    task.assignees[keyAssignee] = fullAdressWriters[assignee].address;
                                }
                            });
                        }
                    });
                }
                this.writers = JSON.parse(JSON.stringify(writers));
                TaskAPI.setWritersData(writers);
            },
            setFavWritersData: function(favWriters, writers) {
                var duplicateValues = [];
                if (typeof favWriters != "undefined") {
                    var obj = favWriters;
                    Object.keys(obj).map(function(key) {
                        writerAddress = obj[key][1];
                        writerName = obj[key][0];
                        if (writers) {
                            writers.map(function(val, key) {
                                if (val.address == writerAddress) {
                                    if (duplicateValues.indexOf(val.address) == -1) {
                                        duplicateValues.push(val.address);
                                    }
                                }
                            });
                        }
                    });
                }
                if (duplicateValues.length > 0) {
                    var data = [];
                    var obj = favWriters;
                    Object.keys(obj).map(function(key) {
                        if (duplicateValues.indexOf(obj[key][1]) == -1) {
                            data.push(obj[key]);
                        }
                    });
                    favWriters = data;
                }
                this.favWriters = JSON.parse(JSON.stringify(favWriters));
                TaskAPI.setFavWritersData(favWriters, writers);
            },
            validationIssue: function() {
                var json = JSON.parse(JSON.stringify(this.data));
                var hasContent = false;
                var currentUserAddress = this.currentUser.address;
                var taskLength = json.taskables.length;
                json.taskables.map(function(val, key) {
                    if (val.title == "" && (val.description != "" || val.requester != "" || val.assignees.length > 0) && (taskLength > 1 && !val.newItem)) {
                        hasContent = true;
                    }
                });
                if (json.isValidationIssue && hasContent) {
                    return true;
                } else {
                    return false;
                }
            },
            destroyTasklistComponent: function(id) {
                ReactDOM.unmountComponentAtNode(document.getElementById(id));
            }
        };
        module.exports = App;
    }, {
        "./actions/TaskActions": 1,
        "./components/TaskApp.react": 4,
        "./stores/TaskStore": 12,
        "./utils/TaskAPI": 15,
        react: "react",
        "react-dom": "react-dom"
    } ]
}, {}, []);

require = function() {
    function r(e, n, t) {
        function o(i, f) {
            if (!n[i]) {
                if (!e[i]) {
                    var c = "function" == typeof require && require;
                    if (!f && c) return c(i, !0);
                    if (u) return u(i, !0);
                    var a = new Error("Cannot find module '" + i + "'");
                    throw a.code = "MODULE_NOT_FOUND", a;
                }
                var p = n[i] = {
                    exports: {}
                };
                e[i][0].call(p.exports, function(r) {
                    var n = e[i][1][r];
                    return o(n || r);
                }, p, p.exports, r, e, n, t);
            }
            return n[i].exports;
        }
        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
        return o;
    }
    return r;
}()({
    1: [ function(require, module, exports) {
        var Popover = require("react-awesome-popover");
        var React = require("react");
        var ReactDOM = require("react-dom");
        var createReactClass = require("create-react-class");
        var Global = require("./Global");
        var CommonMixin = require("./CommonMixin");
        var ActionButton = createReactClass({
            mixins: [ CommonMixin ],
            getInitialState: function() {
                return {
                    userInput: "",
                    formModeVal: this.props.formModeVal
                };
            },
            componentDidMount: function() {
                var mainIdEl = document.getElementById(Global.mainCmpId);
                var elField = $(mainIdEl).find("[name='" + this.props.elComponent.name + "']");
                var selectedActionButton = "";
                for (var i = 0; i < elField.length; i++) {
                    if (elField[i].checked) {
                        selectedActionButton = $(elField[i]).parent("label").find("span").attr("name");
                        break;
                    }
                }
                if (selectedActionButton != "") {
                    $(mainIdEl).find("[name='" + this.props.elComponent.name + "']").parent("label").parent("div").find("label").hide();
                    $(mainIdEl).find("[name='" + selectedActionButton + "']").parent("label").show();
                }
                var obj = {
                    elName: this.props.elComponent.name,
                    elVal: ReactDOM.findDOMNode(this.refs[this.props.elComponent.name]).value,
                    validator: this.props.elComponent.validator,
                    type: "radio"
                };
                this.checkIfObjectExists(Global.allFormElObjects, this.props.elComponent.name, "", "");
                Global.allFormElObjects.push(obj);
            },
            render: function() {
                var me = this;
                var actionButtonName = this.props.elComponent.name;
                var frmMode = this.state.formModeVal;
                var fieldValue = "";
                if (this.props.elData && typeof this.props.elData[this.props.elComponent.name] != "undefined") {
                    fieldValue = this.props.elData[this.props.elComponent.name];
                } else {
                    fieldValue = this.props.elComponent.value ? this.props.elComponent.value : "";
                }
                var diffDataCls = diffDataIconCls = diffData = "";
                var isDiff = false;
                if (this.props.elDiffData && typeof this.props.elDiffData[this.props.elComponent.name] != "undefined") {
                    isDiff = true;
                    diffDataIconCls = "modified-data-icon";
                    var diffValClass = this.props.elDiffData[this.props.elComponent.name];
                    var diffArr = diffValClass.split("~diff~");
                    diffData = diffArr[0];
                    diffDataCls = diffArr[1];
                }
                if (!me.props.elComponent.style) {
                    me.props.elComponent.style = {};
                }
                var editModeCheckedCls = inEditMode = "";
                var dStyle = me.props.elComponent.style;
                dStyle = jQuery.parseJSON(JSON.stringify(dStyle));
                var elDefaultColor = dStyle.backgroundColor;
                var actionButtonItems = this.props.elComponent.elements.map(function(val, index) {
                    if (diffData == val.value) diffData = val.stateTitle;
                    dStyle.backgroundColor = "";
                    if (val.stateColor != "" && fieldValue == val.value) {
                        var undoBtnCls = "";
                        var stateClrCls = "";
                        dStyle.backgroundColor = val.stateColor;
                        var stateTitleVal = val.stateTitle;
                    } else {
                        var stateClrCls = "action-button-span-default-clr";
                        dStyle.backgroundColor = elDefaultColor;
                        var stateTitleVal = val.label;
                    }
                    nnewStyle = jQuery.parseJSON(JSON.stringify(dStyle));
                    return React.createElement("label", {
                        key: Math.random(),
                        className: "r-form-action-button-label-box " + (val.clsName ? val.clsName : "")
                    }, React.createElement("input", {
                        key: Math.random(),
                        type: "radio",
                        className: "r-form-action-button " + (val.clsName ? val.clsName : ""),
                        ref: actionButtonName,
                        rel: me.props.cmpId,
                        name: actionButtonName,
                        value: val.value,
                        onChange: me.onChange,
                        defaultChecked: fieldValue == val.value ? true : false
                    }), React.createElement("span", {
                        style: nnewStyle,
                        className: "r-form-action-button-span " + stateClrCls + " " + editModeCheckedCls,
                        name: actionButtonName + "-" + index
                    }, " " + stateTitleVal), React.createElement("div", {
                        key: Math.random(),
                        className: "hidden",
                        name: actionButtonName + "-" + index + "_stateTitle",
                        value: val.stateTitle,
                        title: val.label
                    }));
                });
                var hoverTitle = diffData == "" ? "No Value" : diffData;
                if (this.props.elComponent.label == "") {
                    var clsName = "hidden";
                } else {
                    var clsName = "";
                }
                this.props.elComponent.maxOptionNumber = this.props.elComponent.maxOptionNumber ? this.props.elComponent.maxOptionNumber : this.props.elComponent.elements.length;
                return React.createElement("div", {
                    className: diffDataCls + " form-element-box float-left " + this.props.elComponent.ctClsName,
                    "data-json": JSON.stringify(this.props.elComponent)
                }, React.createElement("div", {
                    className: clsName + " float-left form-field-label"
                }, React.createElement("label", {
                    name: this.props.elComponent.name + "-label",
                    className: "r-form-el-label " + (this.props.clsName ? this.props.clsName : ""),
                    style: this.props.elComponent.labelStyle
                }, React.createElement("span", null, this.props.elComponent.label), React.createElement("b", null, ":"), React.createElement("span", {
                    className: "required-sign"
                }, this.props.elComponent.validator ? this.props.elComponent.validator.isRequired ? "*" : "" : ""))), React.createElement("div", {
                    className: "float-left form-field"
                }, actionButtonItems, React.createElement("br", null), React.createElement("div", {
                    name: this.props.elComponent.name + "_errorMsg",
                    className: this.props.elComponent.name + "_errorMsg error-message"
                })), React.createElement("span", {
                    className: diffDataIconCls,
                    alt: diffData,
                    title: diffData
                }));
            }
        });
        module.exports = ActionButton;
    }, {
        "./CommonMixin": 4,
        "./Global": 10,
        "create-react-class": 19,
        react: "react",
        "react-awesome-popover": 27,
        "react-dom": "react-dom"
    } ],
    2: [ function(require, module, exports) {
        var Popover = require("react-awesome-popover");
        var React = require("react");
        var ReactDOM = require("react-dom");
        var createReactClass = require("create-react-class");
        var Global = require("./Global");
        var CommonMixin = require("./CommonMixin");
        var CheckBox = createReactClass({
            mixins: [ CommonMixin ],
            getInitialState: function() {
                return {
                    userInput: "",
                    formModeVal: this.props.formModeVal
                };
            },
            componentDidMount: function() {
                var obj = {
                    elName: this.props.elComponent.name,
                    elVal: ReactDOM.findDOMNode(this.refs[this.props.elComponent.name]).value,
                    validator: this.props.elComponent.validator,
                    type: "checkbox"
                };
                this.checkIfObjectExists(Global.allFormElObjects, this.props.elComponent.name, "", "");
                Global.allFormElObjects.push(obj);
            },
            render: function() {
                var me = this;
                var checkBoxName = this.props.elComponent.name;
                var fieldValue = "";
                if (this.props.elData && typeof this.props.elData[this.props.elComponent.name] != "undefined") {
                    fieldValue = this.props.elData[this.props.elComponent.name];
                } else {
                    fieldValue = this.props.elComponent.value ? this.props.elComponent.value : "";
                }
                this.props.elComponent.value = fieldValue;
                var diffDataCls = diffDataIconCls = diffData = "";
                var isDiff = false;
                if (this.props.elDiffData && typeof this.props.elDiffData[this.props.elComponent.name] != "undefined") {
                    isDiff = true;
                    diffDataIconCls = "modified-data-icon";
                    var diffValClass = this.props.elDiffData[this.props.elComponent.name];
                    var diffArr = diffValClass.split("~diff~");
                    diffData = diffArr[0];
                    diffDataCls = diffArr[1];
                }
                var newDataVal = "";
                var checkBoxItems = this.props.elComponent.elements.map(function(val, index) {
                    var diffDataArr = diffData.split(",");
                    if (diffDataArr.length > 0) {
                        diffDataArr.map(function(v, i) {
                            if (v == val.value) newDataVal = newDataVal + "," + val.label;
                        });
                    } else {
                        if (diffData == val.value) diffData = val.label;
                    }
                    return React.createElement("label", {
                        key: Math.random(),
                        className: "r-form-check-box-label-box " + (val.clsName ? val.clsName : "")
                    }, React.createElement("input", {
                        type: "checkbox",
                        value: val.value,
                        key: Math.random(),
                        className: "r-form-check-box " + (val.clsName ? val.clsName : ""),
                        ref: checkBoxName,
                        name: checkBoxName,
                        onChange: me.onChange,
                        defaultChecked: fieldValue != "" ? typeof fieldValue != "string" ? fieldValue.indexOf(val.value) > -1 ? true : false : fieldValue == val.value ? true : false : false
                    }), React.createElement("span", {
                        name: checkBoxName + "-" + index
                    }, " " + val.label));
                });
                if (newDataVal != "") {
                    if (newDataVal.indexOf(",", 1)) {
                        diffData = newDataVal.substring(1, newDataVal.length);
                    } else {
                        diffData = newDataVal;
                    }
                    newDataVal = "";
                }
                var hoverTitle = diffData == "" ? "No Value" : diffData;
                if (this.props.elComponent.label == "") {
                    var clsName = "hidden";
                } else {
                    var clsName = "";
                }
                this.props.elComponent.maxOptionNumber = this.props.elComponent.maxOptionNumber ? this.props.elComponent.maxOptionNumber : this.props.elComponent.elements.length;
                return React.createElement("div", {
                    className: diffDataCls + " form-element-box float-left " + this.props.elComponent.ctClsName,
                    "data-json": JSON.stringify(this.props.elComponent),
                    style: this.props.elComponent.style ? this.props.elComponent.style : {}
                }, React.createElement("div", {
                    className: clsName + " float-left form-field-label"
                }, React.createElement("label", {
                    name: this.props.elComponent.name + "-label",
                    className: "r-form-el-label " + (this.props.clsName ? this.props.clsName : ""),
                    style: this.props.elComponent.labelStyle
                }, React.createElement("span", null, this.props.elComponent.label), React.createElement("b", null, ":"), React.createElement("span", {
                    className: "required-sign"
                }, this.props.elComponent.validator ? this.props.elComponent.validator.isRequired ? "*" : "" : ""))), React.createElement("div", {
                    className: "float-left form-field"
                }, checkBoxItems, React.createElement("br", null), React.createElement("div", {
                    name: this.props.elComponent.name + "_errorMsg",
                    className: this.props.elComponent.name + "_errorMsg error-message"
                })), React.createElement("span", {
                    className: diffDataIconCls,
                    alt: diffData,
                    title: diffData
                }));
            }
        });
        module.exports = CheckBox;
    }, {
        "./CommonMixin": 4,
        "./Global": 10,
        "create-react-class": 19,
        react: "react",
        "react-awesome-popover": 27,
        "react-dom": "react-dom"
    } ],
    3: [ function(require, module, exports) {
        var React = require("react");
        var ReactDOM = require("react-dom");
        var createReactClass = require("create-react-class");
        var Global = require("./Global");
        var CommonMixin = require("./CommonMixin");
        var ChoiceOption = createReactClass({
            mixins: [ CommonMixin ],
            getInitialState: function() {
                return {
                    userInput: "",
                    formModeVal: this.props.formModeVal
                };
            },
            componentDidMount: function() {
                var mainIdEl = document.getElementById(Global.mainCmpId);
                var obj = {
                    elName: this.props.elComponent.name[0],
                    elVal: ReactDOM.findDOMNode(this.refs[this.props.elComponent.name[0]]).value,
                    validator: this.props.elComponent.validator
                };
                this.checkIfObjectExists(Global.allFormElObjects, this.props.elComponent.name[0], "", "");
                Global.allFormElObjects.push(obj);
                var obj = {
                    elName: this.props.elComponent.name[1],
                    elVal: ReactDOM.findDOMNode(this.refs[this.props.elComponent.name[1]]).value,
                    validator: this.props.elComponent.validator
                };
                this.checkIfObjectExists(Global.allFormElObjects, this.props.elComponent.name[1], "", "");
                Global.allFormElObjects.push(obj);
            },
            render: function() {
                var me = this;
                var choiceDefaultValue = choiceDefaultValueSelected = choiceDefaultCheckBoxValue = optionTitle = optionAddClass = optionDeleteClass = "";
                var flVal = "";
                if (this.props.elComponent.choiceDefaultValue) {
                    if (!this.props.elComponent.choiceDefaultCheckBoxValue) {
                        choiceDefaultValue = "choice-default-value";
                        optionTitle = "Make this option default";
                    }
                    optionAddClass = "add-new-choice-icon";
                    optionDeleteClass = "delete-new-choice-icon";
                }
                var optionChoiceItems = this.props.elComponent.name.map(function(val, index) {
                    if (me.props.elComponent.label[index] == "") {
                        var clsName = "hidden";
                    } else {
                        var clsName = "";
                    }
                    if (me.props.elComponent.choiceDefaultValue == me.props.elComponent.value[1]) {
                        choiceDefaultValueSelected = "choice-default-value-selected";
                        optionTitle = "This option is default selected";
                    }
                    return React.createElement("div", {
                        key: "c1" + index,
                        className: "float-left margin-right " + (index == 1 ? me.props.elComponent.optionValClsName : "")
                    }, React.createElement("div", {
                        key: "c2" + index,
                        className: clsName + " float-left form-field-label"
                    }, React.createElement("label", {
                        key: "c3" + index,
                        name: me.props.elComponent.name[index] + "-label",
                        className: "r-form-el-label " + (me.props.clsName ? me.props.clsName : ""),
                        style: me.props.elComponent.labelStyle
                    }, me.props.elComponent.label, React.createElement("b", null, ":"), React.createElement("span", {
                        key: "c4" + index,
                        className: "required-sign"
                    }, me.props.elComponent.validator ? me.props.elComponent.validator.isRequired ? "*" : "" : ""))), React.createElement("div", {
                        key: "c5" + index,
                        className: "float-left form-field"
                    }, React.createElement("input", {
                        key: "c5" + index,
                        type: "text",
                        className: "r-form-text " + (me.props.elComponent.clsName ? me.props.elComponent.clsName : ""),
                        style: me.props.elComponent.style ? me.props.elComponent.style : {},
                        ref: me.props.elComponent.name[index],
                        name: me.props.elComponent.name[index],
                        placeholder: me.props.elComponent.placeHolder,
                        defaultValue: me.props.elComponent.value[index],
                        onChange: me.onChange,
                        onBlur: me.onBlur,
                        onClick: me.onChange
                    })));
                });
                return React.createElement("div", {
                    className: "form-element-box choice-wrapper float-left clear " + this.props.elComponent.ctClsName,
                    "data-json": JSON.stringify(this.props.elComponent)
                }, optionChoiceItems, React.createElement("div", {
                    name: me.props.elComponent.name[0] + "_errorMsg",
                    className: me.props.elComponent.name[0] + "_errorMsg error-message"
                }), React.createElement("div", {
                    name: me.props.elComponent.name[1] + "_errorMsg",
                    className: me.props.elComponent.name[1] + "_errorMsg error-message"
                }));
            }
        });
        module.exports = ChoiceOption;
    }, {
        "./CommonMixin": 4,
        "./Global": 10,
        "create-react-class": 19,
        react: "react",
        "react-dom": "react-dom"
    } ],
    4: [ function(require, module, exports) {
        var React = require("react");
        var ReactDOM = require("react-dom");
        var Global = require("./Global");
        var CommonMixin = {
            formMode: "read",
            applyValidations: true,
            initiallyStartup: false,
            init: function() {
                Global.isMobile = this.isMobile.any() == null ? false : true;
            },
            isMobile: {
                Android: function() {
                    return navigator.userAgent.match(/Android/i);
                },
                BlackBerry: function() {
                    return navigator.userAgent.match(/BlackBerry/i);
                },
                iOS: function() {
                    return navigator.userAgent.match(/iPhone|iPad|iPod/i);
                },
                Opera: function() {
                    return navigator.userAgent.match(/Opera Mini/i);
                },
                Windows: function() {
                    return navigator.userAgent.match(/IEMobile/i);
                },
                any: function() {
                    return this.Android() || this.BlackBerry() || this.iOS() || this.Opera() || this.Windows();
                }
            },
            isInViewport: function(element) {
                var rect = element.getBoundingClientRect();
                var html = document.documentElement;
                return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || html.clientHeight) && rect.right <= (window.innerWidth || html.clientWidth);
            },
            confirmBox: function(title, message, cb, config) {
                var me = this;
                Global.callMe("open");
                var config = config ? config : {};
                config.id = config.id ? config.id : "t-confirm-msg";
                $("[name='common_alert_popup']").dialog({
                    title: title,
                    width: 500,
                    height: 190,
                    modal: true,
                    resizable: false,
                    buttons: [ {
                        text: config.yesButtonText ? config.okButtonText : "Yes",
                        name: "popupBtnYes",
                        click: function() {
                            Global.callMe("close");
                            cb("yes", this.text);
                            $(this).dialog("destroy");
                            $("[name='common_alert_popup']").html("");
                        }
                    }, {
                        text: config.yesButtonText ? config.okButtonText : "No",
                        name: "popupBtnNo",
                        click: function() {
                            Global.callMe("close");
                            cb("no", this.text);
                            $(this).dialog("destroy");
                            $("[name='common_alert_popup']").html("");
                        }
                    } ],
                    close: function(ev, ui) {
                        Global.callMe("close");
                        $(this).dialog("destroy");
                        $("[name='common_alert_popup']").html("");
                    }
                });
                $("[name='common_alert_popup']").html("<p style='font-size: 12px;'><span class='ui-icon ui-icon-alert' style='float:left; margin:0 7px 20px 0;'></span>" + message + "</p>");
            },
            alertBox: function(title, message, cb, config) {
                Global.callMe("open");
                var config = config ? config : {};
                config.id = config.id ? config.id : "t-alert-msg";
                $("[name='common_alert_popup']").dialog({
                    title: title,
                    width: 500,
                    height: 190,
                    resizable: false,
                    modal: true,
                    buttons: [ {
                        text: config.yesButtonText ? config.okButtonText : "Ok",
                        name: "popupBtnOk",
                        click: function() {
                            Global.callMe("close");
                            if (cb) cb("yes", this.text);
                            $(this).dialog("destroy");
                            $("[name='common_alert_popup']").html("");
                        }
                    } ],
                    close: function(ev, ui) {
                        Global.callMe("close");
                        $(this).dialog("destroy");
                        $("[name='common_alert_popup']").html("");
                    }
                });
                $("[name='common_alert_popup']").html("<p style='font-size: 12px;'><span class='ui-icon ui-icon-alert' style='float:left; margin:0 7px 20px 0;'></span>" + message + "</p>");
            },
            checkDefaultValValidations: function(validators, val) {
                if (val != "" && typeof validators != "undefined") {
                    if (validators.isAlpha) {
                        var letters = /^[A-Za-z ]+$/;
                        if (!val.match(letters)) {
                            $("[name='valueToolBoxProp_errorMsg']").html("Alpha characters only, will revert to last valid value.");
                            return true;
                        } else {
                            $("[name='charValidationToolBoxProp_errorMsg']").html("");
                        }
                    }
                    if (validators.isNumeric) {
                        var letters = /^[0-9., ]+$/;
                        if (!val.match(letters)) {
                            $("[name='valueToolBoxProp_errorMsg']").html("Numeric characters only, will revert to last valid value.");
                            return true;
                        } else {
                            $("[name='charValidationToolBoxProp_errorMsg']").html("");
                        }
                    }
                    if (validators.isAlphaNumeric) {
                        var letters = /^[0-9a-zA-Z ]+$/;
                        if (!val.match(letters)) {
                            $("[name='valueToolBoxProp_errorMsg']").html("Alphanumeric characters only, will revert to last valid value.");
                            return true;
                        } else {
                            $("[name='charValidationToolBoxProp_errorMsg']").html("");
                        }
                    }
                    if (validators.minLength) {
                        if (val.length < validators.minLength) {
                            $("[name='valueToolBoxProp_errorMsg']").html("should not less than " + validators.minLength + " characters, will revert to last valid value.");
                            return true;
                        } else {
                            $("[name='minLengthToolBoxProp_errorMsg']").html("");
                        }
                    }
                    if (validators.maxLength) {
                        if (val.length > validators.maxLength) {
                            $("[name='valueToolBoxProp_errorMsg']").html("should not greater than " + validators.maxLength + " characters, will revert to last valid value.");
                            return true;
                        } else {
                            $("[name='maxLengthToolBoxProp_errorMsg']").html("");
                        }
                    }
                    if (validators.email) {
                        var pattern = /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,5})+$/;
                        if (!pattern.test(val)) {
                            $("[name='valueToolBoxProp_errorMsg']").html("Invalid email address, will revert to last valid value.");
                            return true;
                        } else {
                            $("[name='validationToolBoxProp_errorMsg']").html("");
                        }
                    }
                }
                return false;
            },
            formRenderedAt: function(mCmpId) {
                var mCCmpId = document.getElementById(mCmpId + "-renderedAt");
                var renderedAt = $(mCCmpId).html();
                var timeStamp = renderedAt;
                if (timeStamp != "") {
                    var renderedAtArr = timeStamp.split("~");
                    if (renderedAtArr[0] == mCmpId) {
                        return renderedAtArr[1];
                    } else {
                        return null;
                    }
                } else {
                    return null;
                }
            },
            removeDuplicateObjectInArr: function(mCmpId, myArr) {
                var results = [];
                var idsSeen = {}, idSeenValue = {};
                for (var i = 0, len = myArr.length, id; i < len; ++i) {
                    id = myArr[i].elName;
                    if (idsSeen[id] !== idSeenValue) {
                        var mCCmpId = document.getElementById(mCmpId);
                        if ($(mCCmpId).find("[name='" + myArr[i].elName + "']").parents(".formInfomation").attr("class")) {
                            results.push(myArr[i]);
                            idsSeen[id] = idSeenValue;
                        }
                    }
                }
                return results;
            },
            setFormMode: function(id, json, mode, isShowErrMsg, cb) {
                var me = this;
                this.formMode = mode;
                if (mode == "read") this.initiallyStartup = true; else this.initiallyStartup = false;
                if (json.formStructure) {
                    this.applyValidations = json.formStructure.applyValidations;
                }
                ReactDOM.render(React.createElement(FormPanel, {
                    cmpId: id,
                    formInfo: json,
                    formMode: mode,
                    isShowErrMsg: isShowErrMsg,
                    callMe: cb
                }), document.getElementById(id));
                if (this.formMode == "edit") {
                    if ($("#form-section-container-edit-toolbox").length <= 0) {
                        var existEl = document.getElementById(id);
                        var newEl = document.createElement("div");
                        newEl.id = "form-section-container-edit-toolbox";
                        newEl.className = "main-react-form-container form-toolbox-container";
                        existEl.appendChild(newEl);
                        me.showEditPanel(id, json, this.formMode, 0);
                    }
                    setTimeout(function() {
                        $("#form-toolbox-container").show();
                    }, 100);
                }
                this.validateForm(mode, id, this.initiallyStartup, "");
            },
            getFormSectionData: function(mCmpId) {
                var formData = {};
                Global.allFormElObjects = this.removeDuplicateObjectInArr(mCmpId, Global.allFormElObjects);
                var elmCmpId = document.getElementById(mCmpId);
                var validateRes = Global.allFormElObjects.map(function(val) {
                    if ($("[name='" + val.elName + "']").parents(".formInfomation").attr("name") == "TMFormSectionContainer") {
                        if (val.type == "radio" || val.type == "checkbox" || val.type == "scheckbox") {
                            var elField = $(elmCmpId).find("[name='" + val.elName + "']");
                            var checkedVal = [];
                            for (var i = 0; i < elField.length; i++) {
                                if (elField[i].checked) {
                                    if (val.type == "radio") {
                                        var checkedVal = elField[i].value;
                                    } else {
                                        checkedVal.push(elField[i].value);
                                    }
                                }
                            }
                            if (checkedVal.length > 0) formData[val.elName] = checkedVal;
                        } else {
                            var updatedFldVal = $(elmCmpId).find("[name='" + val.elName + "']").val();
                            if (updatedFldVal != "") formData[val.elName] = updatedFldVal;
                        }
                    }
                });
                return JSON.stringify(formData);
            },
            getFormSectionJSON: function(mCmpId, formInfo, exportJson) {
                var mainIdEl = document.getElementById(mCmpId);
                formInfo.formStructure.elements = [];
                $(mainIdEl).find("[name='TMFormSectionContainer'] div[data-json]").each(function(index) {
                    if ($(this).attr("data-json") != "" && ($(this).parent(".handle-sortable:visible").length > 0 || $(this).parent(".el-container:visible").length > 0)) {
                        formInfo.formStructure.elements.push(jQuery.parseJSON($(this).attr("data-json")));
                    }
                });
                if ($(mainIdEl).find("[name='TMFormSectionContainer']").attr("data-json")) {
                    var formProperties = jQuery.parseJSON($(mainIdEl).find("[name='TMFormSectionContainer']").attr("data-json"));
                    formInfo.formStructure.maxFldNumber = formProperties.maxFldNumber;
                    formInfo.formStructure.frmDescription = formProperties.frmDescription;
                    formInfo.formStructure.frmDescFontWeight = formProperties.frmDescFontWeight;
                    formInfo.formStructure.frmDescFontStyle = formProperties.frmDescFontStyle;
                    formInfo.formStructure.frmDescFontDecoration = formProperties.frmDescFontDecoration;
                    formInfo.formStructure.frmDescFontAlign = formProperties.frmDescFontAlign;
                    formInfo.formStructure.frmTitle = formProperties.frmTitle;
                    formInfo.formStructure.frmlabelWidth = formProperties.frmlabelWidth;
                    if (formInfo.formStructure.style) formInfo.formStructure.style["fontSize"] = formProperties.style.fontSize;
                }
                if (exportJson == "structure-json") {
                    var partialJSON = {
                        formStructure: formInfo.formStructure
                    };
                    return JSON.stringify(partialJSON);
                }
                var jsonData = jQuery.parseJSON(this.getFormSectionData(mCmpId));
                formInfo.formData = jsonData;
                if (exportJson == "data-json") {
                    var partialJSON = {
                        formData: jsonData
                    };
                    return JSON.stringify(partialJSON);
                }
                formInfo = JSON.stringify(formInfo);
                $("#formJsonData").val(formInfo);
                return formInfo;
            },
            getDiffJson: function(currentJson, diffJson) {
                var diff = {};
                for (var k in currentJson) {
                    if (!(k in diffJson)) {
                        if (currentJson[k] != "") {
                            diff[k] = "No Value Set~diff~set-data-ui";
                        } else {
                            diff[k] = undefined;
                        }
                    } else if (currentJson[k] !== diffJson[k]) {
                        if (currentJson[k] != "" || diffJson[k] != "") {
                            var dVal = diffJson[k] != "" ? diffJson[k] : "No Value Set";
                            var nVal = currentJson[k];
                            if (String(dVal).trim() != String(nVal).trim()) {
                                if (nVal == "") diff[k] = dVal + "~diff~unset-data-ui"; else if (dVal == "No Value Set") diff[k] = dVal + "~diff~set-data-ui"; else diff[k] = dVal + "~diff~modified-data-ui";
                            }
                        }
                    }
                }
                for (k in diffJson) {
                    v = diffJson[k];
                    if (!(k in currentJson)) {
                        if (v == "" && currentJson[k] == "undefined") {} else {
                            diff[k] = diffJson[k] + "~diff~set-data-ui";
                        }
                    }
                }
                return diff;
            },
            checkIfObjectExists: function(allFormObjects, name, type, value) {
                for (var i in allFormObjects) {
                    if (allFormObjects[i].elName == name) {
                        if (type == "validation") {
                            allFormObjects[i].validator = value;
                        } else {
                            Global.allFormElObjects.splice(Global.allFormElObjects.indexOf(allFormObjects[i]), 1);
                        }
                        break;
                    }
                }
            },
            err: "",
            hasStructureValidationIssues: function(mCmpId) {
                var err = false;
                var fldNameArr = [];
                var mainIdEl = document.getElementById(mCmpId);
                jQuery(mainIdEl).find("[name='TMFormSectionContainer'] div[data-json]").each(function(index) {
                    el = $(this);
                    if ($(this).attr("data-json")) {
                        var formElJSON = jQuery.parseJSON($(this).attr("data-json"));
                        var formSubElJSON = formElJSON.elements ? formElJSON.elements : "";
                        if (fldNameArr.indexOf(formElJSON.name) > -1) {
                            err = true;
                            return true;
                        } else {
                            fldNameArr.push(formElJSON.name);
                        }
                        if (formElJSON.name.length > 20) {
                            err = true;
                            return true;
                        }
                        if (!/^[a-z](?:-?[a-z0-9~]+)*$/i.test(formElJSON.name)) {
                            err = true;
                            return true;
                        }
                        if (formSubElJSON != "") {
                            optionNameArr = optionValueArr = [];
                            jQuery(formSubElJSON).each(function(opts) {
                                var optionLbl = formSubElJSON[opts].label;
                                var optionVal = formSubElJSON[opts].value;
                                if (optionLbl.length > 30 || optionVal.length > 30) {
                                    err = true;
                                    return true;
                                }
                                if (!/^[a-z](?:-?[a-z0-9]+)*$/i.test(optionVal)) {
                                    err = true;
                                    return true;
                                }
                                if (optionNameArr.indexOf(optionLbl) > -1 || optionValueArr.indexOf(optionVal) > -1) {
                                    err = true;
                                    return true;
                                } else {
                                    optionNameArr.push(optionLbl);
                                    optionValueArr.push(optionVal);
                                }
                            });
                        }
                    }
                });
                return err;
            },
            hasDataValidationIssues: function(mCmpId, showFormErr) {
                var me = this;
                var elCpId = document.getElementById(mCmpId);
                Global.allFormElObjects = this.removeDuplicateObjectInArr(mCmpId, Global.allFormElObjects);
                var validateRes = Global.allFormElObjects.map(function(val, i) {
                    if (me.applyValidations) {
                        return me.validateField(mCmpId + "~noerr", val.elName, val.elVal, val.validator, "protected", val.type, false);
                    }
                });
                var err = false;
                if (this.applyValidations) {
                    for (var i = 0; i < validateRes.length; i++) {
                        if (validateRes[i] != "") {
                            err = true;
                            break;
                        }
                    }
                }
                document.getElementById(mCmpId).getElementsByClassName("common_errorMsg")[0].className = "common_errorMsg no-error-message";
                document.getElementById(mCmpId).getElementsByClassName("common_errorMsg")[0].innerHTML = "";
                if (showFormErr) {
                    var isShowErrMsg = $(elCpId).find("#isShowErrMsg").val();
                    if (err && isShowErrMsg == "true") {
                        document.getElementById(mCmpId).getElementsByClassName("common_errorMsg")[0].className = "common_errorMsg error-message";
                        document.getElementById(mCmpId).getElementsByClassName("common_errorMsg")[0].innerHTML = "The Form has Validation Errors";
                    }
                }
                return err;
            },
            validateForm: function(mode, cmpId, initiallyStartup, errFldClr) {
                this.formMode = mode;
                var me = this;
                this.initiallyStartup = initiallyStartup;
                Global.formErrFlds = [];
                var formData = {};
                Global.allFormElObjects = this.removeDuplicateObjectInArr(cmpId, Global.allFormElObjects);
                var elmCmpId = document.getElementById(cmpId);
                var validateRes = Global.allFormElObjects.map(function(val) {
                    if ($("[name='" + val.elName + "']").parents(".formInfomation").attr("name") == "TMFormSectionContainer") {
                        if (val.type == "radio" || val.type == "checkbox" || val.type == "scheckbox") {
                            var elField = $(elmCmpId).find("[name='" + val.elName + "']");
                            var checkedVal = [];
                            for (var i = 0; i < elField.length; i++) {
                                if (elField[i].checked) {
                                    if (val.type == "radio") {
                                        var checkedVal = elField[i].value;
                                    } else {
                                        checkedVal.push(elField[i].value);
                                    }
                                }
                            }
                            formData[val.elName] = checkedVal;
                        } else {
                            val.elVal = $(elmCmpId).find("[name='" + val.elName + "']").val();
                            formData[val.elName] = val.elVal;
                        }
                    }
                    if (me.applyValidations) {
                        var returnValidateFieldErr = "";
                        if (typeof val.validator != "undefined") {
                            returnValidateFieldErr = me.validateField(cmpId, val.elName, val.elVal, val.validator, mode, val.type, false);
                            if (returnValidateFieldErr != "") {
                                Global.formErrFlds.push(val.elName);
                                if (errFldClr == "show") {} else if (errFldClr == "hide") {
                                    document.getElementById(cmpId).getElementsByClassName(val.elName + "_errorMsg")[0].innerHTML = "";
                                    $(elmCmpId).find("[name='" + val.elName + "']").css({
                                        border: ""
                                    });
                                }
                            }
                        }
                        return returnValidateFieldErr;
                    }
                });
                var validationPass = true;
                if (this.applyValidations) {
                    for (var i = 0; i < validateRes.length; i++) {
                        if (validateRes[i] != "") {
                            validationPass = false;
                            break;
                        }
                    }
                }
                if (!validationPass) {
                    var isShowErrMsg = $(elmCmpId).find("#isShowErrMsg").val();
                    if (isShowErrMsg == "true") {
                        if (this.formMode != "edit") {
                            document.getElementById(cmpId).getElementsByClassName("common_errorMsg")[0].className = "common_errorMsg error-message";
                            document.getElementById(cmpId).getElementsByClassName("common_errorMsg")[0].innerHTML = "The Form has Validation Errors";
                        }
                        if (this.formMode == "read") $(elmCmpId).find(".preview-error-field-link").show(); else $(elmCmpId).find(".preview-error-field-link").hide();
                    } else {
                        $(elmCmpId).find(".preview-error-field-link").hide();
                    }
                } else {
                    $(elmCmpId).find(".preview-error-field-link").hide();
                    if (this.applyValidations) {
                        document.getElementById(cmpId).getElementsByClassName("common_errorMsg")[0].className = "common_errorMsg no-error-message";
                        document.getElementById(cmpId).getElementsByClassName("common_errorMsg")[0].innerHTML = "";
                    }
                }
                if (this.formMode == "edit") {
                    document.getElementById(cmpId).getElementsByClassName("common_errorMsg")[0].innerHTML = "";
                }
                return JSON.stringify(formData);
            },
            validateField: function(cmpId, name, value, vTypes, formModeVal, inputType, chkAllFld) {
                var me = this;
                cmpIdArr = cmpId.split("~");
                cmpId = cmpIdArr[0];
                var noErr = cmpIdArr[1] ? false : true;
                value = typeof value != "undefined" ? value.trim() : "";
                me.err = "";
                var elmCmpId = document.getElementById(cmpId);
                if (typeof vTypes != "undefined") {
                    Object.keys(vTypes).forEach(function(key) {
                        switch (key) {
                          case "isRequired":
                            if (vTypes[key]) {
                                var elField = $(elmCmpId).find("[name='" + name + "']");
                                if (inputType == "radio" || inputType == "checkbox" || inputType == "scheckbox") {
                                    var c = -1;
                                    for (var i = 0; i < elField.length; i++) {
                                        if (elField[i].checked) {
                                            c = i;
                                        }
                                    }
                                    if (inputType == "radio") {
                                        var eMsg = "You must choose an action.";
                                    } else {
                                        var eMsg = "You must choose an option.";
                                    }
                                    if (c == -1) me.err = eMsg;
                                } else {
                                    if (value == "") {
                                        if ($("[name='" + name + "']").hasClass("hasDatepicker")) {
                                            me.err = "You must select Date.";
                                        } else {
                                            me.err = "Field should not be empty.";
                                        }
                                    }
                                }
                            }
                            break;

                          case "minLength":
                            if (value != "" && value.length < vTypes[key]) {
                                if (me.err == "") me.err = "Field should not have less than " + vTypes[key] + " characters";
                            }
                            break;

                          case "maxLength":
                            if (value != "" && value.length > vTypes[key]) {
                                if (me.err == "") me.err = "Field should not have greater than " + vTypes[key] + " characters";
                            }
                            break;

                          case "email":
                            if (value != "") {
                                if (vTypes[key]) {
                                    var pattern = /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,5})+$/;
                                    if (!pattern.test(value)) {
                                        if (me.err == "") me.err = "Invalid email address";
                                    }
                                }
                            }
                            break;

                          case "isNumeric":
                            if (value != "") {
                                if (vTypes[key]) {
                                    var letters = /^[0-9., ]+$/;
                                    if (!value.match(letters)) {
                                        if (me.err == "") me.err = "Numeric characters only";
                                    }
                                }
                            }
                            break;

                          case "isAlpha":
                            if (value != "") {
                                if (vTypes[key]) {
                                    var letters = /^[A-Za-z ]+$/;
                                    if (!value.match(letters)) {
                                        if (me.err == "") me.err = "Alpha characters only";
                                    }
                                }
                            }
                            break;

                          case "isAlphaNumeric":
                            if (value != "") {
                                if (vTypes[key]) {
                                    var letters = /^[0-9a-zA-Z ]+$/;
                                    if (!value.match(letters)) {
                                        if (me.err == "") me.err = "Alphanumeric characters only";
                                    }
                                }
                            }
                            break;
                        }
                        if (!me.initiallyStartup) {
                            if (noErr && cmpId && formModeVal != "edit") {
                                document.getElementById(cmpId).getElementsByClassName(name + "_errorMsg")[0].innerHTML = me.err;
                                if (me.err) {
                                    $(elmCmpId).find("[name='" + name + "']").css({
                                        border: "solid 1px red"
                                    });
                                } else {
                                    $(elmCmpId).find("[name='" + name + "']").css({
                                        border: ""
                                    });
                                }
                            }
                        }
                    });
                    if (me.err == "") {
                        Global.formErrFlds.indexOf(name) >= 0 ? Global.formErrFlds.splice(Global.formErrFlds.indexOf(name), 1) : "";
                    } else {
                        chkAllFld === true && Global.formErrFlds.indexOf(name) < 0 ? Global.formErrFlds.push(name) : "";
                    }
                }
                if (Global.formErrFlds.length > 0 && formModeVal == "protected") {
                    document.getElementById(cmpId).getElementsByClassName("common_errorMsg")[0].className = "common_errorMsg error-message";
                    document.getElementById(cmpId).getElementsByClassName("common_errorMsg")[0].innerHTML = "The Form has Validation Errors";
                } else {
                    document.getElementById(cmpId).getElementsByClassName("common_errorMsg")[0].className = "common_errorMsg no-error-message";
                    document.getElementById(cmpId).getElementsByClassName("common_errorMsg")[0].innerHTML = "";
                }
                return me.err;
            },
            importChoiceClick: function(e) {
                var me = this;
                Global.callMe("open");
                e.preventDefault();
                var fldName = $("#changeableFieldName").val();
                var ccD = document.getElementById(cmpId);
                dataJson = $(ccD).find("[name='" + fldName + "']").parents(".handle-sortable").find(".form-element-box").attr("data-json");
                var dataJson = dataJson ? jQuery.parseJSON(dataJson) : "";
                $("#import-dialog-popup").dialog({
                    modal: true,
                    width: 710,
                    height: 470,
                    title: "Manage Choice Dialog Box",
                    buttons: [ {
                        text: "Validate",
                        name: "btnValidate",
                        click: function() {
                            var optionElObj = new Object();
                            var optionElRecursiveObj = new Object();
                            var existOptionElObj = new Object();
                            var existOptionElRecursiveObj = new Object();
                            var csvText = $("#option-csv-area").val();
                            csvText = csvText.trim();
                            if (csvText != "") {
                                var optionArr = [];
                                var lastOptionName = lastOptionVal = "";
                                var prevOptLen = 0;
                                optionArr = csvText.split(/\n/);
                                dataJson.elements.map(function(optionChoice) {
                                    existOptionElObj[optionChoice.label] = optionChoice.value;
                                    existOptionElRecursiveObj[optionChoice.value] = optionChoice.label;
                                });
                                var hasChoiceError = tolOptLen = false;
                                var seperatedErrLines = uniqueOptNamErrLines = uniqueOptValErrLines = lengthOptNamErrLines = lengthOptValErrLines = invalidOptValErrLines = systemGeneratedOptValErrLines = systemGeneratedOptNamErrLines = "";
                                $(".lineno").removeClass("lineselect");
                                var optionArrLen = optionArr.length;
                                if (optionArrLen > 100) {
                                    hasChoiceError = true;
                                    tolOptLen = true;
                                } else {
                                    var elOptions = optionArr.map(function(val, index) {
                                        var addIndex = index + 1;
                                        if (val.indexOf(",") > -1 || val.indexOf("\t") > -1) {
                                            $(".lineno-" + addIndex).removeClass("lineselect");
                                            if (val.indexOf(",") > -1) {
                                                var option = val.split(",");
                                            } else if (val.indexOf("\t") > -1) {
                                                var option = val.split("\t");
                                            }
                                            var optNam = option[0].trim();
                                            var optVal = option[1].trim();
                                            if (typeof optNam != "undefined" && typeof optVal != "undefined") {
                                                if (optNam.length > 30) {
                                                    lengthOptNamErrLines = lengthOptNamErrLines + "," + addIndex;
                                                    hasChoiceError = true;
                                                    $(".lineno-" + addIndex).addClass("lineselect");
                                                }
                                                if (optVal.length > 30) {
                                                    lengthOptValErrLines = lengthOptValErrLines + "," + addIndex;
                                                    hasChoiceError = true;
                                                    $(".lineno-" + addIndex).addClass("lineselect");
                                                }
                                                if (!/^[a-z](?:-?[a-z0-9]+)*$/i.test(optVal)) {
                                                    invalidOptValErrLines = invalidOptValErrLines + "," + addIndex;
                                                    hasChoiceError = true;
                                                    $(".lineno-" + addIndex).addClass("lineselect");
                                                }
                                                if (typeof existOptionElObj[optNam] == "undefined") {
                                                    if (/\boption\-/i.test(optNam)) {
                                                        systemGeneratedOptNamErrLines = systemGeneratedOptNamErrLines + "," + addIndex;
                                                        hasChoiceError = true;
                                                        $(".lineno-" + addIndex).addClass("lineselect");
                                                    }
                                                }
                                                if (typeof existOptionElRecursiveObj[optVal] == "undefined") {
                                                    if (/\boption-value\-/i.test(optVal)) {
                                                        systemGeneratedOptValErrLines = systemGeneratedOptValErrLines + "," + addIndex;
                                                        hasChoiceError = true;
                                                        $(".lineno-" + addIndex).addClass("lineselect");
                                                    }
                                                }
                                                if (typeof optionElObj[optNam] == "undefined") {
                                                    optionElObj[optNam] = optVal;
                                                } else {
                                                    uniqueOptNamErrLines = uniqueOptNamErrLines + "," + addIndex;
                                                    hasChoiceError = true;
                                                    $(".lineno-" + addIndex).addClass("lineselect");
                                                }
                                                if (typeof optionElRecursiveObj[optVal] == "undefined") {
                                                    optionElRecursiveObj[optVal] = optNam;
                                                } else {
                                                    uniqueOptValErrLines = uniqueOptValErrLines + "," + addIndex;
                                                    hasChoiceError = true;
                                                    $(".lineno-" + addIndex).addClass("lineselect");
                                                }
                                            }
                                        } else {
                                            seperatedErrLines = seperatedErrLines + "," + addIndex;
                                            hasChoiceError = true;
                                            $(".lineno-" + addIndex).addClass("lineselect");
                                        }
                                    });
                                }
                                if (hasChoiceError) {
                                    $(".err-import-choice").removeClass("no-error-message");
                                    var shrErr = "<div>";
                                    if (seperatedErrLines != "") {
                                        seperatedErrLines = seperatedErrLines.substr(1);
                                        shrErr = shrErr + " separated by `,` or `tab` on line(" + seperatedErrLines + ").";
                                    }
                                    if (invalidOptValErrLines != "") {
                                        invalidOptValErrLines = invalidOptValErrLines.substr(1);
                                        shrErr = shrErr + "<br />Invalid option-value on line(" + invalidOptValErrLines + ").";
                                    }
                                    if (systemGeneratedOptNamErrLines != "") {
                                        systemGeneratedOptNamErrLines = systemGeneratedOptNamErrLines.substr(1);
                                        shrErr = shrErr + "<br />Only the system can create option names with the form of option-*, on line(" + systemGeneratedOptNamErrLines + ").";
                                    }
                                    if (systemGeneratedOptValErrLines != "") {
                                        systemGeneratedOptValErrLines = systemGeneratedOptValErrLines.substr(1);
                                        shrErr = shrErr + "<br />Only the system can create option value with the form of option-value-*, on line(" + systemGeneratedOptValErrLines + ").";
                                    }
                                    if (lengthOptNamErrLines != "") {
                                        lengthOptNamErrLines = lengthOptNamErrLines.substr(1);
                                        shrErr = shrErr + "<br />option-display-name length should not greater than 30 on line(" + lengthOptNamErrLines + ").";
                                    }
                                    if (lengthOptValErrLines != "") {
                                        lengthOptValErrLines = lengthOptValErrLines.substr(1);
                                        shrErr = shrErr + "<br />option-value length should not greater than 30 on line(" + lengthOptValErrLines + ").";
                                    }
                                    if (uniqueOptNamErrLines != "") {
                                        uniqueOptNamErrLines = uniqueOptNamErrLines.substr(1);
                                        shrErr = shrErr + "<br />Uniqueness on option-display-name on line(" + uniqueOptNamErrLines + ").";
                                    }
                                    if (uniqueOptValErrLines != "") {
                                        uniqueOptValErrLines = uniqueOptValErrLines.substr(1);
                                        shrErr = shrErr + "<br />Uniqueness on option-value on line(" + uniqueOptValErrLines + ").";
                                    }
                                    if (tolOptLen) {
                                        shrErr = shrErr + "Only 100 options are supported";
                                    }
                                    shrErr = shrErr + "</div>";
                                    $(".err-import-choice").html(shrErr);
                                    if ($("#import-dialog-popup").parent(".ui-dialog").height() < 460) {
                                        var newDialogHeight = $("#import-dialog-popup").parent(".ui-dialog").height() + ($(".err-import-choice").height() + 10);
                                        $("#import-dialog-popup").dialog({
                                            height: newDialogHeight
                                        });
                                    }
                                    $(".ui-dialog-buttonpane button:contains('Ok')").button("disable");
                                } else {
                                    if ($("#import-dialog-popup").parent(".ui-dialog").height() > 460) {
                                        var newDialogHeight = $("#import-dialog-popup").parent(".ui-dialog").height() - ($(".err-import-choice").height() - 20);
                                        $("#import-dialog-popup").dialog({
                                            height: newDialogHeight
                                        });
                                    }
                                    $(".err-import-choice").html("There is no validation error.");
                                    $(".err-import-choice").addClass("no-error-message");
                                    $(".ui-dialog-buttonpane button:contains('Ok')").button("enable");
                                }
                            } else {
                                me.alertBox("Error", "Please insert choices in csv format.");
                            }
                        }
                    }, {
                        text: "Ok",
                        name: "btnOk",
                        click: function() {
                            var _this = this;
                            $(".ui-dialog-buttonpane button:contains('Ok')").button("disable");
                            $("[name=btnOk]").find("span").html("loading...");
                            setTimeout(function() {
                                if ($("#option-csv-area").val() != "") {
                                    var lastOptionName = lastOptionVal = "";
                                    var csvText = $("#option-csv-area").val();
                                    var optionArr = csvText.split(/\n/);
                                    var optionElObj = {};
                                    var optionElRecursiveObj = {};
                                    var maxId = 0;
                                    var incrementalUniqueNumber = dataJson.maxOptionNumber;
                                    dataJson.elements = [];
                                    var tolChoices = $("[name='" + dataJson.name + "']").find("option");
                                    if (tolChoices.length == 0) {
                                        $(ccD).find("[name='" + dataJson.name + "']").parents(".form-field").find("label").hide();
                                        $(ccD).find("[name='" + dataJson.name + "']").parents(".form-field").find("label span").removeAttr("class value name");
                                        $(ccD).find("[name='" + dataJson.name + "']").parents(".form-field").find("label").removeAttr("class value name");
                                        $(ccD).find("[name='" + dataJson.name + "']").parents(".form-field").find("input").removeAttr("class value checked");
                                    } else {
                                        $(ccD).find("[name='" + dataJson.name + "']").find("option").remove();
                                    }
                                    var defaultValExist = false;
                                    var defaultValue = "";
                                    var elOptions = optionArr.map(function(val) {
                                        if (val.indexOf(",") > -1 || val.indexOf("\t") > -1) {
                                            if (val.indexOf(",") > -1) {
                                                var option = val.split(",");
                                            } else if (val.indexOf("\t") > -1) {
                                                var option = val.split("\t");
                                            }
                                            if (typeof option[0] != "undefined" && typeof option[1] != "undefined") {
                                                if (typeof optionElObj[option[0].trim()] == "undefined" && typeof optionElRecursiveObj[option[1].trim()] == "undefined") {
                                                    if (dataJson.value == option[1].trim()) {
                                                        defaultValExist = true;
                                                    }
                                                    if (defaultValue == "") {
                                                        defaultValue = option[1].trim();
                                                    }
                                                    dataJson.elements.push({
                                                        label: option[0].trim(),
                                                        value: option[1].trim()
                                                    });
                                                    optionElObj[option[0].trim()] = option[1].trim();
                                                    optionElRecursiveObj[option[1].trim()] = option[0].trim();
                                                    me.setFormSectionJSON("OptionValueToolBoxPropAddElement", dataJson, "choice");
                                                }
                                            }
                                        }
                                    });
                                    if (dataJson.etype != "checkbox") {
                                        if (!defaultValExist) dataJson.value = defaultValue;
                                        if ($("[name='" + dataJson.name + "']").parents(".form-field").find("label:visible").find("input[type='radio']:checked").length <= 0) {
                                            if (dataJson.etype == "radio") {
                                                $("[name='" + dataJson.name + "-0']").parent("label").find("input").prop("checked", true);
                                            }
                                        }
                                    }
                                    maxId = parseInt(dataJson.elements.length) < parseInt(incrementalUniqueNumber) ? incrementalUniqueNumber : dataJson.elements.length;
                                    dataJson.maxOptionNumber = parseInt(maxId) + 1;
                                    $(ccD).find("[name='" + dataJson.name + "']").parents(".handle-sortable").find(".form-element-box").attr("data-json", JSON.stringify(dataJson));
                                    ReactDOM.render(React.createElement(FieldAttributesElements, {
                                        fieldProp: true,
                                        cmpId: cmpId,
                                        dataJson: JSON.stringify(dataJson),
                                        formMode: "edit",
                                        formInfo: formInfo
                                    }), document.getElementById("tabs-content-panel-1"));
                                    $("[name=btnOk]").find("span").html("Ok");
                                    Global.callMe("close");
                                    $(_this).dialog("close");
                                } else {
                                    $("[name=btnOk]").find("span").html("Ok");
                                    $(".ui-dialog-buttonpane button:contains('Ok')").button("enable");
                                    me.alertBox("Error", "Please insert choices in csv format.");
                                }
                            }, 100);
                        }
                    } ],
                    open: function() {
                        $(".ui-dialog-buttonpane button:contains('Ok')").button("disable");
                    },
                    close: function(ev, ui) {
                        Global.callMe("close");
                        $(this).dialog("destroy");
                        $("#import-dialog-popup").html("");
                    }
                });
                var dialogHtml = "";
                dataJson.elements.map(function(optionChoice) {
                    dialogHtml = dialogHtml + optionChoice.label + ", " + optionChoice.value + "\n";
                });
                var previewDialogNote = "<div class='preview-note'><b>Note:</b> One can add tab-delimited or comma-delimited.</div><div class='choice-header-preview'>Ex. option-display-name, option-value</div><div class='clear'></div>";
                var errChoice = "<div class='err-import-choice'></div>";
                $("#import-dialog-popup").html(previewDialogNote + '<textarea class="lined" id="option-csv-area" name="option-csv-area" style="width:97%; height: 260px;">' + dialogHtml + "</textarea>" + errChoice);
                $("#import-dialog-popup").dialog("option", "position", "center");
                $("#option-csv-area").css({
                    "font-size": 14
                });
                $("#option-csv-area").focus();
                $(".lined").linedtextarea();
            }
        };
        module.exports = CommonMixin;
        var FormPanel = require("./FormPanel");
    }, {
        "./FormPanel": 9,
        "./Global": 10,
        react: "react",
        "react-dom": "react-dom"
    } ],
    5: [ function(require, module, exports) {
        var Popover = require("react-awesome-popover");
        var React = require("react");
        var ReactDOM = require("react-dom");
        var createReactClass = require("create-react-class");
        var Global = require("./Global");
        var CommonMixin = require("./CommonMixin");
        var DatePicker = createReactClass({
            mixins: [ CommonMixin ],
            getInitialState: function() {
                return {
                    userInput: "",
                    formModeVal: this.props.formModeVal
                };
            },
            componentDidMount: function() {
                var me = this;
                var mainIdEl = document.getElementById(this.props.cmpId);
                var elNam = this.props.elComponent.name;
                var obj = {
                    elName: this.props.elComponent.name,
                    elVal: ReactDOM.findDOMNode(this.refs[this.props.elComponent.name]).value,
                    validator: this.props.elComponent.validator
                };
                this.checkIfObjectExists(Global.allFormElObjects, this.props.elComponent.name, "", "");
                Global.allFormElObjects.push(obj);
                var selectedDateFormat = this.props.elComponent.dateFormat;
            },
            render: function() {
                var today = new Date();
                var dd = today.getDate();
                var mm = today.getMonth() + 1;
                var yyyy = today.getFullYear();
                if (dd < 10) {
                    dd = "0" + dd;
                }
                if (mm < 10) {
                    mm = "0" + mm;
                }
                var today = mm + "/" + dd + "/" + yyyy;
                this.props.elComponent.value = this.props.elComponent.value ? this.props.elComponent.value : "";
                var fieldValue = "";
                if (this.props.elData && typeof this.props.elData[this.props.elComponent.name] != "undefined") {
                    fieldValue = this.props.elData[this.props.elComponent.name];
                } else {
                    fieldValue = this.props.elComponent.value ? this.props.elComponent.value : "";
                }
                var diffDataCls = diffDataIconCls = diffData = "";
                var isDiff = false;
                if (this.props.elDiffData && typeof this.props.elDiffData[this.props.elComponent.name] != "undefined") {
                    isDiff = true;
                    diffDataIconCls = "modified-data-icon";
                    var diffValClass = this.props.elDiffData[this.props.elComponent.name];
                    var diffArr = diffValClass.split("~diff~");
                    diffData = diffArr[0];
                    diffDataCls = diffArr[1];
                }
                var hoverTitle = diffData == "" ? "No Value" : diffData;
                if (this.props.elComponent.label == "") {
                    var clsName = "hidden";
                } else {
                    var clsName = "";
                }
                if (this.state.formModeVal && (this.state.formModeVal == "edit" || this.state.formModeVal == "read") && this.props.elComponent.name != "valueToolBoxProp") var disabledSpanEl = React.createElement("span", {
                    className: "disabled-span"
                }); else var disabledSpanEl = React.createElement("span", {
                    className: "disabled-span",
                    style: {
                        width: "130px"
                    }
                });
                return React.createElement("div", {
                    className: diffDataCls + " form-element-box float-left " + this.props.elComponent.ctClsName,
                    "data-json": JSON.stringify(this.props.elComponent)
                }, React.createElement("div", {
                    className: clsName + " float-left form-field-label"
                }, React.createElement("label", {
                    name: this.props.elComponent.name + "-label",
                    className: "r-form-el-label " + (this.props.clsName ? this.props.clsName : ""),
                    style: this.props.elComponent.labelStyle
                }, React.createElement("span", null, this.props.elComponent.label), React.createElement("b", null, ":"), React.createElement("span", {
                    className: "required-sign"
                }, this.props.elComponent.validator ? this.props.elComponent.validator.isRequired ? "*" : "" : ""))), React.createElement("div", {
                    className: "float-left form-field"
                }, disabledSpanEl, React.createElement("input", {
                    id: this.props.elComponent.id,
                    type: "text",
                    className: "r-form-text " + (this.props.elComponent.clsName ? this.props.elComponent.clsName : ""),
                    style: this.props.elComponent.style ? this.props.elComponent.style : {},
                    ref: this.props.elComponent.name,
                    name: this.props.elComponent.name,
                    placeholder: this.props.elComponent.placeHolder,
                    readOnly: true,
                    defaultValue: fieldValue,
                    onChange: this.onChange,
                    onBlur: this.onBlur,
                    onClick: this.onChange
                }), React.createElement("br", null), React.createElement("div", {
                    name: this.props.elComponent.name + "_errorMsg",
                    className: this.props.elComponent.name + "_errorMsg error-message"
                })), React.createElement("span", {
                    className: diffDataIconCls,
                    alt: diffData,
                    title: diffData
                }));
            }
        });
        module.exports = DatePicker;
    }, {
        "./CommonMixin": 4,
        "./Global": 10,
        "create-react-class": 19,
        react: "react",
        "react-awesome-popover": 27,
        "react-dom": "react-dom"
    } ],
    6: [ function(require, module, exports) {
        var React = require("react");
        var ReactDOM = require("react-dom");
        var createReactClass = require("create-react-class");
        var Global = require("./Global");
        var CommonMixin = require("./CommonMixin");
        var Divider = createReactClass({
            mixins: [ CommonMixin ],
            getInitialState: function() {
                return {
                    userInput: "",
                    formModeVal: this.props.formModeVal
                };
            },
            componentDidMount: function() {
                var me = this;
                var mainIdEl = document.getElementById(this.props.cmpId);
                var elNam = this.props.elComponent.name;
                var obj = {
                    elName: this.props.elComponent.name,
                    elVal: ReactDOM.findDOMNode(this.refs[this.props.elComponent.name]).value,
                    validator: this.props.elComponent.validator
                };
                this.checkIfObjectExists(Global.allFormElObjects, this.props.elComponent.name, "", "");
                Global.allFormElObjects.push(obj);
                var selectedDateFormat = this.props.elComponent.dateFormat;
            },
            render: function() {
                var fieldValue = "";
                if (this.props.elData && typeof this.props.elData[this.props.elComponent.name] != "undefined") {
                    fieldValue = this.props.elData[this.props.elComponent.name];
                } else {
                    fieldValue = this.props.elComponent.value ? this.props.elComponent.value : "";
                }
                return React.createElement("div", {
                    className: "form-element-box float-left " + this.props.elComponent.ctClsName,
                    "data-json": JSON.stringify(this.props.elComponent)
                }, React.createElement("div", {
                    className: "float-left form-field form-field-divider"
                }, React.createElement("hr", {
                    id: this.props.elComponent.id,
                    className: "r-form-divider " + (this.props.elComponent.clsName ? this.props.elComponent.clsName : ""),
                    style: this.props.elComponent.style ? this.props.elComponent.style : {},
                    ref: this.props.elComponent.name,
                    name: this.props.elComponent.name
                }), React.createElement("input", {
                    type: "hidden",
                    name: this.props.elComponent.name
                })));
            }
        });
        module.exports = Divider;
    }, {
        "./CommonMixin": 4,
        "./Global": 10,
        "create-react-class": 19,
        react: "react",
        "react-dom": "react-dom"
    } ],
    7: [ function(require, module, exports) {
        var Popover = require("react-awesome-popover");
        var React = require("react");
        var ReactDOM = require("react-dom");
        var createReactClass = require("create-react-class");
        var Global = require("./Global");
        var CommonMixin = require("./CommonMixin");
        var DropDown = createReactClass({
            mixins: [ CommonMixin ],
            getInitialState: function() {
                return {
                    userInput: "",
                    formModeVal: this.props.formModeVal
                };
            },
            componentDidMount: function() {
                var obj = {
                    elName: this.props.elComponent.name,
                    elVal: ReactDOM.findDOMNode(this.refs[this.props.elComponent.name]).value,
                    validator: this.props.elComponent.validator
                };
                this.checkIfObjectExists(Global.allFormElObjects, this.props.elComponent.name, "", "");
                Global.allFormElObjects.push(obj);
            },
            render: function() {
                var me = this;
                var fieldValue = "";
                if (this.props.elData && typeof this.props.elData[this.props.elComponent.name] != "undefined") {
                    fieldValue = this.props.elData[this.props.elComponent.name];
                } else {
                    fieldValue = this.props.elComponent.value ? this.props.elComponent.value : "";
                }
                var diffDataCls = diffDataIconCls = diffData = "";
                var isDiff = false;
                if (this.props.elDiffData && typeof this.props.elDiffData[this.props.elComponent.name] != "undefined") {
                    isDiff = true;
                    diffDataIconCls = "modified-data-icon";
                    var diffValClass = this.props.elDiffData[this.props.elComponent.name];
                    var diffArr = diffValClass.split("~diff~");
                    diffData = diffArr[0];
                    diffDataCls = diffArr[1];
                }
                if (this.state.userInput != "") fieldValue = this.state.userInput;
                var dropDownItems = this.props.elComponent.elements.map(function(val, index) {
                    if (diffData == val.value) diffData = val.label;
                    return React.createElement("option", {
                        name: me.props.elComponent.name + "-" + index,
                        key: Math.random(),
                        value: val.value
                    }, val.label);
                });
                var hoverTitle = diffData == "" ? "No Value" : diffData;
                if (this.props.elComponent.label == "") {
                    var clsName = "hidden";
                } else {
                    var clsName = "";
                }
                this.props.elComponent.maxOptionNumber = this.props.elComponent.maxOptionNumber ? this.props.elComponent.maxOptionNumber : this.props.elComponent.elements.length;
                return React.createElement("div", {
                    className: diffDataCls + " form-element-box float-left " + this.props.elComponent.ctClsName,
                    "data-json": JSON.stringify(this.props.elComponent)
                }, React.createElement("div", {
                    className: clsName + " float-left form-field-label"
                }, React.createElement("label", {
                    name: this.props.elComponent.name + "-label",
                    className: "r-form-el-label " + (this.props.clsName ? this.props.clsName : ""),
                    style: this.props.elComponent.labelStyle
                }, React.createElement("span", null, this.props.elComponent.label), React.createElement("b", null, ":"), React.createElement("span", {
                    className: "required-sign"
                }, this.props.elComponent.validator ? this.props.elComponent.validator.isRequired ? "*" : "" : ""))), React.createElement("div", {
                    className: "float-left form-field"
                }, React.createElement("select", {
                    defaultValue: fieldValue,
                    id: this.props.elComponent.id,
                    type: "dropdown",
                    className: "r-form-drop-down " + (this.props.elComponent.clsName ? this.props.elComponent.clsName : ""),
                    style: this.props.elComponent.style ? this.props.elComponent.style : {},
                    ref: this.props.elComponent.name,
                    name: this.props.elComponent.name,
                    onChange: this.onChange,
                    onBlur: this.onChange,
                    onClick: this.onChange
                }, dropDownItems), React.createElement("br", null), React.createElement("div", {
                    name: this.props.elComponent.name + "_errorMsg",
                    className: this.props.elComponent.name + "_errorMsg error-message"
                })), React.createElement("span", {
                    className: diffDataIconCls,
                    alt: diffData,
                    title: diffData
                }));
            }
        });
        module.exports = DropDown;
    }, {
        "./CommonMixin": 4,
        "./Global": 10,
        "create-react-class": 19,
        react: "react",
        "react-awesome-popover": 27,
        "react-dom": "react-dom"
    } ],
    8: [ function(require, module, exports) {
        var React = require("react");
        var createReactClass = require("create-react-class");
        var FieldSet = createReactClass({
            render: function() {
                return React.createElement("fieldset", {
                    style: this.props.style,
                    className: "r-fieldset " + (this.props.clsName ? this.props.clsName : "")
                }, React.createElement("legend", {
                    style: this.props.style ? {
                        display: "none"
                    } : {}
                }, this.props.title, ":"), React.createElement("div", {
                    className: "sortable"
                }, this.props.innerElements));
            }
        });
        module.exports = FieldSet;
    }, {
        "create-react-class": 19,
        react: "react"
    } ],
    9: [ function(require, module, exports) {
        var React = require("react");
        var ReactDOM = require("react-dom");
        var createReactClass = require("create-react-class");
        var PerfectScrollbar = require("perfect-scrollbar");
        var Global = require("./Global");
        var CommonMixin = require("./CommonMixin");
        var FormPanel = createReactClass({
            mixins: [ CommonMixin ],
            getInitialState: function() {
                Global.callMe = Global.callMe != "" ? Global.callMe : this.props.callMe;
                return {
                    activeTabId: 0,
                    dataJson: {}
                };
            },
            bindEditFunctions: function() {
                var me = this;
                var fInfo = this.props.formInfo;
                var previousFormId = this.props.cmpId;
                var fFormMode = this.props.formMode;
                var $ = jQuery;
                var elmCmpId = document.getElementById(this.props.cmpId);
                var elmPrevCmpId = document.getElementById(previousFormId);
                if (typeof $(".react-form-section-class").attr("id") == "undefined") $(elmCmpId).addClass("react-form-section-class");
                var lblWdth = this.props.formInfo.formStructure.frmlabelWidth;
                $(elmPrevCmpId).find("[name='TMFormSectionContainer']").find("label.r-form-el-label").css({
                    width: lblWdth
                });
                $("[name='" + this.props.formInfo.formStructure.name + "']").submit(function(e) {
                    e.preventDefault();
                    return false;
                });
                var mainIdEl = document.getElementById(Global.mainCmpId);
                jQuery(mainIdEl).css("backgroundColor", "#F3F3F3");
                jQuery(mainIdEl).find(".formInfomation .form-element-box").find(":text, textarea").css("color", "#666666");
                jQuery(mainIdEl).find(".formInfomation .form-element-box").find(":text, textarea").attr("readonly", "readonly");
                jQuery(mainIdEl).find(".formInfomation .form-element-box").find(":radio, :checkbox, button, select").attr("disabled", "disabled");
                jQuery(mainIdEl).find(".formInfomation .form-element-box").find(":radio, :checkbox, button, select").parents(".form-field").prepend("<span class='disabled-span'></span>");
                $(mainIdEl).find("[name='show_error_fields']").unbind("click");
                $(mainIdEl).find("[name='show_error_fields']").click(function(e) {
                    e.preventDefault();
                    var errFieldVisibility = $(mainIdEl).find(".preview-error-field-link").attr("rel");
                    me.validateForm(fFormMode, previousFormId, false, errFieldVisibility);
                    $(mainIdEl).find(".preview-error-field-link").attr("rel", errFieldVisibility == "show" ? "hide" : "show");
                    $(mainIdEl).find(".preview-error-field-link").html((errFieldVisibility == "hide" ? " - Show" : " - Hide") + " Error Fields");
                });
            },
            componentWillMount: function() {
                if ($("head style")[0].childNodes[0].textContent.indexOf("main-react-form-container") < 0) {
                    $("<style>").prop("type", "text/css").html('body{font-family:arial}.zeroPadding{padding:0!important}.form-element-box a{text-decoration:none}.main-react-form-container textarea{resize:none}#preview-mode-dialog{padding-right: 0!important}#preview-mode-dialog .perfect-scrollbar{}.float-left{float:left!important}.fr{float:right!important}.clear{clear:both}.hidden{display:none}.err-import-choice,.error-message{clear:both;color:red;margin-bottom:3px;float:left}.err-import-choice{font-size:12px;font-weight:700;margin-left:12px;margin-top:5px}.common_errorMsg{float:left}.no-error-message{color:#538135}.required-sign{color:red}.preview-error-field-link{float:left!important;margin-left:3px}.preview-error-field-link,.preview-mode-link{float:right;color:#488CC8;cursor:pointer;font-weight:700}.preview-error-field-link:hover,.preview-mode-link:hover{color:#000}.preview-note{color:red;font-size:12px;padding:5px 12px;float:left}.ui-widget-overlay{opacity:.5!important;filter:Alpha(Opacity=50)!important;background:#323232!important}.choice-header-preview{float:left;clear:both;margin:0 0 5px 12px;font-size:13px;font-weight:700}.ui-dialog #import-dialog-popup{padding:0;display:inline-block;width:700px!important}.main-react-form-container{color:#000;background:#F3F3F3;font-family:arial,tahoma,helvetica,sans-serif;font-size:12px;font-weight:400;display:inline-block;width:95%;height:auto;min-height:200px;}.main-react-form-container .formInfomation h2{padding-bottom:0;font-size:18px}.main-react-form-container .formInfomation p{font-size:12px}.main-react-form-container .el-container{float:left;padding:10px;margin-right:10px;display:inline-block;margin-bottom:10px;position:relative;width:96%}.handle-sortable{padding:10px;margin-right:10px;border:1px solid transparent;display:inline-block;margin-bottom:10px;width:96%;position:relative}.handle-sortable-hover{border:1px dashed #488CC8}.handle-sortable-selected{border:1px solid #488CC8;background-color:#EEE}.handle-area{background-image:url(/tm/common/react-tmail/form/img/arrow.png);background-repeat:no-repeat;cursor:move;width:5%;height:16px;float:left;margin:3px 10px 0 0}.remove-element{background-image:url(/tm/common/react-tmail/form/img/delete.png);background-repeat:no-repeat;cursor:pointer;width:16px;height:16px;float:left;position:absolute;right:15px;top:-7px;display:none}.main-react-form-container .r-information-label{color:#000;font-family:arial,tahoma,helvetica,sans-serif;font-size:12px;font-weight:400;display:inline-block;width:100%;white-space:pre-line;word-wrap:break-word;}.main-react-form-container .r-form-el-label{display:inline-block;float:left;padding:3px 3px 3px 0;position:relative;width:120px;word-wrap:break-word}.main-react-form-container .form-field-label{width:auto}.main-react-form-container .form-field{width:75%;position:relative}.main-react-form-container input.r-form-text{height:24px;width:100%;padding-left:5px}.main-react-form-container textarea.r-form-text-area{width:100%;padding-left:5px}.main-react-form-container select.r-form-drop-down{height:24px;width:100%}.main-react-form-container input.r-form-radio{margin-right:3px}.main-react-form-container .r-form-radio-label-box{margin-right:10px;display:inline-block}.main-react-form-container input.r-form-action-button{display:none;margin:10px}.main-react-form-container .r-form-action-button-label-box{display:block}.main-react-form-container input.r-form-action-button+.r-form-action-button-span{cursor:pointer;float:left;margin:-2px -2px 5px 2px;padding:4px 12px;border:1px solid #999;-webkit-box-shadow:1px 1px 1px 0 #000,0 2px 0 #000;-moz-box-shadow:1px 1px 1px 0 #000,0 2px 0 #000;box-shadow:1px 1px 1px 0 #000,0 2px 0 #000}.main-react-form-container input.r-form-action-button+.action-button-span-default-clr{background-color:#ADD8E6}.main-react-form-container input.r-form-action-button:checked+.r-form-action-button-span{cursor:auto;border:none;background-image:none;background-color:silver;color:#000;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.main-react-form-container input.r-form-action-button:checked+.r-form-action-button-span-edit-mode{border:1px solid #999;-webkit-box-shadow:1px 1px 1px 0 #000,0 2px 0 #000;-moz-box-shadow:1px 1px 1px 0 #000,0 2px 0 #000;box-shadow:1px 1px 1px 0 #000,0 2px 0 #000}.main-react-form-container .undo-action-icon{background-image:url(/tm/common/react-tmail/form/img/arrow-undo.png);background-repeat:no-repeat;cursor:pointer;height:32px;width:32px;margin:-6px 0 0 10px;float:left}.main-react-form-container input.r-form-check-box{margin-right:3px;margin-top:5px}.main-react-form-container .r-form-check-box-label-box{margin-right:10px;display:inline-block}.main-react-form-container .r-fieldset{display: table-row;border:1px solid #CCC;padding:10px;margin-bottom:10px;width:95%;position:relative}.main-react-form-container .r-fieldset legend{color:#111;font:700 11px tahoma,arial,helvetica,sans-serif}.main-react-form-container .r-form-divider{color:#EEE}#import-choice,#reset-choice,#show-more-choice{color:#488CC8;cursor:pointer;padding-bottom:10px}#import-choice:hover,#reset-choice:hover,#show-more-choice:hover{color:#000}#form-section-container-edit-toolbox{}#form-toolbox-container{}.tab-content-area{width:100%;display:inline-block}.margin-bottom{margin-bottom:10px}.margin-right{margin-right:10px}.main-react-form-container .formInfomation .form-element-box{float:left;width:90%}.choice-fieldset .form-element-box.choice-wrapper{width: 100%}.choice-fieldset .form-element-box,.main-react-form-container .choice-fieldset .form-field{width:auto}.main-react-form-container .choice-fieldset .form-element-box{margin:0}.main-react-form-container .choice-fieldset{height:200px;overflow:scroll}.form-element-box{float:left;width:100%}.edit-form-container{border-right: 1px solid #CCCCCC;width:55%;float:left;padding:10px;box-sizing: border-box;}.form-toolbox-container{width:42%;float:right;height:auto;padding:10px 0 0;box-sizing:border-box;}.form-toolbox-container .form-field{width:65%}.form-toolbox-label{text-align:center;margin-bottom:8px;font-size:13px;font-weight:700}#element-buttons-form-section ul{padding:0 0 0 15px;margin:0}#element-buttons-form-section ul li{width:90%;float:left;margin:0 0 15px 0;padding:0 0 0 30px;background-repeat:no-repeat;cursor:pointer;font-size:13px;font-weight:700;list-style-type:none}#element-buttons-form-section ul li.labelarea{background-image:url(/tm/common/react-tmail/form/img/label-area.png)}#element-buttons-form-section ul li.textbox{background-image:url(/tm/common/react-tmail/form/img/single-line-text-bg.png)}#element-buttons-form-section ul li.textarea{background-image:url(/tm/common/react-tmail/form/img/paragraph-text-bg.png)}#element-buttons-form-section ul li.radio{background-image:url(/tm/common/react-tmail/form/img/multiplechoice-bg.png)}#element-buttons-form-section ul li.checkbox,#element-buttons-form-section ul li.scheckbox{background-image:url(/tm/common/react-tmail/form/img/checkbox-bg.png)}#element-buttons-form-section ul li.dropdown{background-image:url(/tm/common/react-tmail/form/img/dropdown-bg.png)}#element-buttons-form-section ul li.actionbutton{background-image:url(/tm/common/react-tmail/form/img/actionbutton.png)}#element-buttons-form-section ul li.datepicker{background-image:url(/tm/common/react-tmail/form/img/calendar.png)}#element-buttons-form-section ul li.divider{background-image:url(/tm/common/react-tmail/form/img/divider.png);background-position:left center}.main-react-form-container .form-field-divider{width:98%}.choice-default-value{background-image:url(/tm/common/react-tmail/form/img/tick-off.png);background-repeat:no-repeat;cursor:pointer;float:right;height:16px;margin-left:3px;padding:0 2px;width:16px}.choice-default-value:hover{background-image:url(/tm/common/react-tmail/form/img/tick-on.png)}.choice-default-value-selected{background-image:url(/tm/common/react-tmail/form/img/tick-on.png)}.add-new-choice-icon{background-image:url(/tm/common/react-tmail/form/img/add.png);background-repeat:no-repeat;cursor:pointer;float:right;height:16px;padding:0 2px;width:16px}.delete-new-choice-icon{background-image:url(/tm/common/react-tmail/form/img/delete.png);background-repeat:no-repeat;cursor:pointer;float:right;height:16px;margin-left:3px;padding:0 2px;width:16px}.tabs-content-panel{display:none}.tabs-content-panel-selected{padding: 20px 15px 0 0;display:block}.tab{cursor:pointer;margin-right:5px;margin-bottom:5px;padding:5px 7px;display:inline-block;text-decoration:none;background:#CCC;color:#000}.tab-selected{padding:5px 7px;display:inline-block;background:#488CC8;color:#FFF;text-decoration:none}#tabs-content-panel-1 h2{font-size:18px;margin:0}.divider-css{padding:0!important;cursor:auto!important}.modified-data-ui{background-color:#FFC;position:relative;padding:10px 10px 8px}.set-data-ui{background-color:#CFC;position:relative;padding:10px}.unset-data-ui{background-color:#FCC;position:relative;padding:10px}.modified-data-icon{margin-left:3px;position:absolute;right:12px;top:2px}.modified-data-ui .modified-data-icon:before{content:"*";color:#BABA05;font-size:50px}.set-data-ui .modified-data-icon:before{content:"+";color:green;font-size:35px}.unset-data-ui .modified-data-icon:before{content:"x";color:red;position:absolute;right:0;top:4px;font-size:25px}.disabled-span{position:absolute;top:0;left:0;height:100%;width:100%;opacity:.01;filter:Alpha(Opacity=0);background:#EEE}div.colorPicker-picker{float:left;margin-right:10px;height:16px;width:16px;padding:0!important;border:1px solid #ccc;background:url(https://laktek.github.io/really-simple-color-picker/arrow.gif) top right no-repeat;cursor:pointer;line-height:16px;font-size:.75em;font-weight:700;text-align:center}div.colorPicker-palette{width:110px;position:absolute;border:1px solid #598FEF;background-color:#EFEFEF;padding:2px;z-index:9999}div.colorPicker_hexWrap{width:100%;float:left}div.colorPicker_hexWrap label{font-size:95%;color:#2F2F2F;margin:5px 2px;width:25%}div.colorPicker_hexWrap input{margin:5px 2px;padding:0;font-size:95%;border:1px solid #000;width:65%}div.colorPicker-swatch{height:12px;width:12px;border:1px solid #000;margin:2px;float:left;cursor:pointer;line-height:12px}.ui-datepicker-trigger{margin-left:5px}#ui-datepicker-div{font-size:.9em!important;z-index:9999!important}.ui-datepicker-header{cursor:move}.ui-datepicker-next,.ui-datepicker-prev{cursor:pointer}.ui-datepicker-close{display:none}.ui-datepicker .ui-datepicker-buttonpane button.ui-datepicker-current{float:right}.mobile-modified-data-icon {width:100%;height:100%;left:0;top:0;position:absolute}.set-data-ui .mobile-modified-data-icon{color:green}.unset-data-ui .mobile-modified-data-icon{color:red}.modified-data-ui .mobile-modified-data-icon{color:#baba05}.custom-popover-content{background: none repeat scroll 0 0 #FFFFFF;border-radius: 5px;box-shadow: 0 0 0 1px rgba(16, 22, 26, 0.1), 0 2px 4px rgba(16, 22, 26, 0.2), 0 8px 24px rgba(16, 22, 26, 0.2);width: 150px !important;height: auto;min-height: 15px;padding: 10px;z-index: 9;}.perfect-scrollbar{position: relative; height: calc(100vh - 135px); overflow: auto;}.perfect-scrollbar-edit{position: relative; height: calc(100vh - 155px); overflow: auto;}.ps__rail-x,.ps__rail-y{display:none;opacity:0;position:absolute}.ps{overflow:hidden!important;overflow-anchor:none;-ms-overflow-style:none;touch-action:auto;-ms-touch-action:auto}.ps__rail-x{transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;height:15px;bottom:0}.ps__rail-y{transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;width:15px;right:0}.ps--active-x>.ps__rail-x,.ps--active-y>.ps__rail-y{display:block;background-color:transparent}.ps--focus>.ps__rail-x,.ps--focus>.ps__rail-y,.ps--scrolling-x>.ps__rail-x,.ps--scrolling-y>.ps__rail-y,.ps:hover>.ps__rail-x,.ps:hover>.ps__rail-y{opacity:.6}.ps__rail-x:focus,.ps__rail-x:hover,.ps__rail-y:focus,.ps__rail-y:hover{background-color:#eee;opacity:.9}.ps__thumb-x,.ps__thumb-y{background-color:#aaa;border-radius:6px;position:absolute}.ps__thumb-x{transition:background-color .2s linear,height .2s ease-in-out;-webkit-transition:background-color .2s linear,height .2s ease-in-out;height:6px;bottom:2px}.ps__thumb-y{transition:background-color .2s linear,width .2s ease-in-out;-webkit-transition:background-color .2s linear,width .2s ease-in-out;width:6px;right:2px}.ps__rail-x:focus>.ps__thumb-x,.ps__rail-x:hover>.ps__thumb-x{background-color:#999;height:11px}.ps__rail-y:focus>.ps__thumb-y,.ps__rail-y:hover>.ps__thumb-y{background-color:#999;width:11px}@supports (-ms-overflow-style:none){.ps{overflow:auto!important}}@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none){.ps{overflow:auto!important}}').prependTo("head");
                }
            },
            componentDidMount: function() {
                var me = this;
                var mainIdEl = document.getElementById(Global.mainCmpId);
                var element = document.getElementsByClassName("perfect-scrollbar");
                if (typeof element != "undefined" && element != null && element.length > 0) {
                    var ps = new PerfectScrollbar(".perfect-scrollbar");
                    ps.update();
                }
                var d = new Date();
                Global.renderedAt = Global.mainCmpId + "~" + d.getFullYear() + d.getMonth() + d.getDay() + d.getHours() + d.getMinutes() + (d.getSeconds() + 3) + d.getMilliseconds();
                var renderedAtEl = document.getElementById(mainIdEl + "-renderedAt");
                if (typeof renderedAtEl != "undefined" && renderedAtEl != null) $(renderedAtEl).html(Global.renderedAt); else $(mainIdEl).append("<p class='hidden' id='" + Global.mainCmpId + "-renderedAt'>" + Global.renderedAt + "</p>");
                setTimeout(function() {
                    $("#form-toolbox-container").show();
                }, 1e3);
                var frmPropsCDM = me.props;
                this.bindEditFunctions();
                $("[name='field-1']").parents(".handle-sortable").addClass("handle-sortable-selected");
                this.initiallyStartup = true;
                if (this.props.formInfo.formStructure) {
                    this.applyValidations = this.props.formInfo.formStructure.applyValidations;
                    this.validateForm(this.props.formMode, this.props.cmpId, this.initiallyStartup, "");
                }
            },
            render: function() {
                var me = this;
                var allFormElObjects = [];
                var mainIdEl = document.getElementById(Global.mainCmpId);
                if ($(mainIdEl).find("[name='TMFormSectionContainer']").length > 0) {
                    var divFormInfo = jQuery.parseJSON($("[name='TMFormSectionContainer']").attr("data-json"));
                    this.props.formInfo.formStructure.frmlabelWidth = divFormInfo.frmlabelWidth;
                }
                var mainHtml = editFormMode = editFormCls = editFormToolBoxCls = "";
                var hidePrevMode = "hidden";
                if (this.props.formInfo.formStructure.etype == "form") {
                    var isShowErrMsg = this.props.isShowErrMsg ? this.props.isShowErrMsg : false;
                    var formMode = this.props.formMode;
                    this.formMode = this.props.formMode;
                    cmpId = this.props.cmpId;
                    Global.mainCmpId = this.props.cmpId;
                    var formData = this.props.formInfo.formData;
                    var formDiffData = this.props.formInfo.formDiffData ? this.props.formInfo.formDiffData : "";
                    var sortCls = removeCls = "";
                    var elContainerCls = "el-container";
                    var hideErrField = "hidden";
                    var elHtml = this.props.formInfo.formStructure.elements.map(function(val) {
                        if (val.labelStyle && val.labelStyle.fontSize != 12) {} else {
                            if (val.etype != "labelarea") {
                                if (val.labelStyle) {
                                    val.labelStyle.fontSize = me.props.formInfo.formStructure.style.fontSize;
                                } else {
                                    val.labelStyle = {
                                        fontSize: me.props.formInfo.formStructure.style.fontSize
                                    };
                                }
                            }
                        }
                        if (val.etype == "divider") var dvdrClass = "divider-un-clicked"; else var dvdrClass = "";
                        return React.createElement("div", {
                            className: elContainerCls + " " + dvdrClass,
                            key: Math.random()
                        }, React.createElement("div", {
                            className: sortCls
                        }), React.createElement(RenderAllComponentsRecursion, {
                            formModeVal: formMode,
                            cmpId: cmpId,
                            elStructure: val,
                            elData: formData,
                            elDiffData: formDiffData
                        }), React.createElement("div", {
                            className: removeCls
                        }));
                    });
                    elHtml = React.createElement(FieldSet, {
                        style: {
                            border: "none"
                        },
                        legStyle: {
                            display: "none"
                        },
                        innerElements: elHtml,
                        elMode: formMode
                    });
                    var frmSttyle = this.props.formInfo.formStructure.style ? this.props.formInfo.formStructure.style : {};
                    var frmDescStyle = {};
                    if (this.props.formInfo.formStructure.frmDescFontWeight) {
                        frmDescStyle.fontWeight = this.props.formInfo.formStructure.frmDescFontWeight;
                    }
                    if (this.props.formInfo.formStructure.frmDescFontStyle) {
                        frmDescStyle.fontStyle = this.props.formInfo.formStructure.frmDescFontStyle;
                    }
                    if (this.props.formInfo.formStructure.frmDescFontDecoration) {
                        frmDescStyle.textDecoration = this.props.formInfo.formStructure.frmDescFontDecoration;
                    }
                    if (this.props.formInfo.formStructure.frmDescFontAlign) {
                        frmDescStyle.textAlign = this.props.formInfo.formStructure.frmDescFontAlign;
                    }
                    var cloneFrmSttyle = JSON.parse(JSON.stringify(frmSttyle));
                    cloneFrmSttyle.fontSize ? delete cloneFrmSttyle.fontSize : "";
                    mainHtml = React.createElement("form", {
                        id: this.props.formInfo.formStructure.id,
                        style: cloneFrmSttyle,
                        name: this.props.formInfo.formStructure.name,
                        "data-mode": this.props.formInfo.infoToSubmit,
                        className: "formInfomation " + this.props.formInfo.formStructure.clsName,
                        "data-json": JSON.stringify(this.props.formInfo.formStructure)
                    }, React.createElement("h2", {
                        name: "formTitleToolBoxProp-h2"
                    }, this.props.formInfo.formStructure.frmTitle), React.createElement("p", {
                        style: frmDescStyle,
                        name: "formDescToolBoxProp-p"
                    }, this.props.formInfo.formStructure.frmDescription), React.createElement("input", {
                        type: "hidden",
                        name: "field-is-show-errrr-mssg",
                        id: "isShowErrMsg",
                        defaultValue: isShowErrMsg
                    }), React.createElement("input", {
                        type: "hidden",
                        name: "field-0",
                        id: "formJsonData",
                        defaultValue: ""
                    }), React.createElement("input", {
                        type: "hidden",
                        name: "no-field",
                        id: "changeableFieldName",
                        defaultValue: ""
                    }), React.createElement("div", {
                        name: "common_alert_popup",
                        className: "common_alert_popup"
                    }), React.createElement("div", {
                        className: "clear"
                    }), elHtml);
                }
                return React.createElement("div", {
                    style: {
                        backgroundColor: "F3F3F3"
                    },
                    className: editFormCls + " perfect-scrollbar"
                }, React.createElement("div", {
                    className: "main-react-form-container"
                }, React.createElement("div", {
                    className: "fr"
                }, React.createElement("div", {
                    name: "common_errorMsg",
                    className: "common_errorMsg error-message"
                }), React.createElement("a", {
                    name: "show_error_fields",
                    className: hideErrField + " preview-error-field-link",
                    rel: "show"
                }, " - Show Error Fields")), React.createElement("div", {
                    className: "clear"
                }), mainHtml));
            }
        });
        module.exports = FormPanel;
        var RenderAllComponentsRecursion = require("./RenderAllComponentsRecursion");
        var FieldSet = require("./FieldSet");
    }, {
        "./CommonMixin": 4,
        "./FieldSet": 8,
        "./Global": 10,
        "./RenderAllComponentsRecursion": 13,
        "create-react-class": 19,
        "perfect-scrollbar": 25,
        react: "react",
        "react-dom": "react-dom"
    } ],
    10: [ function(require, module, exports) {
        module.exports = {
            allFormElObjects: [],
            formErrFlds: [],
            mainCmpId: "",
            renderedAt: "",
            callMe: "",
            isMobile: false
        };
    }, {} ],
    11: [ function(require, module, exports) {
        var React = require("react");
        var createReactClass = require("create-react-class");
        var LabelArea = createReactClass({
            render: function() {
                return React.createElement("div", {
                    className: "form-element-box " + this.props.elComponent.ctClsName,
                    "data-json": JSON.stringify(this.props.elComponent)
                }, React.createElement("label", {
                    style: this.props.elComponent.labelStyle,
                    id: this.props.elComponent.id,
                    className: "r-information-label " + (this.props.elComponent.clsName ? this.props.elComponent.clsName : "")
                }, React.createElement("span", null, this.props.elComponent.label), React.createElement("input", {
                    type: "hidden",
                    name: this.props.elComponent.name,
                    value: this.props.elComponent.label
                })));
            }
        });
        module.exports = LabelArea;
    }, {
        "create-react-class": 19,
        react: "react"
    } ],
    12: [ function(require, module, exports) {
        var Popover = require("react-awesome-popover");
        var React = require("react");
        var ReactDOM = require("react-dom");
        var createReactClass = require("create-react-class");
        var Global = require("./Global");
        var CommonMixin = require("./CommonMixin");
        var RadioButton = createReactClass({
            mixins: [ CommonMixin ],
            getInitialState: function() {
                return {
                    userInput: "",
                    formModeVal: this.props.formModeVal
                };
            },
            componentDidMount: function() {
                var obj = {
                    elName: this.props.elComponent.name,
                    elVal: ReactDOM.findDOMNode(this.refs[this.props.elComponent.name]).value,
                    validator: this.props.elComponent.validator,
                    type: "radio"
                };
                this.checkIfObjectExists(Global.allFormElObjects, this.props.elComponent.name, "", "");
                Global.allFormElObjects.push(obj);
            },
            render: function() {
                var me = this;
                var radioName = this.props.elComponent.name;
                var fieldValue = "";
                if (this.props.elData && typeof this.props.elData[this.props.elComponent.name] != "undefined") {
                    fieldValue = this.props.elData[this.props.elComponent.name];
                } else {
                    fieldValue = this.props.elComponent.value ? this.props.elComponent.value : "";
                }
                var diffDataCls = diffDataIconCls = diffData = "";
                var isDiff = false;
                if (this.props.elDiffData && typeof this.props.elDiffData[this.props.elComponent.name] != "undefined") {
                    isDiff = true;
                    diffDataIconCls = "modified-data-icon";
                    var diffValClass = this.props.elDiffData[this.props.elComponent.name];
                    var diffArr = diffValClass.split("~diff~");
                    diffData = diffArr[0];
                    diffDataCls = diffArr[1];
                }
                var radioButtonsItems = this.props.elComponent.elements.map(function(val, index) {
                    if (diffData == val.value) diffData = val.label;
                    return React.createElement("label", {
                        key: Math.random(),
                        className: "r-form-radio-label-box " + (val.clsName ? val.clsName : "")
                    }, React.createElement("input", {
                        key: Math.random(),
                        type: "radio",
                        className: "r-form-radio " + (val.clsName ? val.clsName : ""),
                        ref: radioName,
                        name: radioName,
                        value: val.value,
                        onChange: me.onChange,
                        defaultChecked: fieldValue == val.value ? true : false
                    }), React.createElement("span", {
                        name: radioName + "-" + index
                    }, " " + val.label));
                });
                var hoverTitle = diffData == "" ? "No Value" : diffData;
                if (this.props.elComponent.label == "") {
                    var clsName = "hidden";
                } else {
                    var clsName = "";
                }
                this.props.elComponent.maxOptionNumber = this.props.elComponent.maxOptionNumber ? this.props.elComponent.maxOptionNumber : this.props.elComponent.elements.length;
                return React.createElement("div", {
                    className: diffDataCls + " form-element-box float-left " + this.props.elComponent.ctClsName,
                    "data-json": JSON.stringify(this.props.elComponent)
                }, React.createElement("div", {
                    className: clsName + " float-left form-field-label"
                }, React.createElement("label", {
                    name: this.props.elComponent.name + "-label",
                    className: "r-form-el-label " + (this.props.clsName ? this.props.clsName : ""),
                    style: this.props.elComponent.labelStyle
                }, React.createElement("span", null, this.props.elComponent.label), React.createElement("b", null, ":"), React.createElement("span", {
                    className: "required-sign"
                }, this.props.elComponent.validator ? this.props.elComponent.validator.isRequired ? "*" : "" : ""))), React.createElement("div", {
                    className: "float-left form-field"
                }, radioButtonsItems, React.createElement("br", null), React.createElement("div", {
                    name: this.props.elComponent.name + "_errorMsg",
                    className: this.props.elComponent.name + "_errorMsg error-message"
                })), React.createElement("span", {
                    className: diffDataIconCls,
                    alt: diffData,
                    title: diffData
                }));
            }
        });
        module.exports = RadioButton;
    }, {
        "./CommonMixin": 4,
        "./Global": 10,
        "create-react-class": 19,
        react: "react",
        "react-awesome-popover": 27,
        "react-dom": "react-dom"
    } ],
    13: [ function(require, module, exports) {
        var React = require("react");
        var createReactClass = require("create-react-class");
        var RenderAllComponentsRecursion = createReactClass({
            render: function() {
                var me = this;
                val = this.props.elStructure;
                formData = this.props.elData;
                formDiffData = this.props.elDiffData;
                cmpId = this.props.cmpId;
                if (val.etype == "fieldset") {
                    var subElHtml = val.elements.map(function(val) {
                        if (val.etype == "fieldset") {
                            return React.createElement("div", {
                                key: Math.random()
                            }, React.createElement(RenderAllComponentsRecursion, {
                                formModeVal: me.props.formModeVal,
                                cmpId: cmpId,
                                elStructure: val,
                                elData: formData,
                                elDiffData: formDiffData
                            }));
                        } else {
                            return React.createElement("div", {
                                key: Math.random()
                            }, React.createElement(SwitchComponent, {
                                formModeVal: me.props.formModeVal,
                                cmpId: cmpId,
                                elComponentArr: val,
                                elData: formData,
                                elDiffData: formDiffData
                            }));
                        }
                    });
                    return React.createElement(FieldSet, {
                        clsName: val.clsName,
                        style: val.style,
                        title: val.title,
                        innerElements: subElHtml
                    });
                } else {
                    return React.createElement(SwitchComponent, {
                        formModeVal: this.props.formModeVal,
                        cmpId: cmpId,
                        elComponentArr: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                }
            }
        });
        module.exports = RenderAllComponentsRecursion;
        var SwitchComponent = require("./SwitchComponent");
        var FieldSet = require("./FieldSet");
    }, {
        "./FieldSet": 8,
        "./SwitchComponent": 15,
        "create-react-class": 19,
        react: "react"
    } ],
    14: [ function(require, module, exports) {
        var Popover = require("react-awesome-popover");
        var React = require("react");
        var ReactDOM = require("react-dom");
        var createReactClass = require("create-react-class");
        var Global = require("./Global");
        var CommonMixin = require("./CommonMixin");
        var ScheckBox = createReactClass({
            mixins: [ CommonMixin ],
            getInitialState: function() {
                return {
                    userInput: "",
                    formModeVal: this.props.formModeVal
                };
            },
            componentDidMount: function() {
                var obj = {
                    elName: this.props.elComponent.name,
                    elVal: ReactDOM.findDOMNode(this.refs[this.props.elComponent.name]).value,
                    validator: this.props.elComponent.validator,
                    type: "scheckbox"
                };
                this.checkIfObjectExists(Global.allFormElObjects, this.props.elComponent.name, "", "");
                Global.allFormElObjects.push(obj);
            },
            render: function() {
                var me = this;
                var checkBoxName = this.props.elComponent.name;
                var fieldValue = "";
                if (this.props.elData && typeof this.props.elData[this.props.elComponent.name] != "undefined") {
                    fieldValue = this.props.elData[this.props.elComponent.name];
                } else {
                    fieldValue = this.props.elComponent.value ? this.props.elComponent.value : "";
                }
                var diffDataCls = diffDataIconCls = diffData = "";
                var isDiff = false;
                if (this.props.elDiffData && typeof this.props.elDiffData[this.props.elComponent.name] != "undefined") {
                    isDiff = true;
                    diffDataIconCls = "modified-data-icon";
                    var diffValClass = this.props.elDiffData[this.props.elComponent.name];
                    var diffArr = diffValClass.split("~diff~");
                    diffData = diffArr[0];
                    diffDataCls = diffArr[1];
                }
                var newDataVal = "";
                var checkBoxItems = this.props.elComponent.elements.map(function(val, index) {
                    var diffDataArr = diffData.split(",");
                    if (diffDataArr.length > 0) {
                        diffDataArr.map(function(v, i) {
                            if (v == val.value) newDataVal = newDataVal + "," + val.label;
                        });
                    } else {
                        if (diffData == val.value) diffData = val.label;
                    }
                    return React.createElement("label", {
                        key: Math.random(),
                        className: "r-form-check-box-label-box " + (val.clsName ? val.clsName : "")
                    }, React.createElement("input", {
                        type: "checkbox",
                        value: val.value,
                        key: Math.random(),
                        className: "r-form-check-box " + (val.clsName ? val.clsName : ""),
                        ref: checkBoxName,
                        name: checkBoxName,
                        disabled: me.props.elComponent.disabled ? me.props.elComponent.disabled : false,
                        onChange: me.onChange,
                        defaultChecked: fieldValue != "" ? typeof fieldValue != "string" ? fieldValue.indexOf(val.value) > -1 ? true : false : fieldValue == val.value ? true : false : false
                    }), React.createElement("input", {
                        type: "hidden",
                        className: checkBoxName + "-sc",
                        name: checkBoxName + "-sc",
                        value: " " + val.label
                    }));
                });
                if (newDataVal != "") {
                    if (newDataVal.indexOf(",", 1)) {
                        diffData = newDataVal.substring(1, newDataVal.length);
                    } else {
                        diffData = newDataVal;
                    }
                    newDataVal = "";
                }
                diffData = diffData == "No Value Set" || diffData == "" ? "Unchecked" : "Checked";
                if (this.props.elComponent.label == "") {
                    var clsName = "hidden";
                } else {
                    var clsName = "";
                }
                return React.createElement("div", {
                    className: diffDataCls + " form-element-box float-left " + this.props.elComponent.ctClsName,
                    "data-json": JSON.stringify(this.props.elComponent),
                    style: this.props.elComponent.style ? this.props.elComponent.style : {}
                }, React.createElement("div", {
                    className: clsName + " float-left form-field-label"
                }, React.createElement("label", {
                    name: this.props.elComponent.name + "-label",
                    className: "r-form-el-label " + (this.props.clsName ? this.props.clsName : ""),
                    style: this.props.elComponent.labelStyle
                }, React.createElement("span", null, this.props.elComponent.label), React.createElement("b", null, ":"), React.createElement("span", {
                    className: "required-sign"
                }, this.props.elComponent.validator ? this.props.elComponent.validator.isRequired ? "*" : "" : ""))), React.createElement("div", {
                    className: "float-left form-field"
                }, checkBoxItems, React.createElement("br", null), React.createElement("div", {
                    name: this.props.elComponent.name + "_errorMsg",
                    className: this.props.elComponent.name + "_errorMsg error-message"
                })), React.createElement("span", {
                    className: diffDataIconCls,
                    alt: diffData,
                    title: diffData
                }));
            }
        });
        module.exports = ScheckBox;
    }, {
        "./CommonMixin": 4,
        "./Global": 10,
        "create-react-class": 19,
        react: "react",
        "react-awesome-popover": 27,
        "react-dom": "react-dom"
    } ],
    15: [ function(require, module, exports) {
        var React = require("react");
        var createReactClass = require("create-react-class");
        var SwitchComponent = createReactClass({
            render: function() {
                val = this.props.elComponentArr;
                formData = this.props.elData;
                formDiffData = this.props.elDiffData;
                cmpId = this.props.cmpId;
                formModeVal = this.props.formModeVal;
                val.etype = val.etype ? val.etype.toLowerCase() : "";
                switch (val.etype) {
                  case "labelarea":
                    return React.createElement(LabelArea, {
                        formModeVal: formModeVal,
                        elComponent: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                    break;

                  case "textbox":
                    return React.createElement(TextBox, {
                        formModeVal: formModeVal,
                        cmpId: cmpId,
                        elComponent: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                    break;

                  case "textarea":
                    return React.createElement(TextArea, {
                        formModeVal: formModeVal,
                        cmpId: cmpId,
                        elComponent: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                    break;

                  case "dropdown":
                    return React.createElement(DropDown, {
                        formModeVal: formModeVal,
                        cmpId: cmpId,
                        elComponent: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                    break;

                  case "radio":
                    return React.createElement(RadioButton, {
                        formModeVal: formModeVal,
                        cmpId: cmpId,
                        elComponent: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                    break;

                  case "checkbox":
                    return React.createElement(CheckBox, {
                        formModeVal: formModeVal,
                        cmpId: cmpId,
                        elComponent: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                    break;

                  case "scheckbox":
                    return React.createElement(ScheckBox, {
                        formModeVal: formModeVal,
                        cmpId: cmpId,
                        elComponent: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                    break;

                  case "actionbutton":
                    return React.createElement(ActionButton, {
                        formModeVal: formModeVal,
                        cmpId: cmpId,
                        elComponent: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                    break;

                  case "datepicker":
                    return React.createElement(DatePicker, {
                        formModeVal: formModeVal,
                        cmpId: cmpId,
                        elComponent: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                    break;

                  case "divider":
                    return React.createElement(Divider, {
                        formModeVal: formModeVal,
                        cmpId: cmpId,
                        elComponent: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                    break;

                  case "optionchoice":
                    return React.createElement(ChoiceOption, {
                        formModeVal: formModeVal,
                        cmpId: cmpId,
                        elComponent: val,
                        elData: formData,
                        elDiffData: formDiffData
                    });
                    break;

                  default:
                    return React.createElement("div", null);
                    break;
                }
            }
        });
        module.exports = SwitchComponent;
        var LabelArea = require("./LabelArea");
        var TextBox = require("./TextBox");
        var TextArea = require("./TextArea");
        var DropDown = require("./DropDown");
        var RadioButton = require("./RadioButton");
        var CheckBox = require("./CheckBox");
        var ScheckBox = require("./ScheckBox");
        var ActionButton = require("./ActionButton");
        var DatePicker = require("./DatePicker");
        var Divider = require("./Divider");
        var ChoiceOption = require("./ChoiceOption");
    }, {
        "./ActionButton": 1,
        "./CheckBox": 2,
        "./ChoiceOption": 3,
        "./DatePicker": 5,
        "./Divider": 6,
        "./DropDown": 7,
        "./LabelArea": 11,
        "./RadioButton": 12,
        "./ScheckBox": 14,
        "./TextArea": 16,
        "./TextBox": 17,
        "create-react-class": 19,
        react: "react"
    } ],
    16: [ function(require, module, exports) {
        var Popover = require("react-awesome-popover");
        var React = require("react");
        var ReactDOM = require("react-dom");
        var createReactClass = require("create-react-class");
        var Global = require("./Global");
        var CommonMixin = require("./CommonMixin");
        var TextArea = createReactClass({
            mixins: [ CommonMixin ],
            getInitialState: function() {
                return {
                    userInput: "",
                    formModeVal: this.props.formModeVal
                };
            },
            componentDidMount: function() {
                this.limitRows();
                var obj = {
                    elName: this.props.elComponent.name,
                    elVal: ReactDOM.findDOMNode(this.refs[this.props.elComponent.name]).value,
                    validator: this.props.elComponent.validator
                };
                this.checkIfObjectExists(Global.allFormElObjects, this.props.elComponent.name, "", "");
                Global.allFormElObjects.push(obj);
            },
            limitRows: function() {
                var mainIdEl = document.getElementById(this.props.cmpId);
                var ta = $(mainIdEl).find("[name='" + this.props.elComponent.name + "']");
                var keynum, lines = 1;
                var minRows = ta.attr("data-min-rows");
                var maxRows = ta.attr("data-max-rows") - 1;
                var lh = ta[0].clientHeight / ta[0].rows;
                while (ta[0].scrollHeight > ta[0].clientHeight && !window.opera && parseInt(ta[0].rows) < parseInt(maxRows)) {
                    ta[0].style.overflow = "hidden";
                    ta[0].rows += 1;
                }
                if (ta[0].scrollHeight > ta[0].clientHeight) ta[0].style.overflow = "auto";
            },
            render: function() {
                var fieldValue = "";
                if (this.props.elData && typeof this.props.elData[this.props.elComponent.name] != "undefined") {
                    fieldValue = this.props.elData[this.props.elComponent.name];
                } else {
                    fieldValue = this.props.elComponent.value ? this.props.elComponent.value : "";
                }
                var diffDataCls = diffDataIconCls = diffData = "";
                var isDiff = false;
                if (this.props.elDiffData && typeof this.props.elDiffData[this.props.elComponent.name] != "undefined") {
                    isDiff = true;
                    diffDataIconCls = "modified-data-icon";
                    var diffValClass = this.props.elDiffData[this.props.elComponent.name];
                    var diffArr = diffValClass.split("~diff~");
                    diffData = diffArr[0];
                    diffDataCls = diffArr[1];
                }
                var actions = [ {
                    title: diffData == "" ? "No Value" : diffData
                } ];
                if (this.props.elComponent.label == "") {
                    var clsName = "hidden";
                } else {
                    var clsName = "";
                }
                if (this.props.elComponent.disabled) var disabledSpanEl = React.createElement("span", {
                    className: "disabled-span"
                }); else var disabledSpanEl = "";
                return React.createElement("div", {
                    className: diffDataCls + " form-element-box float-left " + this.props.elComponent.ctClsName,
                    "data-json": JSON.stringify(this.props.elComponent)
                }, React.createElement("div", {
                    className: clsName + " float-left form-field-label"
                }, React.createElement("label", {
                    name: this.props.elComponent.name + "-label",
                    className: "r-form-el-label " + (this.props.clsName ? this.props.clsName : ""),
                    style: this.props.elComponent.labelStyle
                }, React.createElement("span", null, this.props.elComponent.label), React.createElement("b", null, ":"), React.createElement("span", {
                    className: "required-sign"
                }, this.props.elComponent.validator ? this.props.elComponent.validator.isRequired ? "*" : "" : ""))), React.createElement("div", {
                    className: "float-left form-field"
                }, disabledSpanEl, React.createElement("textarea", {
                    id: this.props.elComponent.id,
                    type: "textarea",
                    className: "r-form-text-area " + (this.props.elComponent.clsName ? this.props.elComponent.clsName : ""),
                    style: this.props.elComponent.style ? this.props.elComponent.style : {},
                    ref: this.props.elComponent.name,
                    name: this.props.elComponent.name,
                    placeholder: this.props.elComponent.placeHolder,
                    rows: this.props.elComponent.initialVisibleLinesVal ? this.props.elComponent.initialVisibleLinesVal : 3,
                    "data-min-rows": this.props.elComponent.initialVisibleLinesVal ? this.props.elComponent.initialVisibleLinesVal : 3,
                    "data-max-rows": this.props.elComponent.maxVisibleLinesVal,
                    disabled: this.props.elComponent.disabled ? this.props.elComponent.disabled : false,
                    defaultValue: fieldValue,
                    onChange: this.onChange,
                    onBlur: this.onChange,
                    onClick: this.onChange
                }), React.createElement("br", null), React.createElement("div", {
                    name: this.props.elComponent.name + "_errorMsg",
                    className: this.props.elComponent.name + "_errorMsg error-message"
                })), React.createElement("span", {
                    className: diffDataIconCls,
                    alt: diffData,
                    title: diffData
                }));
            }
        });
        module.exports = TextArea;
    }, {
        "./CommonMixin": 4,
        "./Global": 10,
        "create-react-class": 19,
        react: "react",
        "react-awesome-popover": 27,
        "react-dom": "react-dom"
    } ],
    17: [ function(require, module, exports) {
        var Popover = require("react-awesome-popover");
        var React = require("react");
        var ReactDOM = require("react-dom");
        var createReactClass = require("create-react-class");
        var Global = require("./Global");
        var CommonMixin = require("./CommonMixin");
        var TextBox = createReactClass({
            mixins: [ CommonMixin ],
            getInitialState: function() {
                return {
                    userInput: "",
                    formModeVal: this.props.formModeVal
                };
            },
            componentDidMount: function() {
                var fllfName = this.props.elComponent.name;
                if (fllfName.indexOf("_") > -1) {
                    var explodeName = fllfName.split("_");
                    fllfName = explodeName[1];
                }
                if (fllfName == "OptionNameToolBoxProp" || fllfName == "OptionValueToolBoxProp") {
                    var mainIdEl = document.getElementById(Global.mainCmpId);
                    $(mainIdEl).find("[name='" + this.props.elComponent.name + "']").focus().blur();
                }
                var obj = {
                    elName: this.props.elComponent.name,
                    elVal: ReactDOM.findDOMNode(this.refs[this.props.elComponent.name]).value,
                    validator: this.props.elComponent.validator
                };
                this.checkIfObjectExists(Global.allFormElObjects, this.props.elComponent.name, "", "");
                Global.allFormElObjects.push(obj);
            },
            render: function() {
                var fieldValue = "";
                if (this.props.elData && typeof this.props.elData[this.props.elComponent.name] != "undefined") {
                    fieldValue = this.props.elData[this.props.elComponent.name];
                } else {
                    fieldValue = this.props.elComponent.value ? this.props.elComponent.value : "";
                }
                var diffDataCls = diffDataIconCls = diffData = "";
                var isDiff = false;
                if (this.props.elDiffData && typeof this.props.elDiffData[this.props.elComponent.name] != "undefined") {
                    isDiff = true;
                    diffDataIconCls = "modified-data-icon";
                    var diffValClass = this.props.elDiffData[this.props.elComponent.name];
                    var diffArr = diffValClass.split("~diff~");
                    diffData = diffArr[0];
                    diffDataCls = diffArr[1];
                }
                var actions = [ {
                    title: diffData == "" ? "No Value" : diffData
                } ];
                if (this.props.elComponent.label == "") {
                    var clsName = "hidden";
                } else {
                    var clsName = "";
                }
                var choiceDefaultValue = choiceDefaultValueSelected = choiceDefaultCheckBoxValue = optionTitle = optionAddClass = optionDeleteClass = "";
                var flVal = fieldValue;
                if (this.props.elComponent.choiceDefaultValue) {
                    if (!this.props.elComponent.choiceDefaultCheckBoxValue) {
                        choiceDefaultValue = "choice-default-value";
                        optionTitle = "Make this option default";
                        if (this.props.elComponent.actionButtonValue) flVal = this.props.elComponent.actionButtonValue;
                        var dslctdVal = this.props.elComponent.choiceDefaultValue;
                        if (dslctdVal.toLowerCase() == flVal.toLowerCase()) {
                            choiceDefaultValueSelected = "choice-default-value-selected";
                            optionTitle = "This option is default selected";
                        }
                    }
                    optionAddClass = "add-new-choice-icon";
                    optionDeleteClass = "delete-new-choice-icon";
                }
                if (this.props.elComponent.disabled) var disabledSpanEl = React.createElement("span", {
                    className: "disabled-span"
                }); else var disabledSpanEl = "";
                return React.createElement("div", {
                    className: diffDataCls + " form-element-box float-left " + this.props.elComponent.ctClsName,
                    "data-json": JSON.stringify(this.props.elComponent)
                }, React.createElement("div", {
                    className: clsName + " float-left form-field-label"
                }, React.createElement("label", {
                    name: this.props.elComponent.name + "-label",
                    className: "r-form-el-label " + (this.props.clsName ? this.props.clsName : ""),
                    style: this.props.elComponent.labelStyle
                }, React.createElement("span", null, this.props.elComponent.label), React.createElement("b", null, ":"), React.createElement("span", {
                    className: "required-sign"
                }, this.props.elComponent.validator ? this.props.elComponent.validator.isRequired ? "*" : "" : ""))), React.createElement("div", {
                    className: "float-left form-field"
                }, disabledSpanEl, React.createElement("input", {
                    id: this.props.elComponent.id,
                    type: "text",
                    maxLength: "80",
                    className: "r-form-text " + (this.props.elComponent.clsName ? this.props.elComponent.clsName : ""),
                    style: this.props.elComponent.style ? this.props.elComponent.style : {},
                    ref: this.props.elComponent.name,
                    name: this.props.elComponent.name,
                    placeholder: this.props.elComponent.placeHolder,
                    disabled: this.props.elComponent.disabled ? this.props.elComponent.disabled : false,
                    defaultValue: fieldValue,
                    onChange: this.onChange,
                    onBlur: this.onBlur,
                    onClick: this.onChange
                }), React.createElement("br", null), React.createElement("div", {
                    name: this.props.elComponent.name + "_errorMsg",
                    className: this.props.elComponent.name + "_errorMsg error-message"
                })), React.createElement("span", {
                    className: diffDataIconCls,
                    alt: diffData,
                    title: diffData
                }));
            }
        });
        module.exports = TextBox;
    }, {
        "./CommonMixin": 4,
        "./Global": 10,
        "create-react-class": 19,
        react: "react",
        "react-awesome-popover": 27,
        "react-dom": "react-dom"
    } ],
    18: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var _assign = require("object-assign");
            var emptyObject = require("fbjs/lib/emptyObject");
            var _invariant = require("fbjs/lib/invariant");
            if (process.env.NODE_ENV !== "production") {
                var warning = require("fbjs/lib/warning");
            }
            var MIXINS_KEY = "mixins";
            function identity(fn) {
                return fn;
            }
            var ReactPropTypeLocationNames;
            if (process.env.NODE_ENV !== "production") {
                ReactPropTypeLocationNames = {
                    prop: "prop",
                    context: "context",
                    childContext: "child context"
                };
            } else {
                ReactPropTypeLocationNames = {};
            }
            function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
                var injectedMixins = [];
                var ReactClassInterface = {
                    mixins: "DEFINE_MANY",
                    statics: "DEFINE_MANY",
                    propTypes: "DEFINE_MANY",
                    contextTypes: "DEFINE_MANY",
                    childContextTypes: "DEFINE_MANY",
                    getDefaultProps: "DEFINE_MANY_MERGED",
                    getInitialState: "DEFINE_MANY_MERGED",
                    getChildContext: "DEFINE_MANY_MERGED",
                    render: "DEFINE_ONCE",
                    componentWillMount: "DEFINE_MANY",
                    componentDidMount: "DEFINE_MANY",
                    componentWillReceiveProps: "DEFINE_MANY",
                    shouldComponentUpdate: "DEFINE_ONCE",
                    componentWillUpdate: "DEFINE_MANY",
                    componentDidUpdate: "DEFINE_MANY",
                    componentWillUnmount: "DEFINE_MANY",
                    UNSAFE_componentWillMount: "DEFINE_MANY",
                    UNSAFE_componentWillReceiveProps: "DEFINE_MANY",
                    UNSAFE_componentWillUpdate: "DEFINE_MANY",
                    updateComponent: "OVERRIDE_BASE"
                };
                var ReactClassStaticInterface = {
                    getDerivedStateFromProps: "DEFINE_MANY_MERGED"
                };
                var RESERVED_SPEC_KEYS = {
                    displayName: function(Constructor, displayName) {
                        Constructor.displayName = displayName;
                    },
                    mixins: function(Constructor, mixins) {
                        if (mixins) {
                            for (var i = 0; i < mixins.length; i++) {
                                mixSpecIntoComponent(Constructor, mixins[i]);
                            }
                        }
                    },
                    childContextTypes: function(Constructor, childContextTypes) {
                        if (process.env.NODE_ENV !== "production") {
                            validateTypeDef(Constructor, childContextTypes, "childContext");
                        }
                        Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
                    },
                    contextTypes: function(Constructor, contextTypes) {
                        if (process.env.NODE_ENV !== "production") {
                            validateTypeDef(Constructor, contextTypes, "context");
                        }
                        Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
                    },
                    getDefaultProps: function(Constructor, getDefaultProps) {
                        if (Constructor.getDefaultProps) {
                            Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
                        } else {
                            Constructor.getDefaultProps = getDefaultProps;
                        }
                    },
                    propTypes: function(Constructor, propTypes) {
                        if (process.env.NODE_ENV !== "production") {
                            validateTypeDef(Constructor, propTypes, "prop");
                        }
                        Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
                    },
                    statics: function(Constructor, statics) {
                        mixStaticSpecIntoComponent(Constructor, statics);
                    },
                    autobind: function() {}
                };
                function validateTypeDef(Constructor, typeDef, location) {
                    for (var propName in typeDef) {
                        if (typeDef.hasOwnProperty(propName)) {
                            if (process.env.NODE_ENV !== "production") {
                                warning(typeof typeDef[propName] === "function", "%s: %s type `%s` is invalid; it must be a function, usually from " + "React.PropTypes.", Constructor.displayName || "ReactClass", ReactPropTypeLocationNames[location], propName);
                            }
                        }
                    }
                }
                function validateMethodOverride(isAlreadyDefined, name) {
                    var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
                    if (ReactClassMixin.hasOwnProperty(name)) {
                        _invariant(specPolicy === "OVERRIDE_BASE", "ReactClassInterface: You are attempting to override " + "`%s` from your class specification. Ensure that your method names " + "do not overlap with React methods.", name);
                    }
                    if (isAlreadyDefined) {
                        _invariant(specPolicy === "DEFINE_MANY" || specPolicy === "DEFINE_MANY_MERGED", "ReactClassInterface: You are attempting to define " + "`%s` on your component more than once. This conflict may be due " + "to a mixin.", name);
                    }
                }
                function mixSpecIntoComponent(Constructor, spec) {
                    if (!spec) {
                        if (process.env.NODE_ENV !== "production") {
                            var typeofSpec = typeof spec;
                            var isMixinValid = typeofSpec === "object" && spec !== null;
                            if (process.env.NODE_ENV !== "production") {
                                warning(isMixinValid, "%s: You're attempting to include a mixin that is either null " + "or not an object. Check the mixins included by the component, " + "as well as any mixins they include themselves. " + "Expected object but got %s.", Constructor.displayName || "ReactClass", spec === null ? null : typeofSpec);
                            }
                        }
                        return;
                    }
                    _invariant(typeof spec !== "function", "ReactClass: You're attempting to " + "use a component class or function as a mixin. Instead, just use a " + "regular object.");
                    _invariant(!isValidElement(spec), "ReactClass: You're attempting to " + "use a component as a mixin. Instead, just use a regular object.");
                    var proto = Constructor.prototype;
                    var autoBindPairs = proto.__reactAutoBindPairs;
                    if (spec.hasOwnProperty(MIXINS_KEY)) {
                        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
                    }
                    for (var name in spec) {
                        if (!spec.hasOwnProperty(name)) {
                            continue;
                        }
                        if (name === MIXINS_KEY) {
                            continue;
                        }
                        var property = spec[name];
                        var isAlreadyDefined = proto.hasOwnProperty(name);
                        validateMethodOverride(isAlreadyDefined, name);
                        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
                            RESERVED_SPEC_KEYS[name](Constructor, property);
                        } else {
                            var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
                            var isFunction = typeof property === "function";
                            var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
                            if (shouldAutoBind) {
                                autoBindPairs.push(name, property);
                                proto[name] = property;
                            } else {
                                if (isAlreadyDefined) {
                                    var specPolicy = ReactClassInterface[name];
                                    _invariant(isReactClassMethod && (specPolicy === "DEFINE_MANY_MERGED" || specPolicy === "DEFINE_MANY"), "ReactClass: Unexpected spec policy %s for key %s " + "when mixing in component specs.", specPolicy, name);
                                    if (specPolicy === "DEFINE_MANY_MERGED") {
                                        proto[name] = createMergedResultFunction(proto[name], property);
                                    } else if (specPolicy === "DEFINE_MANY") {
                                        proto[name] = createChainedFunction(proto[name], property);
                                    }
                                } else {
                                    proto[name] = property;
                                    if (process.env.NODE_ENV !== "production") {
                                        if (typeof property === "function" && spec.displayName) {
                                            proto[name].displayName = spec.displayName + "_" + name;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                function mixStaticSpecIntoComponent(Constructor, statics) {
                    if (!statics) {
                        return;
                    }
                    for (var name in statics) {
                        var property = statics[name];
                        if (!statics.hasOwnProperty(name)) {
                            continue;
                        }
                        var isReserved = name in RESERVED_SPEC_KEYS;
                        _invariant(!isReserved, "ReactClass: You are attempting to define a reserved " + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + "as an instance property instead; it will still be accessible on the " + "constructor.", name);
                        var isAlreadyDefined = name in Constructor;
                        if (isAlreadyDefined) {
                            var specPolicy = ReactClassStaticInterface.hasOwnProperty(name) ? ReactClassStaticInterface[name] : null;
                            _invariant(specPolicy === "DEFINE_MANY_MERGED", "ReactClass: You are attempting to define " + "`%s` on your component more than once. This conflict may be " + "due to a mixin.", name);
                            Constructor[name] = createMergedResultFunction(Constructor[name], property);
                            return;
                        }
                        Constructor[name] = property;
                    }
                }
                function mergeIntoWithNoDuplicateKeys(one, two) {
                    _invariant(one && two && typeof one === "object" && typeof two === "object", "mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.");
                    for (var key in two) {
                        if (two.hasOwnProperty(key)) {
                            _invariant(one[key] === undefined, "mergeIntoWithNoDuplicateKeys(): " + "Tried to merge two objects with the same key: `%s`. This conflict " + "may be due to a mixin; in particular, this may be caused by two " + "getInitialState() or getDefaultProps() methods returning objects " + "with clashing keys.", key);
                            one[key] = two[key];
                        }
                    }
                    return one;
                }
                function createMergedResultFunction(one, two) {
                    return function mergedResult() {
                        var a = one.apply(this, arguments);
                        var b = two.apply(this, arguments);
                        if (a == null) {
                            return b;
                        } else if (b == null) {
                            return a;
                        }
                        var c = {};
                        mergeIntoWithNoDuplicateKeys(c, a);
                        mergeIntoWithNoDuplicateKeys(c, b);
                        return c;
                    };
                }
                function createChainedFunction(one, two) {
                    return function chainedFunction() {
                        one.apply(this, arguments);
                        two.apply(this, arguments);
                    };
                }
                function bindAutoBindMethod(component, method) {
                    var boundMethod = method.bind(component);
                    if (process.env.NODE_ENV !== "production") {
                        boundMethod.__reactBoundContext = component;
                        boundMethod.__reactBoundMethod = method;
                        boundMethod.__reactBoundArguments = null;
                        var componentName = component.constructor.displayName;
                        var _bind = boundMethod.bind;
                        boundMethod.bind = function(newThis) {
                            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                args[_key - 1] = arguments[_key];
                            }
                            if (newThis !== component && newThis !== null) {
                                if (process.env.NODE_ENV !== "production") {
                                    warning(false, "bind(): React component methods may only be bound to the " + "component instance. See %s", componentName);
                                }
                            } else if (!args.length) {
                                if (process.env.NODE_ENV !== "production") {
                                    warning(false, "bind(): You are binding a component method to the component. " + "React does this for you automatically in a high-performance " + "way, so you can safely remove this call. See %s", componentName);
                                }
                                return boundMethod;
                            }
                            var reboundMethod = _bind.apply(boundMethod, arguments);
                            reboundMethod.__reactBoundContext = component;
                            reboundMethod.__reactBoundMethod = method;
                            reboundMethod.__reactBoundArguments = args;
                            return reboundMethod;
                        };
                    }
                    return boundMethod;
                }
                function bindAutoBindMethods(component) {
                    var pairs = component.__reactAutoBindPairs;
                    for (var i = 0; i < pairs.length; i += 2) {
                        var autoBindKey = pairs[i];
                        var method = pairs[i + 1];
                        component[autoBindKey] = bindAutoBindMethod(component, method);
                    }
                }
                var IsMountedPreMixin = {
                    componentDidMount: function() {
                        this.__isMounted = true;
                    }
                };
                var IsMountedPostMixin = {
                    componentWillUnmount: function() {
                        this.__isMounted = false;
                    }
                };
                var ReactClassMixin = {
                    replaceState: function(newState, callback) {
                        this.updater.enqueueReplaceState(this, newState, callback);
                    },
                    isMounted: function() {
                        if (process.env.NODE_ENV !== "production") {
                            warning(this.__didWarnIsMounted, "%s: isMounted is deprecated. Instead, make sure to clean up " + "subscriptions and pending requests in componentWillUnmount to " + "prevent memory leaks.", this.constructor && this.constructor.displayName || this.name || "Component");
                            this.__didWarnIsMounted = true;
                        }
                        return !!this.__isMounted;
                    }
                };
                var ReactClassComponent = function() {};
                _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
                function createClass(spec) {
                    var Constructor = identity(function(props, context, updater) {
                        if (process.env.NODE_ENV !== "production") {
                            warning(this instanceof Constructor, "Something is calling a React component directly. Use a factory or " + "JSX instead. See: https://fb.me/react-legacyfactory");
                        }
                        if (this.__reactAutoBindPairs.length) {
                            bindAutoBindMethods(this);
                        }
                        this.props = props;
                        this.context = context;
                        this.refs = emptyObject;
                        this.updater = updater || ReactNoopUpdateQueue;
                        this.state = null;
                        var initialState = this.getInitialState ? this.getInitialState() : null;
                        if (process.env.NODE_ENV !== "production") {
                            if (initialState === undefined && this.getInitialState._isMockFunction) {
                                initialState = null;
                            }
                        }
                        _invariant(typeof initialState === "object" && !Array.isArray(initialState), "%s.getInitialState(): must return an object or null", Constructor.displayName || "ReactCompositeComponent");
                        this.state = initialState;
                    });
                    Constructor.prototype = new ReactClassComponent();
                    Constructor.prototype.constructor = Constructor;
                    Constructor.prototype.__reactAutoBindPairs = [];
                    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
                    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
                    mixSpecIntoComponent(Constructor, spec);
                    mixSpecIntoComponent(Constructor, IsMountedPostMixin);
                    if (Constructor.getDefaultProps) {
                        Constructor.defaultProps = Constructor.getDefaultProps();
                    }
                    if (process.env.NODE_ENV !== "production") {
                        if (Constructor.getDefaultProps) {
                            Constructor.getDefaultProps.isReactClassApproved = {};
                        }
                        if (Constructor.prototype.getInitialState) {
                            Constructor.prototype.getInitialState.isReactClassApproved = {};
                        }
                    }
                    _invariant(Constructor.prototype.render, "createClass(...): Class specification must implement a `render` method.");
                    if (process.env.NODE_ENV !== "production") {
                        warning(!Constructor.prototype.componentShouldUpdate, "%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", spec.displayName || "A component");
                        warning(!Constructor.prototype.componentWillRecieveProps, "%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", spec.displayName || "A component");
                        warning(!Constructor.prototype.UNSAFE_componentWillRecieveProps, "%s has a method called UNSAFE_componentWillRecieveProps(). " + "Did you mean UNSAFE_componentWillReceiveProps()?", spec.displayName || "A component");
                    }
                    for (var methodName in ReactClassInterface) {
                        if (!Constructor.prototype[methodName]) {
                            Constructor.prototype[methodName] = null;
                        }
                    }
                    return Constructor;
                }
                return createClass;
            }
            module.exports = factory;
        }).call(this, require("_process"));
    }, {
        _process: 26,
        "fbjs/lib/emptyObject": 21,
        "fbjs/lib/invariant": 22,
        "fbjs/lib/warning": 23,
        "object-assign": 24
    } ],
    19: [ function(require, module, exports) {
        "use strict";
        var React = require("react");
        var factory = require("./factory");
        if (typeof React === "undefined") {
            throw Error("create-react-class could not find the React object. If you are using script tags, " + "make sure that React is being loaded before create-react-class.");
        }
        var ReactNoopUpdateQueue = new React.Component().updater;
        module.exports = factory(React.Component, React.isValidElement, ReactNoopUpdateQueue);
    }, {
        "./factory": 18,
        react: "react"
    } ],
    20: [ function(require, module, exports) {
        "use strict";
        function makeEmptyFunction(arg) {
            return function() {
                return arg;
            };
        }
        var emptyFunction = function emptyFunction() {};
        emptyFunction.thatReturns = makeEmptyFunction;
        emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
        emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
        emptyFunction.thatReturnsNull = makeEmptyFunction(null);
        emptyFunction.thatReturnsThis = function() {
            return this;
        };
        emptyFunction.thatReturnsArgument = function(arg) {
            return arg;
        };
        module.exports = emptyFunction;
    }, {} ],
    21: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var emptyObject = {};
            if (process.env.NODE_ENV !== "production") {
                Object.freeze(emptyObject);
            }
            module.exports = emptyObject;
        }).call(this, require("_process"));
    }, {
        _process: 26
    } ],
    22: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var validateFormat = function validateFormat(format) {};
            if (process.env.NODE_ENV !== "production") {
                validateFormat = function validateFormat(format) {
                    if (format === undefined) {
                        throw new Error("invariant requires an error message argument");
                    }
                };
            }
            function invariant(condition, format, a, b, c, d, e, f) {
                validateFormat(format);
                if (!condition) {
                    var error;
                    if (format === undefined) {
                        error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
                    } else {
                        var args = [ a, b, c, d, e, f ];
                        var argIndex = 0;
                        error = new Error(format.replace(/%s/g, function() {
                            return args[argIndex++];
                        }));
                        error.name = "Invariant Violation";
                    }
                    error.framesToPop = 1;
                    throw error;
                }
            }
            module.exports = invariant;
        }).call(this, require("_process"));
    }, {
        _process: 26
    } ],
    23: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var emptyFunction = require("./emptyFunction");
            var warning = emptyFunction;
            if (process.env.NODE_ENV !== "production") {
                var printWarning = function printWarning(format) {
                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }
                    var argIndex = 0;
                    var message = "Warning: " + format.replace(/%s/g, function() {
                        return args[argIndex++];
                    });
                    if (typeof console !== "undefined") {
                        console.error(message);
                    }
                    try {
                        throw new Error(message);
                    } catch (x) {}
                };
                warning = function warning(condition, format) {
                    if (format === undefined) {
                        throw new Error("`warning(condition, format, ...args)` requires a warning " + "message argument");
                    }
                    if (format.indexOf("Failed Composite propType: ") === 0) {
                        return;
                    }
                    if (!condition) {
                        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                            args[_key2 - 2] = arguments[_key2];
                        }
                        printWarning.apply(undefined, [ format ].concat(args));
                    }
                };
            }
            module.exports = warning;
        }).call(this, require("_process"));
    }, {
        "./emptyFunction": 20,
        _process: 26
    } ],
    24: [ function(require, module, exports) {
        "use strict";
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
            if (val === null || val === undefined) {
                throw new TypeError("Object.assign cannot be called with null or undefined");
            }
            return Object(val);
        }
        function shouldUseNative() {
            try {
                if (!Object.assign) {
                    return false;
                }
                var test1 = new String("abc");
                test1[5] = "de";
                if (Object.getOwnPropertyNames(test1)[0] === "5") {
                    return false;
                }
                var test2 = {};
                for (var i = 0; i < 10; i++) {
                    test2["_" + String.fromCharCode(i)] = i;
                }
                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                });
                if (order2.join("") !== "0123456789") {
                    return false;
                }
                var test3 = {};
                "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                    test3[letter] = letter;
                });
                if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                    return false;
                }
                return true;
            } catch (err) {
                return false;
            }
        }
        module.exports = shouldUseNative() ? Object.assign : function(target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for (var s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);
                for (var key in from) {
                    if (hasOwnProperty.call(from, key)) {
                        to[key] = from[key];
                    }
                }
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) {
                        if (propIsEnumerable.call(from, symbols[i])) {
                            to[symbols[i]] = from[symbols[i]];
                        }
                    }
                }
            }
            return to;
        };
    }, {} ],
    25: [ function(require, module, exports) {
        "use strict";
        function get(element) {
            return getComputedStyle(element);
        }
        function set(element, obj) {
            for (var key in obj) {
                var val = obj[key];
                if (typeof val === "number") {
                    val = val + "px";
                }
                element.style[key] = val;
            }
            return element;
        }
        function div(className) {
            var div = document.createElement("div");
            div.className = className;
            return div;
        }
        var elMatches = typeof Element !== "undefined" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
        function matches(element, query) {
            if (!elMatches) {
                throw new Error("No element matching method supported");
            }
            return elMatches.call(element, query);
        }
        function remove(element) {
            if (element.remove) {
                element.remove();
            } else {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            }
        }
        function queryChildren(element, selector) {
            return Array.prototype.filter.call(element.children, function(child) {
                return matches(child, selector);
            });
        }
        var cls = {
            main: "ps",
            element: {
                thumb: function(x) {
                    return "ps__thumb-" + x;
                },
                rail: function(x) {
                    return "ps__rail-" + x;
                },
                consuming: "ps__child--consume"
            },
            state: {
                focus: "ps--focus",
                clicking: "ps--clicking",
                active: function(x) {
                    return "ps--active-" + x;
                },
                scrolling: function(x) {
                    return "ps--scrolling-" + x;
                }
            }
        };
        var scrollingClassTimeout = {
            x: null,
            y: null
        };
        function addScrollingClass(i, x) {
            var classList = i.element.classList;
            var className = cls.state.scrolling(x);
            if (classList.contains(className)) {
                clearTimeout(scrollingClassTimeout[x]);
            } else {
                classList.add(className);
            }
        }
        function removeScrollingClass(i, x) {
            scrollingClassTimeout[x] = setTimeout(function() {
                return i.isAlive && i.element.classList.remove(cls.state.scrolling(x));
            }, i.settings.scrollingThreshold);
        }
        function setScrollingClassInstantly(i, x) {
            addScrollingClass(i, x);
            removeScrollingClass(i, x);
        }
        var EventElement = function EventElement(element) {
            this.element = element;
            this.handlers = {};
        };
        var prototypeAccessors = {
            isEmpty: {
                configurable: true
            }
        };
        EventElement.prototype.bind = function bind(eventName, handler) {
            if (typeof this.handlers[eventName] === "undefined") {
                this.handlers[eventName] = [];
            }
            this.handlers[eventName].push(handler);
            this.element.addEventListener(eventName, handler, false);
        };
        EventElement.prototype.unbind = function unbind(eventName, target) {
            var this$1 = this;
            this.handlers[eventName] = this.handlers[eventName].filter(function(handler) {
                if (target && handler !== target) {
                    return true;
                }
                this$1.element.removeEventListener(eventName, handler, false);
                return false;
            });
        };
        EventElement.prototype.unbindAll = function unbindAll() {
            var this$1 = this;
            for (var name in this$1.handlers) {
                this$1.unbind(name);
            }
        };
        prototypeAccessors.isEmpty.get = function() {
            var this$1 = this;
            return Object.keys(this.handlers).every(function(key) {
                return this$1.handlers[key].length === 0;
            });
        };
        Object.defineProperties(EventElement.prototype, prototypeAccessors);
        var EventManager = function EventManager() {
            this.eventElements = [];
        };
        EventManager.prototype.eventElement = function eventElement(element) {
            var ee = this.eventElements.filter(function(ee) {
                return ee.element === element;
            })[0];
            if (!ee) {
                ee = new EventElement(element);
                this.eventElements.push(ee);
            }
            return ee;
        };
        EventManager.prototype.bind = function bind(element, eventName, handler) {
            this.eventElement(element).bind(eventName, handler);
        };
        EventManager.prototype.unbind = function unbind(element, eventName, handler) {
            var ee = this.eventElement(element);
            ee.unbind(eventName, handler);
            if (ee.isEmpty) {
                this.eventElements.splice(this.eventElements.indexOf(ee), 1);
            }
        };
        EventManager.prototype.unbindAll = function unbindAll() {
            this.eventElements.forEach(function(e) {
                return e.unbindAll();
            });
            this.eventElements = [];
        };
        EventManager.prototype.once = function once(element, eventName, handler) {
            var ee = this.eventElement(element);
            var onceHandler = function(evt) {
                ee.unbind(eventName, onceHandler);
                handler(evt);
            };
            ee.bind(eventName, onceHandler);
        };
        function createEvent(name) {
            if (typeof window.CustomEvent === "function") {
                return new CustomEvent(name);
            } else {
                var evt = document.createEvent("CustomEvent");
                evt.initCustomEvent(name, false, false, undefined);
                return evt;
            }
        }
        var processScrollDiff = function(i, axis, diff, useScrollingClass, forceFireReachEvent) {
            if (useScrollingClass === void 0) useScrollingClass = true;
            if (forceFireReachEvent === void 0) forceFireReachEvent = false;
            var fields;
            if (axis === "top") {
                fields = [ "contentHeight", "containerHeight", "scrollTop", "y", "up", "down" ];
            } else if (axis === "left") {
                fields = [ "contentWidth", "containerWidth", "scrollLeft", "x", "left", "right" ];
            } else {
                throw new Error("A proper axis should be provided");
            }
            processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
        };
        function processScrollDiff$1(i, diff, ref, useScrollingClass, forceFireReachEvent) {
            var contentHeight = ref[0];
            var containerHeight = ref[1];
            var scrollTop = ref[2];
            var y = ref[3];
            var up = ref[4];
            var down = ref[5];
            if (useScrollingClass === void 0) useScrollingClass = true;
            if (forceFireReachEvent === void 0) forceFireReachEvent = false;
            var element = i.element;
            i.reach[y] = null;
            if (element[scrollTop] < 1) {
                i.reach[y] = "start";
            }
            if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
                i.reach[y] = "end";
            }
            if (diff) {
                element.dispatchEvent(createEvent("ps-scroll-" + y));
                if (diff < 0) {
                    element.dispatchEvent(createEvent("ps-scroll-" + up));
                } else if (diff > 0) {
                    element.dispatchEvent(createEvent("ps-scroll-" + down));
                }
                if (useScrollingClass) {
                    setScrollingClassInstantly(i, y);
                }
            }
            if (i.reach[y] && (diff || forceFireReachEvent)) {
                element.dispatchEvent(createEvent("ps-" + y + "-reach-" + i.reach[y]));
            }
        }
        function toInt(x) {
            return parseInt(x, 10) || 0;
        }
        function isEditable(el) {
            return matches(el, "input,[contenteditable]") || matches(el, "select,[contenteditable]") || matches(el, "textarea,[contenteditable]") || matches(el, "button,[contenteditable]");
        }
        function outerWidth(element) {
            var styles = get(element);
            return toInt(styles.width) + toInt(styles.paddingLeft) + toInt(styles.paddingRight) + toInt(styles.borderLeftWidth) + toInt(styles.borderRightWidth);
        }
        var env = {
            isWebKit: typeof document !== "undefined" && "WebkitAppearance" in document.documentElement.style,
            supportsTouch: typeof window !== "undefined" && ("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch),
            supportsIePointer: typeof navigator !== "undefined" && navigator.msMaxTouchPoints,
            isChrome: typeof navigator !== "undefined" && /Chrome/i.test(navigator && navigator.userAgent)
        };
        var updateGeometry = function(i) {
            var element = i.element;
            var roundedScrollTop = Math.floor(element.scrollTop);
            i.containerWidth = element.clientWidth;
            i.containerHeight = element.clientHeight;
            i.contentWidth = element.scrollWidth;
            i.contentHeight = element.scrollHeight;
            if (!element.contains(i.scrollbarXRail)) {
                queryChildren(element, cls.element.rail("x")).forEach(function(el) {
                    return remove(el);
                });
                element.appendChild(i.scrollbarXRail);
            }
            if (!element.contains(i.scrollbarYRail)) {
                queryChildren(element, cls.element.rail("y")).forEach(function(el) {
                    return remove(el);
                });
                element.appendChild(i.scrollbarYRail);
            }
            if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
                i.scrollbarXActive = true;
                i.railXWidth = i.containerWidth - i.railXMarginWidth;
                i.railXRatio = i.containerWidth / i.railXWidth;
                i.scrollbarXWidth = getThumbSize(i, toInt(i.railXWidth * i.containerWidth / i.contentWidth));
                i.scrollbarXLeft = toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
            } else {
                i.scrollbarXActive = false;
            }
            if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
                i.scrollbarYActive = true;
                i.railYHeight = i.containerHeight - i.railYMarginHeight;
                i.railYRatio = i.containerHeight / i.railYHeight;
                i.scrollbarYHeight = getThumbSize(i, toInt(i.railYHeight * i.containerHeight / i.contentHeight));
                i.scrollbarYTop = toInt(roundedScrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
            } else {
                i.scrollbarYActive = false;
            }
            if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
                i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
            }
            if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
                i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
            }
            updateCss(element, i);
            if (i.scrollbarXActive) {
                element.classList.add(cls.state.active("x"));
            } else {
                element.classList.remove(cls.state.active("x"));
                i.scrollbarXWidth = 0;
                i.scrollbarXLeft = 0;
                element.scrollLeft = 0;
            }
            if (i.scrollbarYActive) {
                element.classList.add(cls.state.active("y"));
            } else {
                element.classList.remove(cls.state.active("y"));
                i.scrollbarYHeight = 0;
                i.scrollbarYTop = 0;
                element.scrollTop = 0;
            }
        };
        function getThumbSize(i, thumbSize) {
            if (i.settings.minScrollbarLength) {
                thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
            }
            if (i.settings.maxScrollbarLength) {
                thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
            }
            return thumbSize;
        }
        function updateCss(element, i) {
            var xRailOffset = {
                width: i.railXWidth
            };
            var roundedScrollTop = Math.floor(element.scrollTop);
            if (i.isRtl) {
                xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
            } else {
                xRailOffset.left = element.scrollLeft;
            }
            if (i.isScrollbarXUsingBottom) {
                xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
            } else {
                xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
            }
            set(i.scrollbarXRail, xRailOffset);
            var yRailOffset = {
                top: roundedScrollTop,
                height: i.railYHeight
            };
            if (i.isScrollbarYUsingRight) {
                if (i.isRtl) {
                    yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth;
                } else {
                    yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
                }
            } else {
                if (i.isRtl) {
                    yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
                } else {
                    yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
                }
            }
            set(i.scrollbarYRail, yRailOffset);
            set(i.scrollbarX, {
                left: i.scrollbarXLeft,
                width: i.scrollbarXWidth - i.railBorderXWidth
            });
            set(i.scrollbarY, {
                top: i.scrollbarYTop,
                height: i.scrollbarYHeight - i.railBorderYWidth
            });
        }
        var clickRail = function(i) {
            i.event.bind(i.scrollbarY, "mousedown", function(e) {
                return e.stopPropagation();
            });
            i.event.bind(i.scrollbarYRail, "mousedown", function(e) {
                var positionTop = e.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top;
                var direction = positionTop > i.scrollbarYTop ? 1 : -1;
                i.element.scrollTop += direction * i.containerHeight;
                updateGeometry(i);
                e.stopPropagation();
            });
            i.event.bind(i.scrollbarX, "mousedown", function(e) {
                return e.stopPropagation();
            });
            i.event.bind(i.scrollbarXRail, "mousedown", function(e) {
                var positionLeft = e.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left;
                var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;
                i.element.scrollLeft += direction * i.containerWidth;
                updateGeometry(i);
                e.stopPropagation();
            });
        };
        var dragThumb = function(i) {
            bindMouseScrollHandler(i, [ "containerWidth", "contentWidth", "pageX", "railXWidth", "scrollbarX", "scrollbarXWidth", "scrollLeft", "x", "scrollbarXRail" ]);
            bindMouseScrollHandler(i, [ "containerHeight", "contentHeight", "pageY", "railYHeight", "scrollbarY", "scrollbarYHeight", "scrollTop", "y", "scrollbarYRail" ]);
        };
        function bindMouseScrollHandler(i, ref) {
            var containerHeight = ref[0];
            var contentHeight = ref[1];
            var pageY = ref[2];
            var railYHeight = ref[3];
            var scrollbarY = ref[4];
            var scrollbarYHeight = ref[5];
            var scrollTop = ref[6];
            var y = ref[7];
            var scrollbarYRail = ref[8];
            var element = i.element;
            var startingScrollTop = null;
            var startingMousePageY = null;
            var scrollBy = null;
            function mouseMoveHandler(e) {
                element[scrollTop] = startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);
                addScrollingClass(i, y);
                updateGeometry(i);
                e.stopPropagation();
                e.preventDefault();
            }
            function mouseUpHandler() {
                removeScrollingClass(i, y);
                i[scrollbarYRail].classList.remove(cls.state.clicking);
                i.event.unbind(i.ownerDocument, "mousemove", mouseMoveHandler);
            }
            i.event.bind(i[scrollbarY], "mousedown", function(e) {
                startingScrollTop = element[scrollTop];
                startingMousePageY = e[pageY];
                scrollBy = (i[contentHeight] - i[containerHeight]) / (i[railYHeight] - i[scrollbarYHeight]);
                i.event.bind(i.ownerDocument, "mousemove", mouseMoveHandler);
                i.event.once(i.ownerDocument, "mouseup", mouseUpHandler);
                i[scrollbarYRail].classList.add(cls.state.clicking);
                e.stopPropagation();
                e.preventDefault();
            });
        }
        var keyboard = function(i) {
            var element = i.element;
            var elementHovered = function() {
                return matches(element, ":hover");
            };
            var scrollbarFocused = function() {
                return matches(i.scrollbarX, ":focus") || matches(i.scrollbarY, ":focus");
            };
            function shouldPreventDefault(deltaX, deltaY) {
                var scrollTop = Math.floor(element.scrollTop);
                if (deltaX === 0) {
                    if (!i.scrollbarYActive) {
                        return false;
                    }
                    if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
                        return !i.settings.wheelPropagation;
                    }
                }
                var scrollLeft = element.scrollLeft;
                if (deltaY === 0) {
                    if (!i.scrollbarXActive) {
                        return false;
                    }
                    if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
                        return !i.settings.wheelPropagation;
                    }
                }
                return true;
            }
            i.event.bind(i.ownerDocument, "keydown", function(e) {
                if (e.isDefaultPrevented && e.isDefaultPrevented() || e.defaultPrevented) {
                    return;
                }
                if (!elementHovered() && !scrollbarFocused()) {
                    return;
                }
                var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
                if (activeElement) {
                    if (activeElement.tagName === "IFRAME") {
                        activeElement = activeElement.contentDocument.activeElement;
                    } else {
                        while (activeElement.shadowRoot) {
                            activeElement = activeElement.shadowRoot.activeElement;
                        }
                    }
                    if (isEditable(activeElement)) {
                        return;
                    }
                }
                var deltaX = 0;
                var deltaY = 0;
                switch (e.which) {
                  case 37:
                    if (e.metaKey) {
                        deltaX = -i.contentWidth;
                    } else if (e.altKey) {
                        deltaX = -i.containerWidth;
                    } else {
                        deltaX = -30;
                    }
                    break;

                  case 38:
                    if (e.metaKey) {
                        deltaY = i.contentHeight;
                    } else if (e.altKey) {
                        deltaY = i.containerHeight;
                    } else {
                        deltaY = 30;
                    }
                    break;

                  case 39:
                    if (e.metaKey) {
                        deltaX = i.contentWidth;
                    } else if (e.altKey) {
                        deltaX = i.containerWidth;
                    } else {
                        deltaX = 30;
                    }
                    break;

                  case 40:
                    if (e.metaKey) {
                        deltaY = -i.contentHeight;
                    } else if (e.altKey) {
                        deltaY = -i.containerHeight;
                    } else {
                        deltaY = -30;
                    }
                    break;

                  case 32:
                    if (e.shiftKey) {
                        deltaY = i.containerHeight;
                    } else {
                        deltaY = -i.containerHeight;
                    }
                    break;

                  case 33:
                    deltaY = i.containerHeight;
                    break;

                  case 34:
                    deltaY = -i.containerHeight;
                    break;

                  case 36:
                    deltaY = i.contentHeight;
                    break;

                  case 35:
                    deltaY = -i.contentHeight;
                    break;

                  default:
                    return;
                }
                if (i.settings.suppressScrollX && deltaX !== 0) {
                    return;
                }
                if (i.settings.suppressScrollY && deltaY !== 0) {
                    return;
                }
                element.scrollTop -= deltaY;
                element.scrollLeft += deltaX;
                updateGeometry(i);
                if (shouldPreventDefault(deltaX, deltaY)) {
                    e.preventDefault();
                }
            });
        };
        var wheel = function(i) {
            var element = i.element;
            function shouldPreventDefault(deltaX, deltaY) {
                var roundedScrollTop = Math.floor(element.scrollTop);
                var isTop = element.scrollTop === 0;
                var isBottom = roundedScrollTop + element.offsetHeight === element.scrollHeight;
                var isLeft = element.scrollLeft === 0;
                var isRight = element.scrollLeft + element.offsetWidth === element.scrollWidth;
                var hitsBound;
                if (Math.abs(deltaY) > Math.abs(deltaX)) {
                    hitsBound = isTop || isBottom;
                } else {
                    hitsBound = isLeft || isRight;
                }
                return hitsBound ? !i.settings.wheelPropagation : true;
            }
            function getDeltaFromEvent(e) {
                var deltaX = e.deltaX;
                var deltaY = -1 * e.deltaY;
                if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
                    deltaX = -1 * e.wheelDeltaX / 6;
                    deltaY = e.wheelDeltaY / 6;
                }
                if (e.deltaMode && e.deltaMode === 1) {
                    deltaX *= 10;
                    deltaY *= 10;
                }
                if (deltaX !== deltaX && deltaY !== deltaY) {
                    deltaX = 0;
                    deltaY = e.wheelDelta;
                }
                if (e.shiftKey) {
                    return [ -deltaY, -deltaX ];
                }
                return [ deltaX, deltaY ];
            }
            function shouldBeConsumedByChild(target, deltaX, deltaY) {
                if (!env.isWebKit && element.querySelector("select:focus")) {
                    return true;
                }
                if (!element.contains(target)) {
                    return false;
                }
                var cursor = target;
                while (cursor && cursor !== element) {
                    if (cursor.classList.contains(cls.element.consuming)) {
                        return true;
                    }
                    var style = get(cursor);
                    var overflow = [ style.overflow, style.overflowX, style.overflowY ].join("");
                    if (overflow.match(/(scroll|auto)/)) {
                        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
                        if (maxScrollTop > 0) {
                            if (!(cursor.scrollTop === 0 && deltaY > 0) && !(cursor.scrollTop === maxScrollTop && deltaY < 0)) {
                                return true;
                            }
                        }
                        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
                        if (maxScrollLeft > 0) {
                            if (!(cursor.scrollLeft === 0 && deltaX < 0) && !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)) {
                                return true;
                            }
                        }
                    }
                    cursor = cursor.parentNode;
                }
                return false;
            }
            function mousewheelHandler(e) {
                var ref = getDeltaFromEvent(e);
                var deltaX = ref[0];
                var deltaY = ref[1];
                if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {
                    return;
                }
                var shouldPrevent = false;
                if (!i.settings.useBothWheelAxes) {
                    element.scrollTop -= deltaY * i.settings.wheelSpeed;
                    element.scrollLeft += deltaX * i.settings.wheelSpeed;
                } else if (i.scrollbarYActive && !i.scrollbarXActive) {
                    if (deltaY) {
                        element.scrollTop -= deltaY * i.settings.wheelSpeed;
                    } else {
                        element.scrollTop += deltaX * i.settings.wheelSpeed;
                    }
                    shouldPrevent = true;
                } else if (i.scrollbarXActive && !i.scrollbarYActive) {
                    if (deltaX) {
                        element.scrollLeft += deltaX * i.settings.wheelSpeed;
                    } else {
                        element.scrollLeft -= deltaY * i.settings.wheelSpeed;
                    }
                    shouldPrevent = true;
                }
                updateGeometry(i);
                shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
                if (shouldPrevent && !e.ctrlKey) {
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
            if (typeof window.onwheel !== "undefined") {
                i.event.bind(element, "wheel", mousewheelHandler);
            } else if (typeof window.onmousewheel !== "undefined") {
                i.event.bind(element, "mousewheel", mousewheelHandler);
            }
        };
        var touch = function(i) {
            if (!env.supportsTouch && !env.supportsIePointer) {
                return;
            }
            var element = i.element;
            function shouldPrevent(deltaX, deltaY) {
                var scrollTop = Math.floor(element.scrollTop);
                var scrollLeft = element.scrollLeft;
                var magnitudeX = Math.abs(deltaX);
                var magnitudeY = Math.abs(deltaY);
                if (magnitudeY > magnitudeX) {
                    if (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight || deltaY > 0 && scrollTop === 0) {
                        return window.scrollY === 0 && deltaY > 0 && env.isChrome;
                    }
                } else if (magnitudeX > magnitudeY) {
                    if (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth || deltaX > 0 && scrollLeft === 0) {
                        return true;
                    }
                }
                return true;
            }
            function applyTouchMove(differenceX, differenceY) {
                element.scrollTop -= differenceY;
                element.scrollLeft -= differenceX;
                updateGeometry(i);
            }
            var startOffset = {};
            var startTime = 0;
            var speed = {};
            var easingLoop = null;
            function getTouch(e) {
                if (e.targetTouches) {
                    return e.targetTouches[0];
                } else {
                    return e;
                }
            }
            function shouldHandle(e) {
                if (e.pointerType && e.pointerType === "pen" && e.buttons === 0) {
                    return false;
                }
                if (e.targetTouches && e.targetTouches.length === 1) {
                    return true;
                }
                if (e.pointerType && e.pointerType !== "mouse" && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
                    return true;
                }
                return false;
            }
            function touchStart(e) {
                if (!shouldHandle(e)) {
                    return;
                }
                var touch = getTouch(e);
                startOffset.pageX = touch.pageX;
                startOffset.pageY = touch.pageY;
                startTime = new Date().getTime();
                if (easingLoop !== null) {
                    clearInterval(easingLoop);
                }
            }
            function shouldBeConsumedByChild(target, deltaX, deltaY) {
                if (!element.contains(target)) {
                    return false;
                }
                var cursor = target;
                while (cursor && cursor !== element) {
                    if (cursor.classList.contains(cls.element.consuming)) {
                        return true;
                    }
                    var style = get(cursor);
                    var overflow = [ style.overflow, style.overflowX, style.overflowY ].join("");
                    if (overflow.match(/(scroll|auto)/)) {
                        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
                        if (maxScrollTop > 0) {
                            if (!(cursor.scrollTop === 0 && deltaY > 0) && !(cursor.scrollTop === maxScrollTop && deltaY < 0)) {
                                return true;
                            }
                        }
                        var maxScrollLeft = cursor.scrollLeft - cursor.clientWidth;
                        if (maxScrollLeft > 0) {
                            if (!(cursor.scrollLeft === 0 && deltaX < 0) && !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)) {
                                return true;
                            }
                        }
                    }
                    cursor = cursor.parentNode;
                }
                return false;
            }
            function touchMove(e) {
                if (shouldHandle(e)) {
                    var touch = getTouch(e);
                    var currentOffset = {
                        pageX: touch.pageX,
                        pageY: touch.pageY
                    };
                    var differenceX = currentOffset.pageX - startOffset.pageX;
                    var differenceY = currentOffset.pageY - startOffset.pageY;
                    if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {
                        return;
                    }
                    applyTouchMove(differenceX, differenceY);
                    startOffset = currentOffset;
                    var currentTime = new Date().getTime();
                    var timeGap = currentTime - startTime;
                    if (timeGap > 0) {
                        speed.x = differenceX / timeGap;
                        speed.y = differenceY / timeGap;
                        startTime = currentTime;
                    }
                    if (shouldPrevent(differenceX, differenceY)) {
                        e.preventDefault();
                    }
                }
            }
            function touchEnd() {
                if (i.settings.swipeEasing) {
                    clearInterval(easingLoop);
                    easingLoop = setInterval(function() {
                        if (i.isInitialized) {
                            clearInterval(easingLoop);
                            return;
                        }
                        if (!speed.x && !speed.y) {
                            clearInterval(easingLoop);
                            return;
                        }
                        if (Math.abs(speed.x) < .01 && Math.abs(speed.y) < .01) {
                            clearInterval(easingLoop);
                            return;
                        }
                        applyTouchMove(speed.x * 30, speed.y * 30);
                        speed.x *= .8;
                        speed.y *= .8;
                    }, 10);
                }
            }
            if (env.supportsTouch) {
                i.event.bind(element, "touchstart", touchStart);
                i.event.bind(element, "touchmove", touchMove);
                i.event.bind(element, "touchend", touchEnd);
            } else if (env.supportsIePointer) {
                if (window.PointerEvent) {
                    i.event.bind(element, "pointerdown", touchStart);
                    i.event.bind(element, "pointermove", touchMove);
                    i.event.bind(element, "pointerup", touchEnd);
                } else if (window.MSPointerEvent) {
                    i.event.bind(element, "MSPointerDown", touchStart);
                    i.event.bind(element, "MSPointerMove", touchMove);
                    i.event.bind(element, "MSPointerUp", touchEnd);
                }
            }
        };
        var defaultSettings = function() {
            return {
                handlers: [ "click-rail", "drag-thumb", "keyboard", "wheel", "touch" ],
                maxScrollbarLength: null,
                minScrollbarLength: null,
                scrollingThreshold: 1e3,
                scrollXMarginOffset: 0,
                scrollYMarginOffset: 0,
                suppressScrollX: false,
                suppressScrollY: false,
                swipeEasing: true,
                useBothWheelAxes: false,
                wheelPropagation: true,
                wheelSpeed: 1
            };
        };
        var handlers = {
            "click-rail": clickRail,
            "drag-thumb": dragThumb,
            keyboard: keyboard,
            wheel: wheel,
            touch: touch
        };
        var PerfectScrollbar = function PerfectScrollbar(element, userSettings) {
            var this$1 = this;
            if (userSettings === void 0) userSettings = {};
            if (typeof element === "string") {
                element = document.querySelector(element);
            }
            if (!element || !element.nodeName) {
                throw new Error("no element is specified to initialize PerfectScrollbar");
            }
            this.element = element;
            element.classList.add(cls.main);
            this.settings = defaultSettings();
            for (var key in userSettings) {
                this$1.settings[key] = userSettings[key];
            }
            this.containerWidth = null;
            this.containerHeight = null;
            this.contentWidth = null;
            this.contentHeight = null;
            var focus = function() {
                return element.classList.add(cls.state.focus);
            };
            var blur = function() {
                return element.classList.remove(cls.state.focus);
            };
            this.isRtl = get(element).direction === "rtl";
            this.isNegativeScroll = function() {
                var originalScrollLeft = element.scrollLeft;
                var result = null;
                element.scrollLeft = -1;
                result = element.scrollLeft < 0;
                element.scrollLeft = originalScrollLeft;
                return result;
            }();
            this.negativeScrollAdjustment = this.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
            this.event = new EventManager();
            this.ownerDocument = element.ownerDocument || document;
            this.scrollbarXRail = div(cls.element.rail("x"));
            element.appendChild(this.scrollbarXRail);
            this.scrollbarX = div(cls.element.thumb("x"));
            this.scrollbarXRail.appendChild(this.scrollbarX);
            this.scrollbarX.setAttribute("tabindex", 0);
            this.event.bind(this.scrollbarX, "focus", focus);
            this.event.bind(this.scrollbarX, "blur", blur);
            this.scrollbarXActive = null;
            this.scrollbarXWidth = null;
            this.scrollbarXLeft = null;
            var railXStyle = get(this.scrollbarXRail);
            this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
            if (isNaN(this.scrollbarXBottom)) {
                this.isScrollbarXUsingBottom = false;
                this.scrollbarXTop = toInt(railXStyle.top);
            } else {
                this.isScrollbarXUsingBottom = true;
            }
            this.railBorderXWidth = toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
            set(this.scrollbarXRail, {
                display: "block"
            });
            this.railXMarginWidth = toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
            set(this.scrollbarXRail, {
                display: ""
            });
            this.railXWidth = null;
            this.railXRatio = null;
            this.scrollbarYRail = div(cls.element.rail("y"));
            element.appendChild(this.scrollbarYRail);
            this.scrollbarY = div(cls.element.thumb("y"));
            this.scrollbarYRail.appendChild(this.scrollbarY);
            this.scrollbarY.setAttribute("tabindex", 0);
            this.event.bind(this.scrollbarY, "focus", focus);
            this.event.bind(this.scrollbarY, "blur", blur);
            this.scrollbarYActive = null;
            this.scrollbarYHeight = null;
            this.scrollbarYTop = null;
            var railYStyle = get(this.scrollbarYRail);
            this.scrollbarYRight = parseInt(railYStyle.right, 10);
            if (isNaN(this.scrollbarYRight)) {
                this.isScrollbarYUsingRight = false;
                this.scrollbarYLeft = toInt(railYStyle.left);
            } else {
                this.isScrollbarYUsingRight = true;
            }
            this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
            this.railBorderYWidth = toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
            set(this.scrollbarYRail, {
                display: "block"
            });
            this.railYMarginHeight = toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
            set(this.scrollbarYRail, {
                display: ""
            });
            this.railYHeight = null;
            this.railYRatio = null;
            this.reach = {
                x: element.scrollLeft <= 0 ? "start" : element.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
                y: element.scrollTop <= 0 ? "start" : element.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
            };
            this.isAlive = true;
            this.settings.handlers.forEach(function(handlerName) {
                return handlers[handlerName](this$1);
            });
            this.lastScrollTop = Math.floor(element.scrollTop);
            this.lastScrollLeft = element.scrollLeft;
            this.event.bind(this.element, "scroll", function(e) {
                return this$1.onScroll(e);
            });
            updateGeometry(this);
        };
        PerfectScrollbar.prototype.update = function update() {
            if (!this.isAlive) {
                return;
            }
            this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0;
            set(this.scrollbarXRail, {
                display: "block"
            });
            set(this.scrollbarYRail, {
                display: "block"
            });
            this.railXMarginWidth = toInt(get(this.scrollbarXRail).marginLeft) + toInt(get(this.scrollbarXRail).marginRight);
            this.railYMarginHeight = toInt(get(this.scrollbarYRail).marginTop) + toInt(get(this.scrollbarYRail).marginBottom);
            set(this.scrollbarXRail, {
                display: "none"
            });
            set(this.scrollbarYRail, {
                display: "none"
            });
            updateGeometry(this);
            processScrollDiff(this, "top", 0, false, true);
            processScrollDiff(this, "left", 0, false, true);
            set(this.scrollbarXRail, {
                display: ""
            });
            set(this.scrollbarYRail, {
                display: ""
            });
        };
        PerfectScrollbar.prototype.onScroll = function onScroll(e) {
            if (!this.isAlive) {
                return;
            }
            updateGeometry(this);
            processScrollDiff(this, "top", this.element.scrollTop - this.lastScrollTop);
            processScrollDiff(this, "left", this.element.scrollLeft - this.lastScrollLeft);
            this.lastScrollTop = Math.floor(this.element.scrollTop);
            this.lastScrollLeft = this.element.scrollLeft;
        };
        PerfectScrollbar.prototype.destroy = function destroy() {
            if (!this.isAlive) {
                return;
            }
            this.event.unbindAll();
            remove(this.scrollbarX);
            remove(this.scrollbarY);
            remove(this.scrollbarXRail);
            remove(this.scrollbarYRail);
            this.removePsClasses();
            this.element = null;
            this.scrollbarX = null;
            this.scrollbarY = null;
            this.scrollbarXRail = null;
            this.scrollbarYRail = null;
            this.isAlive = false;
        };
        PerfectScrollbar.prototype.removePsClasses = function removePsClasses() {
            this.element.className = this.element.className.split(" ").filter(function(name) {
                return !name.match(/^ps([-_].+|)$/);
            }).join(" ");
        };
        module.exports = PerfectScrollbar;
    }, {} ],
    26: [ function(require, module, exports) {
        var process = module.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        (function() {
            try {
                if (typeof setTimeout === "function") {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                if (typeof clearTimeout === "function") {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        })();
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }
            try {
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }
            try {
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }
        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        };
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {}
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name) {
            return [];
        };
        process.binding = function(name) {
            throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
            return "/";
        };
        process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
            return 0;
        };
    }, {} ],
    27: [ function(require, module, exports) {
        (function(global) {
            (function(global, factory) {
                typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require("react"), require("react-dom")) : typeof define === "function" && define.amd ? define([ "react", "react-dom" ], factory) : global.ReactAwesomePopover = factory(global.React, global.ReactDOM);
            })(this, function(React, ReactDOM) {
                "use strict";
                React = React && React.hasOwnProperty("default") ? React["default"] : React;
                ReactDOM = ReactDOM && ReactDOM.hasOwnProperty("default") ? ReactDOM["default"] : ReactDOM;
                function commonjsRequire() {
                    throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
                }
                function unwrapExports(x) {
                    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
                }
                function createCommonjsModule(fn, module) {
                    return module = {
                        exports: {}
                    }, fn(module, module.exports), module.exports;
                }
                "use strict";
                function makeEmptyFunction(arg) {
                    return function() {
                        return arg;
                    };
                }
                var emptyFunction = function emptyFunction() {};
                emptyFunction.thatReturns = makeEmptyFunction;
                emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
                emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
                emptyFunction.thatReturnsNull = makeEmptyFunction(null);
                emptyFunction.thatReturnsThis = function() {
                    return this;
                };
                emptyFunction.thatReturnsArgument = function(arg) {
                    return arg;
                };
                var emptyFunction_1 = emptyFunction;
                "use strict";
                function invariant(condition, format, a, b, c, d, e, f) {
                    if (!condition) {
                        var error;
                        if (format === undefined) {
                            error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
                        } else {
                            var args = [ a, b, c, d, e, f ];
                            var argIndex = 0;
                            error = new Error(format.replace(/%s/g, function() {
                                return args[argIndex++];
                            }));
                            error.name = "Invariant Violation";
                        }
                        error.framesToPop = 1;
                        throw error;
                    }
                }
                var invariant_1 = invariant;
                "use strict";
                var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
                var ReactPropTypesSecret_1 = ReactPropTypesSecret;
                "use strict";
                var factoryWithThrowingShims = function() {
                    function shim(props, propName, componentName, location, propFullName, secret) {
                        if (secret === ReactPropTypesSecret_1) {
                            return;
                        }
                        invariant_1(false, "Calling PropTypes validators directly is not supported by the `prop-types` package. " + "Use PropTypes.checkPropTypes() to call them. " + "Read more at http://fb.me/use-check-prop-types");
                    }
                    shim.isRequired = shim;
                    function getShim() {
                        return shim;
                    }
                    var ReactPropTypes = {
                        array: shim,
                        bool: shim,
                        func: shim,
                        number: shim,
                        object: shim,
                        string: shim,
                        symbol: shim,
                        any: shim,
                        arrayOf: getShim,
                        element: shim,
                        instanceOf: getShim,
                        node: shim,
                        objectOf: getShim,
                        oneOf: getShim,
                        oneOfType: getShim,
                        shape: getShim,
                        exact: getShim
                    };
                    ReactPropTypes.checkPropTypes = emptyFunction_1;
                    ReactPropTypes.PropTypes = ReactPropTypes;
                    return ReactPropTypes;
                };
                var propTypes = createCommonjsModule(function(module) {
                    {
                        module.exports = factoryWithThrowingShims();
                    }
                });
                var Manager_1 = createCommonjsModule(function(module, exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    var _createClass = function() {
                        function defineProperties(target, props) {
                            for (var i = 0; i < props.length; i++) {
                                var descriptor = props[i];
                                descriptor.enumerable = descriptor.enumerable || false;
                                descriptor.configurable = true;
                                if ("value" in descriptor) descriptor.writable = true;
                                Object.defineProperty(target, descriptor.key, descriptor);
                            }
                        }
                        return function(Constructor, protoProps, staticProps) {
                            if (protoProps) defineProperties(Constructor.prototype, protoProps);
                            if (staticProps) defineProperties(Constructor, staticProps);
                            return Constructor;
                        };
                    }();
                    var _react2 = _interopRequireDefault(React);
                    var _propTypes2 = _interopRequireDefault(propTypes);
                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        };
                    }
                    function _objectWithoutProperties(obj, keys) {
                        var target = {};
                        for (var i in obj) {
                            if (keys.indexOf(i) >= 0) continue;
                            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
                            target[i] = obj[i];
                        }
                        return target;
                    }
                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError("Cannot call a class as a function");
                        }
                    }
                    function _possibleConstructorReturn(self, call) {
                        if (!self) {
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        }
                        return call && (typeof call === "object" || typeof call === "function") ? call : self;
                    }
                    function _inherits(subClass, superClass) {
                        if (typeof superClass !== "function" && superClass !== null) {
                            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                        }
                        subClass.prototype = Object.create(superClass && superClass.prototype, {
                            constructor: {
                                value: subClass,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                    }
                    var Manager = function(_Component) {
                        _inherits(Manager, _Component);
                        function Manager() {
                            var _ref;
                            var _temp, _this, _ret;
                            _classCallCheck(this, Manager);
                            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }
                            return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Manager.__proto__ || Object.getPrototypeOf(Manager)).call.apply(_ref, [ this ].concat(args))), 
                            _this), _this._setTargetNode = function(node) {
                                _this._targetNode = node;
                            }, _this._getTargetNode = function() {
                                return _this._targetNode;
                            }, _temp), _possibleConstructorReturn(_this, _ret);
                        }
                        _createClass(Manager, [ {
                            key: "getChildContext",
                            value: function getChildContext() {
                                return {
                                    popperManager: {
                                        setTargetNode: this._setTargetNode,
                                        getTargetNode: this._getTargetNode
                                    }
                                };
                            }
                        }, {
                            key: "render",
                            value: function render() {
                                var _props = this.props, tag = _props.tag, children = _props.children, restProps = _objectWithoutProperties(_props, [ "tag", "children" ]);
                                if (tag !== false) {
                                    return (0, React.createElement)(tag, restProps, children);
                                } else {
                                    return children;
                                }
                            }
                        } ]);
                        return Manager;
                    }(React.Component);
                    Manager.childContextTypes = {
                        popperManager: _propTypes2.default.object.isRequired
                    };
                    Manager.propTypes = {
                        tag: _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.bool ])
                    };
                    Manager.defaultProps = {
                        tag: "div"
                    };
                    exports.default = Manager;
                });
                unwrapExports(Manager_1);
                var Target_1 = createCommonjsModule(function(module, exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    var _extends = Object.assign || function(target) {
                        for (var i = 1; i < arguments.length; i++) {
                            var source = arguments[i];
                            for (var key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    target[key] = source[key];
                                }
                            }
                        }
                        return target;
                    };
                    var _react2 = _interopRequireDefault(React);
                    var _propTypes2 = _interopRequireDefault(propTypes);
                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        };
                    }
                    function _objectWithoutProperties(obj, keys) {
                        var target = {};
                        for (var i in obj) {
                            if (keys.indexOf(i) >= 0) continue;
                            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
                            target[i] = obj[i];
                        }
                        return target;
                    }
                    var Target = function Target(props, context) {
                        var _props$component = props.component, component = _props$component === undefined ? "div" : _props$component, innerRef = props.innerRef, children = props.children, restProps = _objectWithoutProperties(props, [ "component", "innerRef", "children" ]);
                        var popperManager = context.popperManager;
                        var targetRef = function targetRef(node) {
                            popperManager.setTargetNode(node);
                            if (typeof innerRef === "function") {
                                innerRef(node);
                            }
                        };
                        if (typeof children === "function") {
                            var targetProps = {
                                ref: targetRef
                            };
                            return children({
                                targetProps: targetProps,
                                restProps: restProps
                            });
                        }
                        var componentProps = _extends({}, restProps);
                        if (typeof component === "string") {
                            componentProps.ref = targetRef;
                        } else {
                            componentProps.innerRef = targetRef;
                        }
                        return (0, React.createElement)(component, componentProps, children);
                    };
                    Target.contextTypes = {
                        popperManager: _propTypes2.default.object.isRequired
                    };
                    Target.propTypes = {
                        component: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ]),
                        innerRef: _propTypes2.default.func,
                        children: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ])
                    };
                    exports.default = Target;
                });
                unwrapExports(Target_1);
                var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
                var longerTimeoutBrowsers = [ "Edge", "Trident", "Firefox" ];
                var timeoutDuration = 0;
                for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
                    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
                        timeoutDuration = 1;
                        break;
                    }
                }
                function microtaskDebounce(fn) {
                    var called = false;
                    return function() {
                        if (called) {
                            return;
                        }
                        called = true;
                        Promise.resolve().then(function() {
                            called = false;
                            fn();
                        });
                    };
                }
                function taskDebounce(fn) {
                    var scheduled = false;
                    return function() {
                        if (!scheduled) {
                            scheduled = true;
                            setTimeout(function() {
                                scheduled = false;
                                fn();
                            }, timeoutDuration);
                        }
                    };
                }
                var supportsMicroTasks = isBrowser && window.Promise;
                var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
                function isFunction(functionToCheck) {
                    var getType = {};
                    return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
                }
                function getStyleComputedProperty(element, property) {
                    if (element.nodeType !== 1) {
                        return [];
                    }
                    var css = window.getComputedStyle(element, null);
                    return property ? css[property] : css;
                }
                function getParentNode(element) {
                    if (element.nodeName === "HTML") {
                        return element;
                    }
                    return element.parentNode || element.host;
                }
                function getScrollParent(element) {
                    if (!element) {
                        return window.document.body;
                    }
                    switch (element.nodeName) {
                      case "HTML":
                      case "BODY":
                        return element.ownerDocument.body;

                      case "#document":
                        return element.body;
                    }
                    var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
                    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
                        return element;
                    }
                    return getScrollParent(getParentNode(element));
                }
                function getOffsetParent(element) {
                    var offsetParent = element && element.offsetParent;
                    var nodeName = offsetParent && offsetParent.nodeName;
                    if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
                        if (element) {
                            return element.ownerDocument.documentElement;
                        }
                        return window.document.documentElement;
                    }
                    if ([ "TD", "TABLE" ].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
                        return getOffsetParent(offsetParent);
                    }
                    return offsetParent;
                }
                function isOffsetContainer(element) {
                    var nodeName = element.nodeName;
                    if (nodeName === "BODY") {
                        return false;
                    }
                    return nodeName === "HTML" || getOffsetParent(element.firstElementChild) === element;
                }
                function getRoot(node) {
                    if (node.parentNode !== null) {
                        return getRoot(node.parentNode);
                    }
                    return node;
                }
                function findCommonOffsetParent(element1, element2) {
                    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
                        return window.document.documentElement;
                    }
                    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
                    var start = order ? element1 : element2;
                    var end = order ? element2 : element1;
                    var range = document.createRange();
                    range.setStart(start, 0);
                    range.setEnd(end, 0);
                    var commonAncestorContainer = range.commonAncestorContainer;
                    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
                        if (isOffsetContainer(commonAncestorContainer)) {
                            return commonAncestorContainer;
                        }
                        return getOffsetParent(commonAncestorContainer);
                    }
                    var element1root = getRoot(element1);
                    if (element1root.host) {
                        return findCommonOffsetParent(element1root.host, element2);
                    } else {
                        return findCommonOffsetParent(element1, getRoot(element2).host);
                    }
                }
                function getScroll(element) {
                    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "top";
                    var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
                    var nodeName = element.nodeName;
                    if (nodeName === "BODY" || nodeName === "HTML") {
                        var html = element.ownerDocument.documentElement;
                        var scrollingElement = element.ownerDocument.scrollingElement || html;
                        return scrollingElement[upperSide];
                    }
                    return element[upperSide];
                }
                function includeScroll(rect, element) {
                    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                    var scrollTop = getScroll(element, "top");
                    var scrollLeft = getScroll(element, "left");
                    var modifier = subtract ? -1 : 1;
                    rect.top += scrollTop * modifier;
                    rect.bottom += scrollTop * modifier;
                    rect.left += scrollLeft * modifier;
                    rect.right += scrollLeft * modifier;
                    return rect;
                }
                function getBordersSize(styles, axis) {
                    var sideA = axis === "x" ? "Left" : "Top";
                    var sideB = sideA === "Left" ? "Right" : "Bottom";
                    return +styles["border" + sideA + "Width"].split("px")[0] + +styles["border" + sideB + "Width"].split("px")[0];
                }
                var isIE10 = undefined;
                var isIE10$1 = function() {
                    if (isIE10 === undefined) {
                        isIE10 = navigator.appVersion.indexOf("MSIE 10") !== -1;
                    }
                    return isIE10;
                };
                function getSize(axis, body, html, computedStyle) {
                    return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE10$1() ? html["offset" + axis] + computedStyle["margin" + (axis === "Height" ? "Top" : "Left")] + computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")] : 0);
                }
                function getWindowSizes() {
                    var body = window.document.body;
                    var html = window.document.documentElement;
                    var computedStyle = isIE10$1() && window.getComputedStyle(html);
                    return {
                        height: getSize("Height", body, html, computedStyle),
                        width: getSize("Width", body, html, computedStyle)
                    };
                }
                var classCallCheck = function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                };
                var createClass = function() {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();
                var defineProperty = function(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                };
                var _extends = Object.assign || function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) {
                            if (Object.prototype.hasOwnProperty.call(source, key)) {
                                target[key] = source[key];
                            }
                        }
                    }
                    return target;
                };
                function getClientRect(offsets) {
                    return _extends({}, offsets, {
                        right: offsets.left + offsets.width,
                        bottom: offsets.top + offsets.height
                    });
                }
                function getBoundingClientRect(element) {
                    var rect = {};
                    if (isIE10$1()) {
                        try {
                            rect = element.getBoundingClientRect();
                            var scrollTop = getScroll(element, "top");
                            var scrollLeft = getScroll(element, "left");
                            rect.top += scrollTop;
                            rect.left += scrollLeft;
                            rect.bottom += scrollTop;
                            rect.right += scrollLeft;
                        } catch (err) {}
                    } else {
                        rect = element.getBoundingClientRect();
                    }
                    var result = {
                        left: rect.left,
                        top: rect.top,
                        width: rect.right - rect.left,
                        height: rect.bottom - rect.top
                    };
                    var sizes = element.nodeName === "HTML" ? getWindowSizes() : {};
                    var width = sizes.width || element.clientWidth || result.right - result.left;
                    var height = sizes.height || element.clientHeight || result.bottom - result.top;
                    var horizScrollbar = element.offsetWidth - width;
                    var vertScrollbar = element.offsetHeight - height;
                    if (horizScrollbar || vertScrollbar) {
                        var styles = getStyleComputedProperty(element);
                        horizScrollbar -= getBordersSize(styles, "x");
                        vertScrollbar -= getBordersSize(styles, "y");
                        result.width -= horizScrollbar;
                        result.height -= vertScrollbar;
                    }
                    return getClientRect(result);
                }
                function getOffsetRectRelativeToArbitraryNode(children, parent) {
                    var isIE10 = isIE10$1();
                    var isHTML = parent.nodeName === "HTML";
                    var childrenRect = getBoundingClientRect(children);
                    var parentRect = getBoundingClientRect(parent);
                    var scrollParent = getScrollParent(children);
                    var styles = getStyleComputedProperty(parent);
                    var borderTopWidth = +styles.borderTopWidth.split("px")[0];
                    var borderLeftWidth = +styles.borderLeftWidth.split("px")[0];
                    var offsets = getClientRect({
                        top: childrenRect.top - parentRect.top - borderTopWidth,
                        left: childrenRect.left - parentRect.left - borderLeftWidth,
                        width: childrenRect.width,
                        height: childrenRect.height
                    });
                    offsets.marginTop = 0;
                    offsets.marginLeft = 0;
                    if (!isIE10 && isHTML) {
                        var marginTop = +styles.marginTop.split("px")[0];
                        var marginLeft = +styles.marginLeft.split("px")[0];
                        offsets.top -= borderTopWidth - marginTop;
                        offsets.bottom -= borderTopWidth - marginTop;
                        offsets.left -= borderLeftWidth - marginLeft;
                        offsets.right -= borderLeftWidth - marginLeft;
                        offsets.marginTop = marginTop;
                        offsets.marginLeft = marginLeft;
                    }
                    if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== "BODY") {
                        offsets = includeScroll(offsets, parent);
                    }
                    return offsets;
                }
                function getViewportOffsetRectRelativeToArtbitraryNode(element) {
                    var html = element.ownerDocument.documentElement;
                    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
                    var width = Math.max(html.clientWidth, window.innerWidth || 0);
                    var height = Math.max(html.clientHeight, window.innerHeight || 0);
                    var scrollTop = getScroll(html);
                    var scrollLeft = getScroll(html, "left");
                    var offset = {
                        top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
                        left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
                        width: width,
                        height: height
                    };
                    return getClientRect(offset);
                }
                function isFixed(element) {
                    var nodeName = element.nodeName;
                    if (nodeName === "BODY" || nodeName === "HTML") {
                        return false;
                    }
                    if (getStyleComputedProperty(element, "position") === "fixed") {
                        return true;
                    }
                    return isFixed(getParentNode(element));
                }
                function getBoundaries(popper, reference, padding, boundariesElement) {
                    var boundaries = {
                        top: 0,
                        left: 0
                    };
                    var offsetParent = findCommonOffsetParent(popper, reference);
                    if (boundariesElement === "viewport") {
                        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
                    } else {
                        var boundariesNode = void 0;
                        if (boundariesElement === "scrollParent") {
                            boundariesNode = getScrollParent(getParentNode(reference));
                            if (boundariesNode.nodeName === "BODY") {
                                boundariesNode = popper.ownerDocument.documentElement;
                            }
                        } else if (boundariesElement === "window") {
                            boundariesNode = popper.ownerDocument.documentElement;
                        } else {
                            boundariesNode = boundariesElement;
                        }
                        var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);
                        if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
                            var _getWindowSizes = getWindowSizes(), height = _getWindowSizes.height, width = _getWindowSizes.width;
                            boundaries.top += offsets.top - offsets.marginTop;
                            boundaries.bottom = height + offsets.top;
                            boundaries.left += offsets.left - offsets.marginLeft;
                            boundaries.right = width + offsets.left;
                        } else {
                            boundaries = offsets;
                        }
                    }
                    boundaries.left += padding;
                    boundaries.top += padding;
                    boundaries.right -= padding;
                    boundaries.bottom -= padding;
                    return boundaries;
                }
                function getArea(_ref) {
                    var width = _ref.width, height = _ref.height;
                    return width * height;
                }
                function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
                    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
                    if (placement.indexOf("auto") === -1) {
                        return placement;
                    }
                    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
                    var rects = {
                        top: {
                            width: boundaries.width,
                            height: refRect.top - boundaries.top
                        },
                        right: {
                            width: boundaries.right - refRect.right,
                            height: boundaries.height
                        },
                        bottom: {
                            width: boundaries.width,
                            height: boundaries.bottom - refRect.bottom
                        },
                        left: {
                            width: refRect.left - boundaries.left,
                            height: boundaries.height
                        }
                    };
                    var sortedAreas = Object.keys(rects).map(function(key) {
                        return _extends({
                            key: key
                        }, rects[key], {
                            area: getArea(rects[key])
                        });
                    }).sort(function(a, b) {
                        return b.area - a.area;
                    });
                    var filteredAreas = sortedAreas.filter(function(_ref2) {
                        var width = _ref2.width, height = _ref2.height;
                        return width >= popper.clientWidth && height >= popper.clientHeight;
                    });
                    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
                    var variation = placement.split("-")[1];
                    return computedPlacement + (variation ? "-" + variation : "");
                }
                function getReferenceOffsets(state, popper, reference) {
                    var commonOffsetParent = findCommonOffsetParent(popper, reference);
                    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
                }
                function getOuterSizes(element) {
                    var styles = window.getComputedStyle(element);
                    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
                    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
                    var result = {
                        width: element.offsetWidth + y,
                        height: element.offsetHeight + x
                    };
                    return result;
                }
                function getOppositePlacement(placement) {
                    var hash = {
                        left: "right",
                        right: "left",
                        bottom: "top",
                        top: "bottom"
                    };
                    return placement.replace(/left|right|bottom|top/g, function(matched) {
                        return hash[matched];
                    });
                }
                function getPopperOffsets(popper, referenceOffsets, placement) {
                    placement = placement.split("-")[0];
                    var popperRect = getOuterSizes(popper);
                    var popperOffsets = {
                        width: popperRect.width,
                        height: popperRect.height
                    };
                    var isHoriz = [ "right", "left" ].indexOf(placement) !== -1;
                    var mainSide = isHoriz ? "top" : "left";
                    var secondarySide = isHoriz ? "left" : "top";
                    var measurement = isHoriz ? "height" : "width";
                    var secondaryMeasurement = !isHoriz ? "height" : "width";
                    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
                    if (placement === secondarySide) {
                        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
                    } else {
                        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
                    }
                    return popperOffsets;
                }
                function find(arr, check) {
                    if (Array.prototype.find) {
                        return arr.find(check);
                    }
                    return arr.filter(check)[0];
                }
                function findIndex(arr, prop, value) {
                    if (Array.prototype.findIndex) {
                        return arr.findIndex(function(cur) {
                            return cur[prop] === value;
                        });
                    }
                    var match = find(arr, function(obj) {
                        return obj[prop] === value;
                    });
                    return arr.indexOf(match);
                }
                function runModifiers(modifiers, data, ends) {
                    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, "name", ends));
                    modifiersToRun.forEach(function(modifier) {
                        if (modifier["function"]) {
                            console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
                        }
                        var fn = modifier["function"] || modifier.fn;
                        if (modifier.enabled && isFunction(fn)) {
                            data.offsets.popper = getClientRect(data.offsets.popper);
                            data.offsets.reference = getClientRect(data.offsets.reference);
                            data = fn(data, modifier);
                        }
                    });
                    return data;
                }
                function update() {
                    if (this.state.isDestroyed) {
                        return;
                    }
                    var data = {
                        instance: this,
                        styles: {},
                        arrowStyles: {},
                        attributes: {},
                        flipped: false,
                        offsets: {}
                    };
                    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);
                    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
                    data.originalPlacement = data.placement;
                    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
                    data.offsets.popper.position = "absolute";
                    data = runModifiers(this.modifiers, data);
                    if (!this.state.isCreated) {
                        this.state.isCreated = true;
                        this.options.onCreate(data);
                    } else {
                        this.options.onUpdate(data);
                    }
                }
                function isModifierEnabled(modifiers, modifierName) {
                    return modifiers.some(function(_ref) {
                        var name = _ref.name, enabled = _ref.enabled;
                        return enabled && name === modifierName;
                    });
                }
                function getSupportedPropertyName(property) {
                    var prefixes = [ false, "ms", "Webkit", "Moz", "O" ];
                    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
                    for (var i = 0; i < prefixes.length - 1; i++) {
                        var prefix = prefixes[i];
                        var toCheck = prefix ? "" + prefix + upperProp : property;
                        if (typeof window.document.body.style[toCheck] !== "undefined") {
                            return toCheck;
                        }
                    }
                    return null;
                }
                function destroy() {
                    this.state.isDestroyed = true;
                    if (isModifierEnabled(this.modifiers, "applyStyle")) {
                        this.popper.removeAttribute("x-placement");
                        this.popper.style.left = "";
                        this.popper.style.position = "";
                        this.popper.style.top = "";
                        this.popper.style[getSupportedPropertyName("transform")] = "";
                    }
                    this.disableEventListeners();
                    if (this.options.removeOnDestroy) {
                        this.popper.parentNode.removeChild(this.popper);
                    }
                    return this;
                }
                function getWindow(element) {
                    var ownerDocument = element.ownerDocument;
                    return ownerDocument ? ownerDocument.defaultView : window;
                }
                function attachToScrollParents(scrollParent, event, callback, scrollParents) {
                    var isBody = scrollParent.nodeName === "BODY";
                    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
                    target.addEventListener(event, callback, {
                        passive: true
                    });
                    if (!isBody) {
                        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
                    }
                    scrollParents.push(target);
                }
                function setupEventListeners(reference, options, state, updateBound) {
                    state.updateBound = updateBound;
                    getWindow(reference).addEventListener("resize", state.updateBound, {
                        passive: true
                    });
                    var scrollElement = getScrollParent(reference);
                    attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
                    state.scrollElement = scrollElement;
                    state.eventsEnabled = true;
                    return state;
                }
                function enableEventListeners() {
                    if (!this.state.eventsEnabled) {
                        this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
                    }
                }
                function removeEventListeners(reference, state) {
                    getWindow(reference).removeEventListener("resize", state.updateBound);
                    state.scrollParents.forEach(function(target) {
                        target.removeEventListener("scroll", state.updateBound);
                    });
                    state.updateBound = null;
                    state.scrollParents = [];
                    state.scrollElement = null;
                    state.eventsEnabled = false;
                    return state;
                }
                function disableEventListeners() {
                    if (this.state.eventsEnabled) {
                        window.cancelAnimationFrame(this.scheduleUpdate);
                        this.state = removeEventListeners(this.reference, this.state);
                    }
                }
                function isNumeric(n) {
                    return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
                }
                function setStyles(element, styles) {
                    Object.keys(styles).forEach(function(prop) {
                        var unit = "";
                        if ([ "width", "height", "top", "right", "bottom", "left" ].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
                            unit = "px";
                        }
                        element.style[prop] = styles[prop] + unit;
                    });
                }
                function setAttributes(element, attributes) {
                    Object.keys(attributes).forEach(function(prop) {
                        var value = attributes[prop];
                        if (value !== false) {
                            element.setAttribute(prop, attributes[prop]);
                        } else {
                            element.removeAttribute(prop);
                        }
                    });
                }
                function applyStyle(data) {
                    setStyles(data.instance.popper, data.styles);
                    setAttributes(data.instance.popper, data.attributes);
                    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
                        setStyles(data.arrowElement, data.arrowStyles);
                    }
                    return data;
                }
                function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
                    var referenceOffsets = getReferenceOffsets(state, popper, reference);
                    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
                    popper.setAttribute("x-placement", placement);
                    setStyles(popper, {
                        position: "absolute"
                    });
                    return options;
                }
                function computeStyle(data, options) {
                    var x = options.x, y = options.y;
                    var popper = data.offsets.popper;
                    var legacyGpuAccelerationOption = find(data.instance.modifiers, function(modifier) {
                        return modifier.name === "applyStyle";
                    }).gpuAcceleration;
                    if (legacyGpuAccelerationOption !== undefined) {
                        console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
                    }
                    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
                    var offsetParent = getOffsetParent(data.instance.popper);
                    var offsetParentRect = getBoundingClientRect(offsetParent);
                    var styles = {
                        position: popper.position
                    };
                    var offsets = {
                        left: Math.floor(popper.left),
                        top: Math.floor(popper.top),
                        bottom: Math.floor(popper.bottom),
                        right: Math.floor(popper.right)
                    };
                    var sideA = x === "bottom" ? "top" : "bottom";
                    var sideB = y === "right" ? "left" : "right";
                    var prefixedProperty = getSupportedPropertyName("transform");
                    var left = void 0, top = void 0;
                    if (sideA === "bottom") {
                        top = -offsetParentRect.height + offsets.bottom;
                    } else {
                        top = offsets.top;
                    }
                    if (sideB === "right") {
                        left = -offsetParentRect.width + offsets.right;
                    } else {
                        left = offsets.left;
                    }
                    if (gpuAcceleration && prefixedProperty) {
                        styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
                        styles[sideA] = 0;
                        styles[sideB] = 0;
                        styles.willChange = "transform";
                    } else {
                        var invertTop = sideA === "bottom" ? -1 : 1;
                        var invertLeft = sideB === "right" ? -1 : 1;
                        styles[sideA] = top * invertTop;
                        styles[sideB] = left * invertLeft;
                        styles.willChange = sideA + ", " + sideB;
                    }
                    var attributes = {
                        "x-placement": data.placement
                    };
                    data.attributes = _extends({}, attributes, data.attributes);
                    data.styles = _extends({}, styles, data.styles);
                    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
                    return data;
                }
                function isModifierRequired(modifiers, requestingName, requestedName) {
                    var requesting = find(modifiers, function(_ref) {
                        var name = _ref.name;
                        return name === requestingName;
                    });
                    var isRequired = !!requesting && modifiers.some(function(modifier) {
                        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
                    });
                    if (!isRequired) {
                        var _requesting = "`" + requestingName + "`";
                        var requested = "`" + requestedName + "`";
                        console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
                    }
                    return isRequired;
                }
                function arrow(data, options) {
                    if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
                        return data;
                    }
                    var arrowElement = options.element;
                    if (typeof arrowElement === "string") {
                        arrowElement = data.instance.popper.querySelector(arrowElement);
                        if (!arrowElement) {
                            return data;
                        }
                    } else {
                        if (!data.instance.popper.contains(arrowElement)) {
                            console.warn("WARNING: `arrow.element` must be child of its popper element!");
                            return data;
                        }
                    }
                    var placement = data.placement.split("-")[0];
                    var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                    var isVertical = [ "left", "right" ].indexOf(placement) !== -1;
                    var len = isVertical ? "height" : "width";
                    var sideCapitalized = isVertical ? "Top" : "Left";
                    var side = sideCapitalized.toLowerCase();
                    var altSide = isVertical ? "left" : "top";
                    var opSide = isVertical ? "bottom" : "right";
                    var arrowElementSize = getOuterSizes(arrowElement)[len];
                    if (reference[opSide] - arrowElementSize < popper[side]) {
                        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
                    }
                    if (reference[side] + arrowElementSize > popper[opSide]) {
                        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
                    }
                    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
                    var popperMarginSide = getStyleComputedProperty(data.instance.popper, "margin" + sideCapitalized).replace("px", "");
                    var sideValue = center - getClientRect(data.offsets.popper)[side] - popperMarginSide;
                    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
                    data.arrowElement = arrowElement;
                    data.offsets.arrow = {};
                    data.offsets.arrow[side] = Math.round(sideValue);
                    data.offsets.arrow[altSide] = "";
                    return data;
                }
                function getOppositeVariation(variation) {
                    if (variation === "end") {
                        return "start";
                    } else if (variation === "start") {
                        return "end";
                    }
                    return variation;
                }
                var placements = [ "auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start" ];
                var validPlacements = placements.slice(3);
                function clockwise(placement) {
                    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                    var index = validPlacements.indexOf(placement);
                    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
                    return counter ? arr.reverse() : arr;
                }
                var BEHAVIORS = {
                    FLIP: "flip",
                    CLOCKWISE: "clockwise",
                    COUNTERCLOCKWISE: "counterclockwise"
                };
                function flip(data, options) {
                    if (isModifierEnabled(data.instance.modifiers, "inner")) {
                        return data;
                    }
                    if (data.flipped && data.placement === data.originalPlacement) {
                        return data;
                    }
                    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);
                    var placement = data.placement.split("-")[0];
                    var placementOpposite = getOppositePlacement(placement);
                    var variation = data.placement.split("-")[1] || "";
                    var flipOrder = [];
                    switch (options.behavior) {
                      case BEHAVIORS.FLIP:
                        flipOrder = [ placement, placementOpposite ];
                        break;

                      case BEHAVIORS.CLOCKWISE:
                        flipOrder = clockwise(placement);
                        break;

                      case BEHAVIORS.COUNTERCLOCKWISE:
                        flipOrder = clockwise(placement, true);
                        break;

                      default:
                        flipOrder = options.behavior;
                    }
                    flipOrder.forEach(function(step, index) {
                        if (placement !== step || flipOrder.length === index + 1) {
                            return data;
                        }
                        placement = data.placement.split("-")[0];
                        placementOpposite = getOppositePlacement(placement);
                        var popperOffsets = data.offsets.popper;
                        var refOffsets = data.offsets.reference;
                        var floor = Math.floor;
                        var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
                        var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
                        var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
                        var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
                        var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
                        var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
                        var isVertical = [ "top", "bottom" ].indexOf(placement) !== -1;
                        var flippedVariation = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
                        if (overlapsRef || overflowsBoundaries || flippedVariation) {
                            data.flipped = true;
                            if (overlapsRef || overflowsBoundaries) {
                                placement = flipOrder[index + 1];
                            }
                            if (flippedVariation) {
                                variation = getOppositeVariation(variation);
                            }
                            data.placement = placement + (variation ? "-" + variation : "");
                            data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
                            data = runModifiers(data.instance.modifiers, data, "flip");
                        }
                    });
                    return data;
                }
                function keepTogether(data) {
                    var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                    var placement = data.placement.split("-")[0];
                    var floor = Math.floor;
                    var isVertical = [ "top", "bottom" ].indexOf(placement) !== -1;
                    var side = isVertical ? "right" : "bottom";
                    var opSide = isVertical ? "left" : "top";
                    var measurement = isVertical ? "width" : "height";
                    if (popper[side] < floor(reference[opSide])) {
                        data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
                    }
                    if (popper[opSide] > floor(reference[side])) {
                        data.offsets.popper[opSide] = floor(reference[side]);
                    }
                    return data;
                }
                function toValue(str, measurement, popperOffsets, referenceOffsets) {
                    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
                    var value = +split[1];
                    var unit = split[2];
                    if (!value) {
                        return str;
                    }
                    if (unit.indexOf("%") === 0) {
                        var element = void 0;
                        switch (unit) {
                          case "%p":
                            element = popperOffsets;
                            break;

                          case "%":
                          case "%r":
                          default:
                            element = referenceOffsets;
                        }
                        var rect = getClientRect(element);
                        return rect[measurement] / 100 * value;
                    } else if (unit === "vh" || unit === "vw") {
                        var size = void 0;
                        if (unit === "vh") {
                            size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                        } else {
                            size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                        }
                        return size / 100 * value;
                    } else {
                        return value;
                    }
                }
                function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
                    var offsets = [ 0, 0 ];
                    var useHeight = [ "right", "left" ].indexOf(basePlacement) !== -1;
                    var fragments = offset.split(/(\+|\-)/).map(function(frag) {
                        return frag.trim();
                    });
                    var divider = fragments.indexOf(find(fragments, function(frag) {
                        return frag.search(/,|\s/) !== -1;
                    }));
                    if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
                        console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
                    }
                    var splitRegex = /\s*,\s*|\s+/;
                    var ops = divider !== -1 ? [ fragments.slice(0, divider).concat([ fragments[divider].split(splitRegex)[0] ]), [ fragments[divider].split(splitRegex)[1] ].concat(fragments.slice(divider + 1)) ] : [ fragments ];
                    ops = ops.map(function(op, index) {
                        var measurement = (index === 1 ? !useHeight : useHeight) ? "height" : "width";
                        var mergeWithPrevious = false;
                        return op.reduce(function(a, b) {
                            if (a[a.length - 1] === "" && [ "+", "-" ].indexOf(b) !== -1) {
                                a[a.length - 1] = b;
                                mergeWithPrevious = true;
                                return a;
                            } else if (mergeWithPrevious) {
                                a[a.length - 1] += b;
                                mergeWithPrevious = false;
                                return a;
                            } else {
                                return a.concat(b);
                            }
                        }, []).map(function(str) {
                            return toValue(str, measurement, popperOffsets, referenceOffsets);
                        });
                    });
                    ops.forEach(function(op, index) {
                        op.forEach(function(frag, index2) {
                            if (isNumeric(frag)) {
                                offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1);
                            }
                        });
                    });
                    return offsets;
                }
                function offset(data, _ref) {
                    var offset = _ref.offset;
                    var placement = data.placement, _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                    var basePlacement = placement.split("-")[0];
                    var offsets = void 0;
                    if (isNumeric(+offset)) {
                        offsets = [ +offset, 0 ];
                    } else {
                        offsets = parseOffset(offset, popper, reference, basePlacement);
                    }
                    if (basePlacement === "left") {
                        popper.top += offsets[0];
                        popper.left -= offsets[1];
                    } else if (basePlacement === "right") {
                        popper.top += offsets[0];
                        popper.left += offsets[1];
                    } else if (basePlacement === "top") {
                        popper.left += offsets[0];
                        popper.top -= offsets[1];
                    } else if (basePlacement === "bottom") {
                        popper.left += offsets[0];
                        popper.top += offsets[1];
                    }
                    data.popper = popper;
                    return data;
                }
                function preventOverflow(data, options) {
                    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
                    if (data.instance.reference === boundariesElement) {
                        boundariesElement = getOffsetParent(boundariesElement);
                    }
                    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
                    options.boundaries = boundaries;
                    var order = options.priority;
                    var popper = data.offsets.popper;
                    var check = {
                        primary: function primary(placement) {
                            var value = popper[placement];
                            if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
                                value = Math.max(popper[placement], boundaries[placement]);
                            }
                            return defineProperty({}, placement, value);
                        },
                        secondary: function secondary(placement) {
                            var mainSide = placement === "right" ? "left" : "top";
                            var value = popper[mainSide];
                            if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
                                value = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height));
                            }
                            return defineProperty({}, mainSide, value);
                        }
                    };
                    order.forEach(function(placement) {
                        var side = [ "left", "top" ].indexOf(placement) !== -1 ? "primary" : "secondary";
                        popper = _extends({}, popper, check[side](placement));
                    });
                    data.offsets.popper = popper;
                    return data;
                }
                function shift(data) {
                    var placement = data.placement;
                    var basePlacement = placement.split("-")[0];
                    var shiftvariation = placement.split("-")[1];
                    if (shiftvariation) {
                        var _data$offsets = data.offsets, reference = _data$offsets.reference, popper = _data$offsets.popper;
                        var isVertical = [ "bottom", "top" ].indexOf(basePlacement) !== -1;
                        var side = isVertical ? "left" : "top";
                        var measurement = isVertical ? "width" : "height";
                        var shiftOffsets = {
                            start: defineProperty({}, side, reference[side]),
                            end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
                        };
                        data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
                    }
                    return data;
                }
                function hide(data) {
                    if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
                        return data;
                    }
                    var refRect = data.offsets.reference;
                    var bound = find(data.instance.modifiers, function(modifier) {
                        return modifier.name === "preventOverflow";
                    }).boundaries;
                    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
                        if (data.hide === true) {
                            return data;
                        }
                        data.hide = true;
                        data.attributes["x-out-of-boundaries"] = "";
                    } else {
                        if (data.hide === false) {
                            return data;
                        }
                        data.hide = false;
                        data.attributes["x-out-of-boundaries"] = false;
                    }
                    return data;
                }
                function inner(data) {
                    var placement = data.placement;
                    var basePlacement = placement.split("-")[0];
                    var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                    var isHoriz = [ "left", "right" ].indexOf(basePlacement) !== -1;
                    var subtractLength = [ "top", "left" ].indexOf(basePlacement) === -1;
                    popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
                    data.placement = getOppositePlacement(placement);
                    data.offsets.popper = getClientRect(popper);
                    return data;
                }
                var modifiers = {
                    shift: {
                        order: 100,
                        enabled: true,
                        fn: shift
                    },
                    offset: {
                        order: 200,
                        enabled: true,
                        fn: offset,
                        offset: 0
                    },
                    preventOverflow: {
                        order: 300,
                        enabled: true,
                        fn: preventOverflow,
                        priority: [ "left", "right", "top", "bottom" ],
                        padding: 5,
                        boundariesElement: "scrollParent"
                    },
                    keepTogether: {
                        order: 400,
                        enabled: true,
                        fn: keepTogether
                    },
                    arrow: {
                        order: 500,
                        enabled: true,
                        fn: arrow,
                        element: "[x-arrow]"
                    },
                    flip: {
                        order: 600,
                        enabled: true,
                        fn: flip,
                        behavior: "flip",
                        padding: 5,
                        boundariesElement: "viewport"
                    },
                    inner: {
                        order: 700,
                        enabled: false,
                        fn: inner
                    },
                    hide: {
                        order: 800,
                        enabled: true,
                        fn: hide
                    },
                    computeStyle: {
                        order: 850,
                        enabled: true,
                        fn: computeStyle,
                        gpuAcceleration: true,
                        x: "bottom",
                        y: "right"
                    },
                    applyStyle: {
                        order: 900,
                        enabled: true,
                        fn: applyStyle,
                        onLoad: applyStyleOnLoad,
                        gpuAcceleration: undefined
                    }
                };
                var Defaults = {
                    placement: "bottom",
                    eventsEnabled: true,
                    removeOnDestroy: false,
                    onCreate: function onCreate() {},
                    onUpdate: function onUpdate() {},
                    modifiers: modifiers
                };
                var Popper$1 = function() {
                    function Popper(reference, popper) {
                        var _this = this;
                        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                        classCallCheck(this, Popper);
                        this.scheduleUpdate = function() {
                            return requestAnimationFrame(_this.update);
                        };
                        this.update = debounce(this.update.bind(this));
                        this.options = _extends({}, Popper.Defaults, options);
                        this.state = {
                            isDestroyed: false,
                            isCreated: false,
                            scrollParents: []
                        };
                        this.reference = reference && reference.jquery ? reference[0] : reference;
                        this.popper = popper && popper.jquery ? popper[0] : popper;
                        this.options.modifiers = {};
                        Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function(name) {
                            _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
                        });
                        this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
                            return _extends({
                                name: name
                            }, _this.options.modifiers[name]);
                        }).sort(function(a, b) {
                            return a.order - b.order;
                        });
                        this.modifiers.forEach(function(modifierOptions) {
                            if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
                                modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
                            }
                        });
                        this.update();
                        var eventsEnabled = this.options.eventsEnabled;
                        if (eventsEnabled) {
                            this.enableEventListeners();
                        }
                        this.state.eventsEnabled = eventsEnabled;
                    }
                    createClass(Popper, [ {
                        key: "update",
                        value: function update$$1() {
                            return update.call(this);
                        }
                    }, {
                        key: "destroy",
                        value: function destroy$$1() {
                            return destroy.call(this);
                        }
                    }, {
                        key: "enableEventListeners",
                        value: function enableEventListeners$$1() {
                            return enableEventListeners.call(this);
                        }
                    }, {
                        key: "disableEventListeners",
                        value: function disableEventListeners$$1() {
                            return disableEventListeners.call(this);
                        }
                    } ]);
                    return Popper;
                }();
                Popper$1.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
                Popper$1.placements = placements;
                Popper$1.Defaults = Defaults;
                var popper = Object.freeze({
                    default: Popper$1
                });
                var _popper = popper && Popper$1 || popper;
                var Popper_1 = createCommonjsModule(function(module, exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    var _extends = Object.assign || function(target) {
                        for (var i = 1; i < arguments.length; i++) {
                            var source = arguments[i];
                            for (var key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    target[key] = source[key];
                                }
                            }
                        }
                        return target;
                    };
                    var _createClass = function() {
                        function defineProperties(target, props) {
                            for (var i = 0; i < props.length; i++) {
                                var descriptor = props[i];
                                descriptor.enumerable = descriptor.enumerable || false;
                                descriptor.configurable = true;
                                if ("value" in descriptor) descriptor.writable = true;
                                Object.defineProperty(target, descriptor.key, descriptor);
                            }
                        }
                        return function(Constructor, protoProps, staticProps) {
                            if (protoProps) defineProperties(Constructor.prototype, protoProps);
                            if (staticProps) defineProperties(Constructor, staticProps);
                            return Constructor;
                        };
                    }();
                    var _react2 = _interopRequireDefault(React);
                    var _propTypes2 = _interopRequireDefault(propTypes);
                    var _popper2 = _interopRequireDefault(_popper);
                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        };
                    }
                    function _defineProperty(obj, key, value) {
                        if (key in obj) {
                            Object.defineProperty(obj, key, {
                                value: value,
                                enumerable: true,
                                configurable: true,
                                writable: true
                            });
                        } else {
                            obj[key] = value;
                        }
                        return obj;
                    }
                    function _objectWithoutProperties(obj, keys) {
                        var target = {};
                        for (var i in obj) {
                            if (keys.indexOf(i) >= 0) continue;
                            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
                            target[i] = obj[i];
                        }
                        return target;
                    }
                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError("Cannot call a class as a function");
                        }
                    }
                    function _possibleConstructorReturn(self, call) {
                        if (!self) {
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        }
                        return call && (typeof call === "object" || typeof call === "function") ? call : self;
                    }
                    function _inherits(subClass, superClass) {
                        if (typeof superClass !== "function" && superClass !== null) {
                            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                        }
                        subClass.prototype = Object.create(superClass && superClass.prototype, {
                            constructor: {
                                value: subClass,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                    }
                    var Popper = function(_Component) {
                        _inherits(Popper, _Component);
                        function Popper() {
                            var _ref;
                            var _temp, _this, _ret;
                            _classCallCheck(this, Popper);
                            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }
                            return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Popper.__proto__ || Object.getPrototypeOf(Popper)).call.apply(_ref, [ this ].concat(args))), 
                            _this), _this.state = {}, _this._setArrowNode = function(node) {
                                _this._arrowNode = node;
                            }, _this._getTargetNode = function() {
                                return _this.context.popperManager.getTargetNode();
                            }, _this._getOffsets = function(data) {
                                return Object.keys(data.offsets).map(function(key) {
                                    return data.offsets[key];
                                });
                            }, _this._isDataDirty = function(data) {
                                if (_this.state.data) {
                                    return JSON.stringify(_this._getOffsets(_this.state.data)) !== JSON.stringify(_this._getOffsets(data));
                                } else {
                                    return true;
                                }
                            }, _this._updateStateModifier = {
                                enabled: true,
                                order: 900,
                                fn: function fn(data) {
                                    if (_this._isDataDirty(data)) {
                                        _this.setState({
                                            data: data
                                        });
                                    }
                                    return data;
                                }
                            }, _this._getPopperStyle = function() {
                                var data = _this.state.data;
                                if (!_this._popper || !data) {
                                    return {
                                        position: "absolute",
                                        pointerEvents: "none",
                                        opacity: 0
                                    };
                                }
                                var _data$offsets$popper = data.offsets.popper, top = _data$offsets$popper.top, left = _data$offsets$popper.left, position = _data$offsets$popper.position;
                                return _extends({
                                    position: position
                                }, data.styles);
                            }, _this._getPopperPlacement = function() {
                                return !!_this.state.data ? _this.state.data.placement : undefined;
                            }, _this._getPopperHide = function() {
                                return !!_this.state.data && _this.state.data.hide ? "" : undefined;
                            }, _this._getArrowStyle = function() {
                                if (!_this.state.data || !_this.state.data.offsets.arrow) {
                                    return {};
                                } else {
                                    var _this$state$data$offs = _this.state.data.offsets.arrow, top = _this$state$data$offs.top, left = _this$state$data$offs.left;
                                    return {
                                        top: top,
                                        left: left
                                    };
                                }
                            }, _temp), _possibleConstructorReturn(_this, _ret);
                        }
                        _createClass(Popper, [ {
                            key: "getChildContext",
                            value: function getChildContext() {
                                return {
                                    popper: {
                                        setArrowNode: this._setArrowNode,
                                        getArrowStyle: this._getArrowStyle
                                    }
                                };
                            }
                        }, {
                            key: "componentDidMount",
                            value: function componentDidMount() {
                                this._updatePopper();
                            }
                        }, {
                            key: "componentDidUpdate",
                            value: function componentDidUpdate(lastProps) {
                                if (lastProps.placement !== this.props.placement || lastProps.eventsEnabled !== this.props.eventsEnabled) {
                                    this._updatePopper();
                                }
                                if (this._popper && lastProps.children !== this.props.children) {
                                    this._popper.scheduleUpdate();
                                }
                            }
                        }, {
                            key: "componentWillUnmount",
                            value: function componentWillUnmount() {
                                this._destroyPopper();
                            }
                        }, {
                            key: "_updatePopper",
                            value: function _updatePopper() {
                                this._destroyPopper();
                                if (this._node) {
                                    this._createPopper();
                                }
                            }
                        }, {
                            key: "_createPopper",
                            value: function _createPopper() {
                                var _props = this.props, placement = _props.placement, eventsEnabled = _props.eventsEnabled;
                                var modifiers = _extends({}, this.props.modifiers, {
                                    applyStyle: {
                                        enabled: false
                                    },
                                    updateState: this._updateStateModifier
                                });
                                if (this._arrowNode) {
                                    modifiers.arrow = {
                                        element: this._arrowNode
                                    };
                                }
                                this._popper = new _popper2.default(this._getTargetNode(), this._node, {
                                    placement: placement,
                                    eventsEnabled: eventsEnabled,
                                    modifiers: modifiers
                                });
                                this._popper.scheduleUpdate();
                            }
                        }, {
                            key: "_destroyPopper",
                            value: function _destroyPopper() {
                                if (this._popper) {
                                    this._popper.destroy();
                                }
                            }
                        }, {
                            key: "render",
                            value: function render() {
                                var _this2 = this;
                                var _props2 = this.props, component = _props2.component, innerRef = _props2.innerRef, placement = _props2.placement, eventsEnabled = _props2.eventsEnabled, modifiers = _props2.modifiers, children = _props2.children, restProps = _objectWithoutProperties(_props2, [ "component", "innerRef", "placement", "eventsEnabled", "modifiers", "children" ]);
                                var popperRef = function popperRef(node) {
                                    _this2._node = node;
                                    if (typeof innerRef === "function") {
                                        innerRef(node);
                                    }
                                };
                                var popperStyle = this._getPopperStyle();
                                var popperPlacement = this._getPopperPlacement();
                                var popperHide = this._getPopperHide();
                                if (typeof children === "function") {
                                    var _popperProps;
                                    var popperProps = (_popperProps = {
                                        ref: popperRef,
                                        style: popperStyle
                                    }, _defineProperty(_popperProps, "data-placement", popperPlacement), _defineProperty(_popperProps, "data-x-out-of-boundaries", popperHide), 
                                    _popperProps);
                                    return children({
                                        popperProps: popperProps,
                                        restProps: restProps,
                                        scheduleUpdate: this._popper && this._popper.scheduleUpdate
                                    });
                                }
                                var componentProps = _extends({}, restProps, {
                                    style: _extends({}, restProps.style, popperStyle),
                                    "data-placement": popperPlacement,
                                    "data-x-out-of-boundaries": popperHide
                                });
                                if (typeof component === "string") {
                                    componentProps.ref = popperRef;
                                } else {
                                    componentProps.innerRef = popperRef;
                                }
                                return (0, React.createElement)(component, componentProps, children);
                            }
                        } ]);
                        return Popper;
                    }(React.Component);
                    Popper.contextTypes = {
                        popperManager: _propTypes2.default.object.isRequired
                    };
                    Popper.childContextTypes = {
                        popper: _propTypes2.default.object.isRequired
                    };
                    Popper.propTypes = {
                        component: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ]),
                        innerRef: _propTypes2.default.func,
                        placement: _propTypes2.default.oneOf(_popper2.default.placements),
                        eventsEnabled: _propTypes2.default.bool,
                        modifiers: _propTypes2.default.object,
                        children: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ])
                    };
                    Popper.defaultProps = {
                        component: "div",
                        placement: "bottom",
                        eventsEnabled: true,
                        modifiers: {}
                    };
                    exports.default = Popper;
                });
                unwrapExports(Popper_1);
                var Arrow_1 = createCommonjsModule(function(module, exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    var _extends = Object.assign || function(target) {
                        for (var i = 1; i < arguments.length; i++) {
                            var source = arguments[i];
                            for (var key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    target[key] = source[key];
                                }
                            }
                        }
                        return target;
                    };
                    var _react2 = _interopRequireDefault(React);
                    var _propTypes2 = _interopRequireDefault(propTypes);
                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        };
                    }
                    function _objectWithoutProperties(obj, keys) {
                        var target = {};
                        for (var i in obj) {
                            if (keys.indexOf(i) >= 0) continue;
                            if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
                            target[i] = obj[i];
                        }
                        return target;
                    }
                    var Arrow = function Arrow(props, context) {
                        var _props$component = props.component, component = _props$component === undefined ? "span" : _props$component, innerRef = props.innerRef, children = props.children, restProps = _objectWithoutProperties(props, [ "component", "innerRef", "children" ]);
                        var popper = context.popper;
                        var arrowRef = function arrowRef(node) {
                            popper.setArrowNode(node);
                            if (typeof innerRef === "function") {
                                innerRef(node);
                            }
                        };
                        var arrowStyle = popper.getArrowStyle();
                        if (typeof children === "function") {
                            var arrowProps = {
                                ref: arrowRef,
                                style: arrowStyle
                            };
                            return children({
                                arrowProps: arrowProps,
                                restProps: restProps
                            });
                        }
                        var componentProps = _extends({}, restProps, {
                            style: _extends({}, arrowStyle, restProps.style)
                        });
                        if (typeof component === "string") {
                            componentProps.ref = arrowRef;
                        } else {
                            componentProps.innerRef = arrowRef;
                        }
                        return (0, React.createElement)(component, componentProps, children);
                    };
                    Arrow.contextTypes = {
                        popper: _propTypes2.default.object.isRequired
                    };
                    Arrow.propTypes = {
                        component: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ]),
                        innerRef: _propTypes2.default.func,
                        children: _propTypes2.default.oneOfType([ _propTypes2.default.node, _propTypes2.default.func ])
                    };
                    exports.default = Arrow;
                });
                unwrapExports(Arrow_1);
                var reactPopper = createCommonjsModule(function(module, exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.Arrow = exports.Popper = exports.Target = exports.Manager = undefined;
                    var _Manager3 = _interopRequireDefault(Manager_1);
                    var _Target3 = _interopRequireDefault(Target_1);
                    var _Popper3 = _interopRequireDefault(Popper_1);
                    var _Arrow3 = _interopRequireDefault(Arrow_1);
                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        };
                    }
                    exports.Manager = _Manager3.default;
                    exports.Target = _Target3.default;
                    exports.Popper = _Popper3.default;
                    exports.Arrow = _Arrow3.default;
                });
                unwrapExports(reactPopper);
                var reactPopper_1 = reactPopper.Arrow;
                var reactPopper_2 = reactPopper.Popper;
                var reactPopper_3 = reactPopper.Target;
                var reactPopper_4 = reactPopper.Manager;
                var randomID = createCommonjsModule(function(module) {
                    (function() {
                        var randomID = function(len, pattern) {
                            var possibilities = [ "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "0123456789", "~!@#$%^&()_+-={}[];'," ];
                            var chars = "";
                            var pattern = pattern ? pattern : "aA0";
                            pattern.split("").forEach(function(a) {
                                if (!isNaN(parseInt(a))) {
                                    chars += possibilities[2];
                                } else if (/[a-z]/.test(a)) {
                                    chars += possibilities[0];
                                } else if (/[A-Z]/.test(a)) {
                                    chars += possibilities[1];
                                } else {
                                    chars += possibilities[3];
                                }
                            });
                            var len = len ? len : 30;
                            var result = "";
                            while (len--) {
                                result += chars.charAt(Math.floor(Math.random() * chars.length));
                            }
                            return result;
                        };
                        if ("object" !== "undefined" && typeof commonjsRequire !== "undefined") {
                            module.exports = randomID;
                        } else {
                            window["randomID"] = randomID;
                        }
                    })();
                });
                var jsx = function() {
                    var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 60103;
                    return function createRawReactElement(type, props, key, children) {
                        var defaultProps = type && type.defaultProps;
                        var childrenLength = arguments.length - 3;
                        if (!props && childrenLength !== 0) {
                            props = {};
                        }
                        if (props && defaultProps) {
                            for (var propName in defaultProps) {
                                if (props[propName] === void 0) {
                                    props[propName] = defaultProps[propName];
                                }
                            }
                        } else if (!props) {
                            props = defaultProps || {};
                        }
                        if (childrenLength === 1) {
                            props.children = children;
                        } else if (childrenLength > 1) {
                            var childArray = Array(childrenLength);
                            for (var i = 0; i < childrenLength; i++) {
                                childArray[i] = arguments[i + 3];
                            }
                            props.children = childArray;
                        }
                        return {
                            $$typeof: REACT_ELEMENT_TYPE,
                            type: type,
                            key: key === undefined ? null : "" + key,
                            ref: null,
                            props: props,
                            _owner: null
                        };
                    };
                }();
                var asyncGenerator = function() {
                    function AwaitValue(value) {
                        this.value = value;
                    }
                    function AsyncGenerator(gen) {
                        var front, back;
                        function send(key, arg) {
                            return new Promise(function(resolve, reject) {
                                var request = {
                                    key: key,
                                    arg: arg,
                                    resolve: resolve,
                                    reject: reject,
                                    next: null
                                };
                                if (back) {
                                    back = back.next = request;
                                } else {
                                    front = back = request;
                                    resume(key, arg);
                                }
                            });
                        }
                        function resume(key, arg) {
                            try {
                                var result = gen[key](arg);
                                var value = result.value;
                                if (value instanceof AwaitValue) {
                                    Promise.resolve(value.value).then(function(arg) {
                                        resume("next", arg);
                                    }, function(arg) {
                                        resume("throw", arg);
                                    });
                                } else {
                                    settle(result.done ? "return" : "normal", result.value);
                                }
                            } catch (err) {
                                settle("throw", err);
                            }
                        }
                        function settle(type, value) {
                            switch (type) {
                              case "return":
                                front.resolve({
                                    value: value,
                                    done: true
                                });
                                break;

                              case "throw":
                                front.reject(value);
                                break;

                              default:
                                front.resolve({
                                    value: value,
                                    done: false
                                });
                                break;
                            }
                            front = front.next;
                            if (front) {
                                resume(front.key, front.arg);
                            } else {
                                back = null;
                            }
                        }
                        this._invoke = send;
                        if (typeof gen.return !== "function") {
                            this.return = undefined;
                        }
                    }
                    if (typeof Symbol === "function" && Symbol.asyncIterator) {
                        AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
                            return this;
                        };
                    }
                    AsyncGenerator.prototype.next = function(arg) {
                        return this._invoke("next", arg);
                    };
                    AsyncGenerator.prototype.throw = function(arg) {
                        return this._invoke("throw", arg);
                    };
                    AsyncGenerator.prototype.return = function(arg) {
                        return this._invoke("return", arg);
                    };
                    return {
                        wrap: function(fn) {
                            return function() {
                                return new AsyncGenerator(fn.apply(this, arguments));
                            };
                        },
                        await: function(value) {
                            return new AwaitValue(value);
                        }
                    };
                }();
                var classCallCheck$1 = function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                };
                var createClass$1 = function() {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();
                var _extends$1 = Object.assign || function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) {
                            if (Object.prototype.hasOwnProperty.call(source, key)) {
                                target[key] = source[key];
                            }
                        }
                    }
                    return target;
                };
                var inherits = function(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                };
                var possibleConstructorReturn = function(self, call) {
                    if (!self) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return call && (typeof call === "object" || typeof call === "function") ? call : self;
                };
                var _ref3 = jsx("feGaussianBlur", {
                    in: "SourceAlpha",
                    stdDeviation: 3
                });
                var _ref4 = jsx("feOffset", {
                    dx: 7,
                    dy: 1,
                    result: "offsetblur"
                });
                var _ref5 = jsx("feComponentTransfer", {}, void 0, jsx("feFuncA", {
                    type: "linear",
                    slope: "0.2"
                }));
                var _ref6 = jsx("feMerge", {}, void 0, jsx("feMergeNode", {}), jsx("feMergeNode", {
                    in: "SourceGraphic"
                }));
                var ArrowComponent = function(_React$Component) {
                    inherits(ArrowComponent, _React$Component);
                    function ArrowComponent() {
                        classCallCheck$1(this, ArrowComponent);
                        var _this = possibleConstructorReturn(this, (ArrowComponent.__proto__ || Object.getPrototypeOf(ArrowComponent)).call(this));
                        _this.id = randomID(19, "a");
                        return _this;
                    }
                    createClass$1(ArrowComponent, [ {
                        key: "render",
                        value: function render() {
                            var _props = this.props, dataPlacement = _props.dataPlacement, customArrow = _props.customArrow;
                            var id = this.id;
                            var _ref2 = jsx("defs", {
                                xmlns: "http://www.w3.org/2000/svg"
                            }, void 0, jsx("filter", {
                                id: id,
                                height: "130%"
                            }, void 0, _ref3, _ref4, _ref5, _ref6));
                            return jsx(reactPopper_1, {}, void 0, function(_ref) {
                                var arrowProps = _ref.arrowProps;
                                arrowProps.style.position = "absolute";
                                if (/right/gi.test(dataPlacement)) {
                                    arrowProps.style.transform = "rotate(-180deg)";
                                    arrowProps.style.left = "-19px";
                                } else if (/bottom/gi.test(dataPlacement)) {
                                    arrowProps.style.transform = "rotate(-90deg)";
                                    arrowProps.style.top = "-20px";
                                } else if (/top/gi.test(dataPlacement)) {
                                    arrowProps.style.transform = "rotate(90deg)";
                                    arrowProps.style.bottom = "-21px";
                                } else if (/left/gi.test(dataPlacement)) {
                                    arrowProps.style.right = "-19px";
                                }
                                return customArrow ? React.createElement("span", arrowProps, customArrow) : React.createElement("span", arrowProps, jsx("svg", {
                                    xmlnsXlink: "http://www.w3.org/1999/xlink",
                                    viewBox: "0 0 100 100",
                                    version: "1.1",
                                    x: "0px",
                                    y: "0px",
                                    width: 30,
                                    height: 30
                                }, void 0, _ref2, jsx("polygon", {
                                    filter: "url(#" + id + ")",
                                    points: "36 23 64 55 36 80",
                                    fill: "#fff",
                                    fillRule: "evenodd"
                                })));
                            });
                        }
                    } ]);
                    return ArrowComponent;
                }(React.Component);
                var PopoverComponent = function(_React$Component) {
                    inherits(PopoverComponent, _React$Component);
                    function PopoverComponent(props) {
                        classCallCheck$1(this, PopoverComponent);
                        var _this = possibleConstructorReturn(this, (PopoverComponent.__proto__ || Object.getPrototypeOf(PopoverComponent)).call(this, props));
                        _this.click = _this.click.bind(_this);
                        _this.onMouseOver = _this.onMouseOver.bind(_this);
                        _this.closePopoverOnMouseLeave = _this.closePopoverOnMouseLeave.bind(_this);
                        return _this;
                    }
                    createClass$1(PopoverComponent, [ {
                        key: "closePopoverOnMouseLeave",
                        value: function closePopoverOnMouseLeave(e) {
                            e.preventDefault();
                            this.props.onClosePopover();
                        }
                    }, {
                        key: "click",
                        value: function click(e) {
                            var thispopover = this.refs.popover._node;
                            var close = e.target.closest(".popover-content");
                            if (!close) {
                                this.props.onClosePopover();
                            } else {
                                var child_popover = thispopover.querySelector(".popover-content");
                                if (!child_popover) {
                                    if (close.getAttribute("data-id") != thispopover.getAttribute("data-id")) {
                                        this.props.onClosePopover();
                                    }
                                }
                            }
                        }
                    }, {
                        key: "componentWillUnmount",
                        value: function componentWillUnmount() {
                            var _props = this.props, action = _props.action, onClose = _props.onClose;
                            if (action === "click") {
                                document.removeEventListener("click", this.click, false);
                            } else if (action === "hover") {
                                document.removeEventListener("mouseover", this.onMouseOver, false);
                                this.refs.popover._node.removeEventListener("mouseleave", this.closePopoverOnMouseLeave, false);
                            }
                            if (onClose) onClose();
                        }
                    }, {
                        key: "onMouseOver",
                        value: function onMouseOver(e) {
                            var popover = this.refs.popover._node;
                            var child = popover.querySelector(".popover-content");
                            if (!child) {
                                popover.addEventListener("mouseleave", this.closePopoverOnMouseLeave, false);
                            }
                            if (!e.target.closest(".manager")) {
                                this.props.onClosePopover();
                            }
                        }
                    }, {
                        key: "componentDidMount",
                        value: function componentDidMount() {
                            var _props2 = this.props, action = _props2.action, onOpen = _props2.onOpen;
                            if (action === "click") {
                                document.addEventListener("click", this.click, false);
                            } else if (action === "hover") {
                                document.addEventListener("mouseover", this.onMouseOver, false);
                            }
                            if (onOpen) onOpen();
                        }
                    }, {
                        key: "render",
                        value: function render() {
                            var _props3 = this.props, placement = _props3.placement, modifiers = _props3.modifiers, arrow = _props3.arrow, className = _props3.className, motion = _props3.motion, id = _props3.id, customArrow = _props3.customArrow, children = _props3.children;
                            return React.createElement(reactPopper_2, {
                                placement: placement,
                                modifiers: modifiers,
                                ref: "popover"
                            }, function(_ref) {
                                var popperProps = _ref.popperProps;
                                popperProps.className = "popover-content";
                                if (arrow) {
                                    if (popperProps["data-placement"]) {
                                        popperProps.className = "popover-content rap-" + popperProps["data-placement"].split("-")[0];
                                    }
                                }
                                if (className) {
                                    popperProps.className += " " + className;
                                }
                                popperProps.style.width = "250px";
                                if (motion) {
                                    var ArrowCallback = arrow ? jsx(ArrowComponent, {
                                        customArrow: customArrow,
                                        dataPlacement: popperProps["data-placement"]
                                    }) : null;
                                    return children[1]({
                                        "data-id": id
                                    }, popperProps, ArrowCallback);
                                } else {
                                    return React.createElement("div", _extends$1({}, popperProps, {
                                        "data-id": id
                                    }), jsx("div", {}, void 0, children[1], arrow ? jsx(ArrowComponent, {
                                        customArrow: customArrow,
                                        dataPlacement: popperProps["data-placement"]
                                    }) : null));
                                }
                            });
                        }
                    } ]);
                    return PopoverComponent;
                }(React.Component);
                var TargetComponent = function(_React$Component) {
                    inherits(TargetComponent, _React$Component);
                    function TargetComponent(props) {
                        classCallCheck$1(this, TargetComponent);
                        var _this = possibleConstructorReturn(this, (TargetComponent.__proto__ || Object.getPrototypeOf(TargetComponent)).call(this, props));
                        _this.click = _this.click.bind(_this);
                        _this.onMouseEnter = _this.onMouseEnter.bind(_this);
                        _this.onMouseLeave = _this.onMouseLeave.bind(_this);
                        return _this;
                    }
                    createClass$1(TargetComponent, [ {
                        key: "onMouseLeave",
                        value: function onMouseLeave(e) {
                            var getElement = e.relatedTarget;
                            if (getElement && getElement.nodeName) {
                                var close = getElement.closest(".manager");
                                if (close) {
                                    var hasDataId = close.hasAttribute("data-target-id");
                                    if (hasDataId) {
                                        var getDataId = close.getAttribute("data-target-id");
                                        if (getDataId) {
                                            if (getDataId != this.props.id) this.props.closePopover();
                                        }
                                    }
                                }
                            }
                        }
                    }, {
                        key: "onMouseEnter",
                        value: function onMouseEnter() {
                            this.props.openPopover();
                        }
                    }, {
                        key: "componentDidMount",
                        value: function componentDidMount() {
                            var action = this.props.action;
                            var target = ReactDOM.findDOMNode(this);
                            this.target = target;
                            if (action === "click") {
                                target.addEventListener("click", this.click, false);
                            } else if (action === "hover") {
                                target.addEventListener("mouseenter", this.onMouseEnter, false);
                                target.addEventListener("mouseleave", this.onMouseLeave, false);
                            }
                        }
                    }, {
                        key: "componentWillUnmount",
                        value: function componentWillUnmount() {
                            var _props = this.props, action = _props.action;
                            if (action === "click") {
                                this.target.removeEventListener("click", this.click, false);
                            } else if (action === "hover") {
                                this.target.removeEventListener("mouseenter", this.onMouseEnter, false);
                                this.target.removeEventListener("mouseleave", this.onMouseLeave, false);
                            }
                        }
                    }, {
                        key: "click",
                        value: function click(e) {
                            e.stopImmediatePropagation();
                            if (!e.target.nextSibling) this.props.tooglePopover();
                        }
                    }, {
                        key: "render",
                        value: function render() {
                            var _this2 = this;
                            return jsx(reactPopper_3, {}, void 0, function(_ref) {
                                var targetProps = _ref.targetProps;
                                return React.createElement("div", _extends$1({
                                    className: "target-container"
                                }, targetProps), _this2.props.children);
                            });
                        }
                    } ]);
                    return TargetComponent;
                }(React.Component);
                function closestWebshim() {
                    if (window.Element && !Element.prototype.closest) {
                        Element.prototype.closest = function(s) {
                            var matches = (this.document || this.ownerDocument).querySelectorAll(s), i, el = this;
                            do {
                                i = matches.length;
                                while (--i >= 0 && matches.item(i) !== el) {}
                            } while (i < 0 && (el = el.parentElement));
                            return el;
                        };
                    }
                }
                var Popover$1 = function(_React$Component) {
                    inherits(Popover, _React$Component);
                    function Popover(props) {
                        classCallCheck$1(this, Popover);
                        var _this = possibleConstructorReturn(this, (Popover.__proto__ || Object.getPrototypeOf(Popover)).call(this, props));
                        _this.closePopover = _this.closePopover.bind(_this);
                        _this.tooglePopover = _this.tooglePopover.bind(_this);
                        _this.openPopover = _this.openPopover.bind(_this);
                        _this.state = {
                            isOpen: props.defaultIsOpen,
                            id: randomID(10, "a")
                        };
                        return _this;
                    }
                    createClass$1(Popover, [ {
                        key: "componentWillMount",
                        value: function componentWillMount() {
                            closestWebshim();
                        }
                    }, {
                        key: "openPopover",
                        value: function openPopover() {
                            this.setState({
                                isOpen: true
                            });
                        }
                    }, {
                        key: "tooglePopover",
                        value: function tooglePopover() {
                            this.setState({
                                isOpen: !this.state.isOpen
                            });
                        }
                    }, {
                        key: "closePopover",
                        value: function closePopover() {
                            this.setState({
                                isOpen: false
                            });
                        }
                    }, {
                        key: "componentWillReceiveProps",
                        value: function componentWillReceiveProps(_ref) {
                            var open = _ref.open;
                            this.setState({
                                isOpen: open
                            });
                        }
                    }, {
                        key: "render",
                        value: function render() {
                            var _props = this.props, className = _props.className, onClose = _props.onClose, onOpen = _props.onOpen, customArrow = _props.customArrow, arrow = _props.arrow, onClick = _props.onClick, placement = _props.placement, modifiers = _props.modifiers, render = _props.render, action = _props.action, motion = _props.motion, children = _props.children;
                            return jsx(reactPopper_4, {
                                className: "manager",
                                style: {
                                    display: "inline"
                                },
                                "data-target-id": this.state.id
                            }, void 0, jsx(TargetComponent, {
                                id: this.state.id,
                                closePopover: this.closePopover,
                                openPopover: this.openPopover,
                                tooglePopover: this.tooglePopover,
                                action: action
                            }, void 0, children[0]), this.state.isOpen ? React.createElement(PopoverComponent, _extends$1({
                                key: Math.random(1),
                                motion: motion,
                                className: className,
                                onClose: onClose,
                                onOpen: onOpen,
                                customArrow: customArrow,
                                onClosePopover: this.closePopover,
                                placement: placement,
                                modifiers: modifiers
                            }, this.props, {
                                id: this.state.id
                            })) : null);
                        }
                    } ]);
                    return Popover;
                }(React.Component);
                Popover$1.defaultProps = {
                    arrow: true,
                    placement: "auto",
                    action: "click",
                    modifiers: {},
                    motion: false,
                    className: undefined,
                    defaultIsOpen: false,
                    open: false
                };
                return Popover$1;
            });
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
        react: "react",
        "react-dom": "react-dom"
    } ],
    Form: [ function(require, module, exports) {
        var React = require("react");
        var ReactDOM = require("react-dom");
        var CommonMixin = require("./components/CommonMixin");
        var FormPanel = require("./components/FormPanel");
        CommonMixin.init();
        var Form = {
            getFormSection: function(cmpId, id, json, formMode, isShowErrMsg, cb) {
                ReactDOM.render(React.createElement(FormPanel, {
                    cmpId: cmpId,
                    formInfo: json,
                    formMode: formMode,
                    isShowErrMsg: isShowErrMsg,
                    callMe: cb
                }), document.getElementById(id));
            },
            setFormMode: function(cmpId, json, val, isShowErrMsg, cb) {
                CommonMixin.setFormMode(cmpId, json, val, isShowErrMsg, cb);
            },
            getFormSectionJSON: function(cmpId, json, exportJson) {
                return CommonMixin.getFormSectionJSON(cmpId, json, exportJson);
            },
            getFormSectionData: function(cmpId) {
                return CommonMixin.getFormSectionData(cmpId);
            },
            getDiffJson: function(currentJsonData, validJsonData) {
                return CommonMixin.getDiffJson(currentJsonData, validJsonData);
            },
            getDiffJson: function(currentJsonData, validJsonData) {
                return CommonMixin.getDiffJson(currentJsonData, validJsonData);
            },
            validateForm: function(formMode, cmpId, initiallyStartup, errFldClr) {
                return CommonMixin.validateForm(formMode, cmpId, initiallyStartup, errFldClr);
            },
            hasDataValidationIssues: function(cmpId, showFormErr) {
                return CommonMixin.hasDataValidationIssues(cmpId, showFormErr);
            },
            hasStructureValidationIssues: function(cmpId) {
                return CommonMixin.hasStructureValidationIssues(cmpId);
            },
            formRenderedAt: function(cmpId) {
                return CommonMixin.formRenderedAt(cmpId);
            }
        };
        module.exports = Form;
    }, {
        "./components/CommonMixin": 4,
        "./components/FormPanel": 9,
        react: "react",
        "react-dom": "react-dom"
    } ]
}, {}, []);